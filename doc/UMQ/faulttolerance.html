<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Guide to Queuing: Fault Tolerance</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen_manual.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Guide to Queuing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('faulttolerance.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Fault Tolerance </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>UMQ uses multiple techniques to ensure that messages reach their destinations. These techniques include the storage and verification of messages and node redundancy.</p>
<p>Ultra Messaging queuing systems use message persistence to confirm to the source application that a message is stored on a broker queue. The source no longer needs to hold a copy of that message. Message durability holds the message in the queue until the receiver application sends a consumption acknowledgement to the queue. These techniques help ensure messages reach their destination if a connection, source, or receiver fails.</p>
<p>An Ultra Messaging high-availability queuing system uses three broker nodes, which can all reside on separate machines. One broker actively handles message traffic while the other two serve as hot standby brokers. If the active broker or broker host fails, messaging can continue relatively uninterrupted.</p>
<p><br />
 </p>
<h1><a class="anchor" id="messagereliability"></a>
Message Reliability&nbsp;&nbsp;<small><a href="#messagereliability">&lt;-</a></small></h1>
<p>To ensure that messages reach receiver applications, Ultra Messaging uses message stability, persistence, and consumption reporting.</p>
<p><br />
 </p>
<h2><a class="anchor" id="messagestability"></a>
Message Stability&nbsp;&nbsp;<small><a href="#messagestability">&lt;-</a></small></h2>
<p>Message stability is an indication that the broker has received a message from the source.</p>
<p>The broker confirms receipt of each message it receives from the sending client application. When at least two nodes acknowledge message stability, the active broker sends a stability acknowledgment back to the source.</p>
<p>Typically, after a source sends a message, it retains that message because it might need to retransmit the message. When the source receives a stability acknowledgment, it can then discard the message. During the period after the source sends the message until the source receives the stability acknowledgment, the message status is in flight. If a broker or broker connection fails, the source application can retain the in-flight messages for retransmission.</p>
<p><br />
 </p>
<h2><a class="anchor" id="messageconsumption"></a>
Message Consumption&nbsp;&nbsp;<small><a href="#messageconsumption">&lt;-</a></small></h2>
<p>Message consumption is an indication that the receiving client application has processed a message from the broker.</p>
<p>The receiving client application receives and processes each message from the broker. After the callback delivers the message and returns, Ultra Messaging automatically tells the broker that the message is consumed.</p>
<p>After a broker sends a message, it retains that message because it might need to retransmit the message if the receiver application or connection to the receiver application fails. When the broker receives a message consumption acknowledgment, it can then discard the message.</p>
<p><br />
 </p>
<h2><a class="anchor" id="messagepersistence"></a>
Message Persistence&nbsp;&nbsp;<small><a href="#messagepersistence">&lt;-</a></small></h2>
<p>By default, queuing sources set all messages to be persisted. When the broker receives a message that is set for persistence, the broker holds that message in long-term storage until the receiving client application consumes the message.</p>
<p>To set persistence in a message, you must set the JMSDeliveryMode message property for the message. The following example shows a way that you can set a message property to persistent:</p>
<pre class="fragment">/* setup */
memset(&amp;info, 0, sizeof(lbm_src_send_ex_info_t));
info.flags = LBM_SRC_SEND_EX_FLAG_PROPERTIES;
lbm_msg_properties_create(&amp;info.properties);

/* set a user defined message property */
value = 2;
ret = lbm_msg_properties_set(info.properties, "JMSDeliveryMode",
                             (void *) &amp;value, LBM_MSG_PROPERTY_INT,
                             sizeof(int32_t));
assert(ret==LBM_OK);
</pre><p><br />
 </p>
<h1><a class="anchor" id="noderedundancy"></a>
Node Redundancy&nbsp;&nbsp;<small><a href="#noderedundancy">&lt;-</a></small></h1>
<p>A high availability queuing system uses three host machines on which to run the components of a node. This deployment uses redundancy for processes and for persistence storage.</p>
<p><br />
 </p>
<h2><a class="anchor" id="highavailability"></a>
High Availability&nbsp;&nbsp;<small><a href="#highavailability">&lt;-</a></small></h2>
<p>To use configure an Ultra Messaging queuing system for high availability, you must use the queuing three-node deployment. Each node resides on a different host, to eliminate any broker single point of failure.</p>
<p>The following image shows a high-availability queuing system with one source application, one receiver application, and three brokers:</p>
<div class="image">
<img src="3_node_topo1.png" alt="3_node_topo1.png"/>
</div>
 <p>The source application sends a persistent message to the active broker. For each persistent message, the active broker performs the following operations:</p>
<ol>
<li>
The active broker receives the persistent message from the source application and attempts to persist the message to disk before adding it to its queue in memory. </li>
<li>
The active broker requests that its UM persistence adapter persist to disk the status that the message is added to its queue. </li>
<li>
The UM persistence adapter replicates an add message event to all UM persistence adapters in the standby brokers and itself, and to all UMP stores. </li>
<li>
The active broker waits until it receives stability from a majority of the UMP stores. </li>
<li>
The active broker puts the message into its queue and sends a response back to the source application that the message is stable and has been persisted to disk. </li>
<li>
The broker assigns the message to an eligible receiver and requests that its UM persistence adapter persist to disk the status that the message is assigned. </li>
<li>
The UM persistence adapter replicates an update message event to the standby UM persistence adapters and to all UMP stores. </li>
<li>
The active broker waits until it receives stability from a majority of the UMP stores. </li>
<li>
The active broker sends the message to the receiver application. </li>
<li>
The receiver application processes the message and then tells the broker that the message is consumed. </li>
<li>
The active broker requests that its UM persistence adapter persist to disk the status that the message is removed from its queue. </li>
<li>
The UM persistence adapter replicates a remove message event to the standby UM persistence adapters and to all UMP stores. </li>
<li>
The active broker waits until it receives stability from a majority of the UMP stores. </li>
<li>
The active broker removes the message from its queue in memory. </li>
</ol>
<p>This configuration keeps all three UMP stores up to date with the latest messages and their statuses. If the active node fails, either standby node is ready to continue with the message broker service, and the standby brokers elect a new active broker.</p>
<p><br />
 </p>
<h2><a class="anchor" id="highavailabilitysysteminitiation"></a>
High Availability System Initiation&nbsp;&nbsp;<small><a href="#highavailabilitysysteminitiation">&lt;-</a></small></h2>
<p>A high availability queuing system follows an initiation procedure when you first start the system.</p>
<p>When a high availability queuing system first starts, it must determine which node is the active node and which nodes are the standby nodes. The brokers do this through an active-broker election process. The queuing system performs the following initiation actions:</p>
<ol>
<li>
All nodes start. </li>
<li>
The nodes elect an active broker, which opens a transport connection for client applications. The other brokers become standby brokers and do not open connections. </li>
<li>
Client applications start. </li>
<li>
Client applications try broker addresses from the list of addresses to determine which broker is active. </li>
<li>
Client applications initiate and complete registration with the active broker. </li>
</ol>
<p><br />
 </p>
<h1><a class="anchor" id="nodefailover"></a>
Node Failover&nbsp;&nbsp;<small><a href="#nodefailover">&lt;-</a></small></h1>
<p>If an active broker fails, Ultra Messaging starts a reelection process to elect a new active broker.</p>
<p>The following image shows the change after an active broker fails and the queuing system elects a new active broker:</p>
<div class="image">
<img src="3_node_topo_failove.png" alt="3_node_topo_failove.png"/>
</div>
 <p>In this example, Broker1 has failed and disconnected from the client applications. The client applications then try all IP and port addresses on their broker option list until they find an open socket to connect to. If a client application does not find an active broker, it waits and then tries the list again. This cycle continues until the system elects a new active broker.</p>
<p>After Broker1 failure, Ultra Messaging Broker3 to be the new active broker. The clients then connect to, and register with, the newly active broker. After registration, the clients can resume messaging.</p>
<p>Active and standby brokers send a periodic heartbeat message to each other. If standby brokers do not receive any heartbeat message from the active broker then the standby brokers elect a new active broker.</p>
<p>If an active broker does not receive heartbeat messages from any standby brokers, the active broker becomes a standby broker. The queuing system fails when a quorum of brokers no longer exists. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
</body>
</html>
