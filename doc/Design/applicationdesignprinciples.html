<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Concepts Guide: Application Design Principles</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen_manual.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Concepts Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('applicationdesignprinciples.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Application Design Principles </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><br />
 </p>
<h1><a class="anchor" id="messagereception"></a>
Message Reception&nbsp;&nbsp;<small><a href="#messagereception">&lt;-</a></small></h1>
<p>Applications receive messages from UM via application callback. The application registers its callback function with UM during the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aa7491c50fefbc2b70f8035fce7ac1477">creation</a> of the <a class="el" href="umobjects.html#receiverobject">Receiver Object</a>. As messages are received, the application's receiver callback function is called, passing in the received message.</p>
<p>Note: there are events other than message reception that can trigger calls to the application's receiver callback. Those other event types are not covered in this section (see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/api.tag:../API/" href="../API/structlbm__msg__t__stct.html#ab25327dc4b4ebf527106f6e708dbc05f">lbm_msg_t_stct::type</a>).</p>
<p>At a high level, there are two general approaches to handling received messages: </p><ul>
<li>
Message is fully processed when the application's receiver callback returns. </li>
<li>
Message must be retained by the application after the receiver callback returns for further processing. </li>
</ul>
<p>These two approaches have slightly different rules for the application, depending on the implementation language, and also depending on if you are using an <a class="el" href="umobjects.html#eventqueueobject">Event Queue Object</a> for delivery of messages.</p>
<p>Here are the models you should follow for coding your application's receiver callback.</p>
<p><br />
 </p>
<h2><a class="anchor" id="cmessagereception"></a>
C Message Reception&nbsp;&nbsp;<small><a href="#cmessagereception">&lt;-</a></small></h2>
<p><b>C: Fully Process Message in Receiver Callback: Context Thread</b></p>
<p>This use case assumes that the context thread is calling the receiver callback function (i.e. an <a class="el" href="umobjects.html#eventqueueobject">Event Queue Object</a> is NOT being used).</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> my_receiver_callback(<a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a0a4af6b8247cc5a0a24a8578fb6e83bd">lbm_rcv_t</a> *rcv, <a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/api.tag:../API/" href="../API/structlbm__msg__t__stct.html">lbm_msg_t</a> *msg, <span class="keywordtype">void</span> *clientd)</div><div class="line">{</div><div class="line">  <span class="keywordflow">switch</span> (msg-&gt;<a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/api.tag:../API/" href="../API/structlbm__msg__t__stct.html#ab25327dc4b4ebf527106f6e708dbc05f">type</a>) {</div><div class="line">    <span class="keywordflow">case</span> <a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aa47eb604db7dc9fd53f9650ed940e058">LBM_MSG_DATA</a>:</div><div class="line">      my_process_received_message(msg);</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Handle other receiver events. */</span></div><div class="line">  }  <span class="comment">/* switch */</span></div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}  <span class="comment">/* my_receiver_callback */</span></div></div><!-- fragment --><p>Important rules regarding the receiver callback function when called by the context thread: </p><ul>
<li>
The function must return 0. </li>
<li>
The passed-in message must not be modified. </li>
<li>
The function should not perform any operation that might be time consuming or put the thread to sleep (block). This is because any delays in your callback prevents the context thread from servicing its sockets, increasing the risk of packet loss. </li>
<li>
If sending a normal UM message, non-blocking sends must be used (see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ab8a470f02029480f179cc4872b7fa713">LBM_SRC_NONBLOCK</a>). And the code should be written to handle a send failure of <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a75f0f83b8684df30d9816210cc20b4b0">LBM_EWOULDBLOCK</a>. </li>
<li>
It is not allowed to create/delete sources or receivers, or subscribe/unsubscribe from a <a class="el" href="umfeatures.html#spectrum">Spectrum</a> channel from a callback function executed by the context thread. </li>
<li>
You may schedule UM timers. </li>
</ul>
<p>If this is a Persistent receiver, see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/ume.tag:../UME/" href="../UME/designingpersistentreceivers.html#persistencemessageconsumption">Persistence Message Consumption</a>.</p>
<p><b>C: Fully Process Message in Receiver Callback: Event Queue</b></p>
<p>This use case assumes that an <a class="el" href="umobjects.html#eventqueueobject">Event Queue Object</a> is being used. So the receiver callback function is called by the event queue dispatch thread.</p>
<p>The code itself is identical to the context thread case above.</p>
<p>The rules are similar, with some important differences: </p><ul>
<li>
The function must return 0. </li>
<li>
The passed-in message must not be modified. </li>
<li>
The application is permitted to perform operations that are time consuming and/or blocking, as long as the average message processing rate is greater than the average message sending rate. Any temporary delays will buffer messages in the event queue. </li>
<li>
Blocking or non-blocking sends may be used, according to the application's preferences. </li>
<li>
You may create/delete sources or receivers, or subscribe/unsubscribe from a <a class="el" href="umfeatures.html#spectrum">Spectrum</a> channel. However, the receiver which is delivering the current message should not be deleted. </li>
<li>
You may schedule UM timers. </li>
</ul>
<p>If this is a Persistent receiver, see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/ume.tag:../UME/" href="../UME/designingpersistentreceivers.html#persistencemessageconsumption">Persistence Message Consumption</a>.</p>
<p><b>C: Message Retained After Receiver Callback Returns</b></p>
<p>This use case assumes that some or all messages require additional processing after the receiver callback returns.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> my_receiver_callback(<a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a0a4af6b8247cc5a0a24a8578fb6e83bd">lbm_rcv_t</a> *rcv, <a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/api.tag:../API/" href="../API/structlbm__msg__t__stct.html">lbm_msg_t</a> *msg, <span class="keywordtype">void</span> *clientd)</div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span> err, more_processing_needed;</div><div class="line"></div><div class="line">  <span class="keywordflow">switch</span> (msg-&gt;<a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/api.tag:../API/" href="../API/structlbm__msg__t__stct.html#ab25327dc4b4ebf527106f6e708dbc05f">type</a>) {</div><div class="line">    <span class="keywordflow">case</span> <a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aa47eb604db7dc9fd53f9650ed940e058">LBM_MSG_DATA</a>:</div><div class="line">      more_processing_needed = my_process_received_message(msg);</div><div class="line">      <span class="keywordflow">if</span> (more_processing_needed) {</div><div class="line">        err = <a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a2b7788ff58f9e78bc89ea890dad0cccf">lbm_msg_retain</a>(msg);  <span class="comment">/* Check and handle errors. */</span></div><div class="line">        my_save_message_for_more_processing(msg);</div><div class="line">      }</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Handle other receiver events. */</span></div><div class="line">  }  <span class="comment">/* switch */</span></div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}  <span class="comment">/* my_receiver_callback */</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">void my_additional_processing(<a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/api.tag:../API/" href="../API/structlbm__msg__t__stct.html">lbm_msg_t</a> *msg)</div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span> err;</div><div class="line">  my_finish_processing_received_message(msg);</div><div class="line">  err = <a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aa5fc1eb324a55b8c800c31460b0f0116">lbm_msg_delete</a>(msg);  <span class="comment">/* Check and handle errors. */</span></div><div class="line">}  <span class="comment">/* my_additional_processing */</span></div></div><!-- fragment --><p>The main point of this example is the presence of the calls to <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a2b7788ff58f9e78bc89ea890dad0cccf">lbm_msg_retain()</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aa5fc1eb324a55b8c800c31460b0f0116">lbm_msg_delete()</a>. By default, when a receiver callback returns, the UM message is implicitly deleted. To prevent that from happening, the message must be "retained". If an application retains a message, then it has a responsibility to subsequently delete it.</p>
<p>The my_save_message_for_more_processing() function is just whatever you need to transfer the message for further processing. The my_additional_processing() function is typically called by you when you are ready to complete processing of the message.</p>
<p>The rules for the receiver callback are the same as those above, depending on whether an event queue is in use. However, the application must ensure that every message that is retained (<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a2b7788ff58f9e78bc89ea890dad0cccf">lbm_msg_retain()</a>) is subsequently deleted (lbm_message_delete()).</p>
<p>The rules for "my_additional_processing()" function depend on how it is being called. For example, an application might arrange to have it called via a different UM callback (e.g. a timer). In that case, it has the same rules as the receiver callback.</p>
<p>Alternatively, it might be called from an independent application thread. In that case, the event queue rules apply.</p>
<p>If this is a Persistent receiver, see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/ume.tag:../UME/" href="../UME/designingpersistentreceivers.html#persistencemessageconsumption">Persistence Message Consumption</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="javamessagereception"></a>
Java Message Reception&nbsp;&nbsp;<small><a href="#javamessagereception">&lt;-</a></small></h2>
<p><b>Java: Fully Process Message in Receiver Callback: Context Thread</b></p>
<p>This use case assumes that the context thread is calling the receiver callback function (i.e. an <a class="el" href="umobjects.html#eventqueueobject">Event Queue Object</a> is NOT being used).</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keywordtype">int</span> onReceive(Object cbArg, LBMMessage msg)</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span> {</div><div class="line">    <span class="keywordflow">switch</span> (msg.type())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">case</span> LBM.MSG_DATA:</div><div class="line">        myProcessReceivedMessage(msg);</div><div class="line">        msg.dispose();</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">      <span class="comment">/* Handle other receiver events. */</span></div><div class="line">    }  <span class="comment">/* switch */</span></div><div class="line">  } <span class="keywordflow">catch</span> (Exception e) {</div><div class="line">    <span class="comment">/* Handle exception. */</span></div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}  <span class="comment">/* onReceive */</span></div></div><!-- fragment --><p>Important rules regarding the receiver callback function when called by the context thread: </p><ul>
<li>
The function must return 0. </li>
<li>
The function must not be allowed to pass an unhandled exception back into UM. For example, you could have your entire callback function enclosed in a large try/catch. (This is true of all UM callbacks, not just receiver.) </li>
<li>
The passed-in message must not be modified. </li>
<li>
The passed-in message must be disposed. In Java, every message must explicitly be disposed, to properly clean up the native memory. Do not assume that GC will clean it up. </li>
<li>
The function should not perform any operation that might be time consuming or put the thread to sleep (block). This is because any delays in your callback prevents the context thread from servicing its sockets, increasing the risk of packet loss. </li>
<li>
If sending a normal UM message, non-blocking sends must be used (see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBM.html#afbb8a9ee8f1b5c98917feef2fd4e1fb0">com::latencybusters::lbm::LBM::SRC_NONBLOCK</a>). And the code should be written to handle a send failure of <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMEWouldBlockException.html">com::latencybusters::lbm::LBMEWouldBlockException</a>. </li>
<li>
It is not allowed to create/delete sources or receivers, or subscribe/unsubscribe from a <a class="el" href="umfeatures.html#spectrum">Spectrum</a> channel from a callback function executed by the context thread. </li>
<li>
You may schedule UM timers. </li>
</ul>
<p>Note the requirement to call <code>msg.dispose()</code> on every message. Prior to UM version 6.7, calling dispose() on every message was considered best practice, but was only <em>required</em> for certain use cases. UM version 6.7 introduced significant performance improvements with Java, but these improvements made calling <code>msg.dispose()</code> a requirement.</p>
<p>If this is a Persistent receiver, see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/ume.tag:../UME/" href="../UME/designingpersistentreceivers.html#persistencemessageconsumption">Persistence Message Consumption</a>.</p>
<p><b>Java: Fully Process Message in Receiver Callback: Event Queue</b></p>
<p>This use case assumes that an <a class="el" href="umobjects.html#eventqueueobject">Event Queue Object</a> is being used. So the receiver callback function is called by the event queue dispatch thread.</p>
<p>The code itself is identical to the context thread case above.</p>
<p>The rules are similar, with some important differences: </p><ul>
<li>
The function must return 0. </li>
<li>
The function must not be allowed to pass an unhandled exception back into UM. For example, you could have your entire callback function enclosed in a large try/catch. (This is true of all UM callbacks, not just receiver.) </li>
<li>
The passed-in message must not be modified. </li>
<li>
The passed-in message must be disposed. In Java, every message must explicitly be disposed, to properly clean up the native memory. Do not assume that GC will clean it up. </li>
<li>
The application is permitted to perform operations that are time consuming and/or blocking, as long as the average message processing rate is greater than the average message sending rate. Any temporary delays will buffer messages in the event queue. </li>
<li>
Blocking or non-blocking sends may be used, according to the application's preferences. </li>
<li>
You may create/delete sources or receivers, or subscribe/unsubscribe from a <a class="el" href="umfeatures.html#spectrum">Spectrum</a> channel. However, the receiver which is delivering the current message should not be deleted. </li>
<li>
You may schedule UM timers. </li>
</ul>
<p>If this is a Persistent receiver, see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/ume.tag:../UME/" href="../UME/designingpersistentreceivers.html#persistencemessageconsumption">Persistence Message Consumption</a>.</p>
<p><b>Java: Message Retained After Receiver Callback Returns</b></p>
<p>This use case assumes that some or all messages require additional processing after the receiver callback returns.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keywordtype">int</span> onReceive(Object cbArg, LBMMessage msg)</div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span> moreProcessing;</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span> {</div><div class="line">    <span class="keywordflow">switch</span> (msg.type())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">case</span> LBM.MSG_DATA:</div><div class="line">        moreProcessing = myProcessReceivedMessage(msg);</div><div class="line">        <span class="keywordflow">if</span> (moreProcessing) {</div><div class="line">          msg.promote();</div><div class="line">          saveMessageForMoreProcessing(msg);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> {</div><div class="line">          msg.dispose();</div><div class="line">        }</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">      <span class="comment">/* Handle other receiver events. */</span></div><div class="line">    }  <span class="comment">/* switch */</span></div><div class="line">  } <span class="keywordflow">catch</span> (Exception e) {</div><div class="line">    <span class="comment">/* Handle exception. */</span></div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}  <span class="comment">/* onReceive */</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">public <span class="keywordtype">int</span> myAdditonalProcessing(LBMMessage msg)</div><div class="line">{</div><div class="line">  myFinishProcessingReceivedMessage(msg);</div><div class="line">  msg.dispose();</div><div class="line">}  <span class="comment">/* myAdditonalProcessing */</span></div></div><!-- fragment --><p>The main point of this example is the presence of the calls to <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMMessage.html#a2cda69ee0b33fe294d46761401e451ca">com.latencybusters.lbm.LBMMessage.promote()</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMMessage.html#a963d0f07751ed176a97f3eff84740fb9">com.latencybusters.lbm.LBMMessage.dispose()</a>. The promote() method explicitly informs UM that the message will be retained after the return of the receiver callback.</p>
<p>The mySaveMessageForMoreProcessing() function is just whatever you need to transfer the message for further processing. The myAdditionalProcessing() function is typically called by you when you are ready to complete processing of the message.</p>
<p>The rules for the receiver callback are the same as those above, depending on whether an event queue is in use. However, the application must ensure that every message is disposed.</p>
<p>The rules for "myAdditionalProcessing()" function depend on how it is being called. For example, an application might arrange to have it called via a different UM callback (e.g. a timer). In that case, it has the same rules as the receiver callback.</p>
<p>Alternatively, it might be called from an independent application thread. In that case, the event queue rules apply.</p>
<p>If this is a Persistent receiver, see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.13.1_RC1/doc/Design/ume.tag:../UME/" href="../UME/designingpersistentreceivers.html#persistencemessageconsumption">Persistence Message Consumption</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="netmessagereception"></a>
.NET Message Reception&nbsp;&nbsp;<small><a href="#netmessagereception">&lt;-</a></small></h2>
<p>The models and rules for .NET are the same as for Java.</p>
<dl class="section note"><dt>Note</dt><dd>A .NET program can skip calling <a href="../DotNetAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMMessage.html#a963d0f07751ed176a97f3eff84740fb9">dispose()</a> and allow the message to become garbage. This is not recommended. It will introduce significant latency outliers (<a class="el" href="umglossary.html#glossaryjitter">jitter</a>) when GC runs, and also makes acknowledgements to the Store non-deterministic. Finally, in the future, performance improvements for .NET will probably require the use of "dispose()". <b>Informatica recommends that .NET programs call "dispose()" for every message.</b></dd></dl>
<p>See <a class="el" href="applicationdesignprinciples.html#javamessagereception">Java Message Reception</a>.</p>
<p><br />
<br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
</body>
</html>
