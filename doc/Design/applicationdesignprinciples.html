<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Concepts Guide: Application Design Principles</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen_manual.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Concepts Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('applicationdesignprinciples.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Application Design Principles </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><br />
 </p>
<h1><a class="anchor" id="ummonitoring"></a>
UM Monitoring&nbsp;&nbsp;<small><a href="#ummonitoring">&lt;-</a></small></h1>
<p>For an Ultra Messaging deployment, "monitoring" is the process of overseeing the operation of UM and the resources it uses to determine its health and performance.</p>
<p><b>Informatica strongly recommends that users of Ultra Messaging actively monitor its operation.</b></p>
<p>Monitoring is addressed in depth in the Operations Guide; see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/operations.tag:../Operations/" href="../Operations/monitoring.html#monitoringintroduction">Monitoring Introduction</a>. From an application design point of view, you should decide on a monitoring approach before you start coding your applications.</p>
<p>In particular, implement the recommendations related to the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/operations.tag:../Operations/" href="../Operations/monitoring.html#applicationlogfile">Application Log File</a>.</p>
<p><br />
 </p>
<h1><a class="anchor" id="messagereception"></a>
Message Reception&nbsp;&nbsp;<small><a href="#messagereception">&lt;-</a></small></h1>
<p>Applications receive messages from UM via application callback. The application registers its callback function with UM during the creation of the <a class="el" href="umobjects.html#receiverobject">Receiver Object</a>. As messages are received, the application's receiver callback function is called, passing in the received message.</p>
<p>Note: there are events other than message reception that can trigger calls to the application's receiver callback. Those other event types are not covered in this section (see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/structlbm__msg__t__stct.html#ab25327dc4b4ebf527106f6e708dbc05f">lbm_msg_t_stct::type</a>).</p>
<p>At a high level, there are three common approaches to handling received messages: </p><ol>
<li>
Message is fully processed by the application's receiver callback, called by a context or <a class="el" href="umfeatures.html#transportservicesproviderxsp">XSP</a> thread. This is typically the most efficient approach. </li>
<li>
Message is fully processed by the application's receiver callback, called by an <a class="el" href="umobjects.html#eventqueueobject">event queue</a> dispatch thread. This is a simple method to move message processing to a different thread. </li>
<li>
Message is retained by the receiver callback for further processing by a different application thread. </li>
</ol>
<p>For example code demonstrating message reception best practices, see the API language: </p><ul>
<li>
<a class="el" href="applicationdesignprinciples.html#cmessagereception">C Message Reception</a> </li>
<li>
<a class="el" href="applicationdesignprinciples.html#javamessagereception">Java Message Reception</a> </li>
<li>
<a class="el" href="applicationdesignprinciples.html#netmessagereception">.NET Message Reception</a> </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="cmessagereception"></a>
C Message Reception&nbsp;&nbsp;<small><a href="#cmessagereception">&lt;-</a></small></h2>
<p><b>C: Message Is Fully Processed by the Application's Receiver Callback, Called by a Context or <a class="el" href="umfeatures.html#transportservicesproviderxsp">XSP</a> Thread</b></p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> my_receiver_callback(<a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a0a4af6b8247cc5a0a24a8578fb6e83bd">lbm_rcv_t</a> *rcv, <a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/structlbm__msg__t__stct.html">lbm_msg_t</a> *msg, <span class="keywordtype">void</span> *clientd)</div><div class="line">{</div><div class="line">  <span class="keywordflow">switch</span> (msg-&gt;<a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/structlbm__msg__t__stct.html#ab25327dc4b4ebf527106f6e708dbc05f">type</a>) {</div><div class="line">    <span class="keywordflow">case</span> <a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aa47eb604db7dc9fd53f9650ed940e058">LBM_MSG_DATA</a>:</div><div class="line"></div><div class="line">      <span class="comment">/* Process &quot;msg-&gt;len&quot; bytes in &quot;msg-&gt;data&quot;. */</span></div><div class="line">      ...</div><div class="line"></div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Handle other receiver events. */</span></div><div class="line">  }  <span class="comment">/* switch */</span></div><div class="line"></div><div class="line">  <span class="comment">/* No need to delete message (C API deletes by default). */</span></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}  <span class="comment">/* my_receiver_callback */</span></div></div><!-- fragment --><p>Important rules regarding the receiver callback function when called by a context/XSP thread: </p><ul>
<li>
The function must return 0. </li>
<li>
The passed-in message must not be modified. </li>
<li>
The function should not perform any operation that might be time consuming or put the thread to sleep (block). This is because any delays in your callback prevents the context thread from servicing its sockets, increasing the risk of packet loss. </li>
<li>
If the receiver callback sends a message, non-blocking sends must be used (see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ab8a470f02029480f179cc4872b7fa713">LBM_SRC_NONBLOCK</a>). The code should be written to handle a send failure of <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a75f0f83b8684df30d9816210cc20b4b0">LBM_EWOULDBLOCK</a>. </li>
<li>
It is not allowed to create/delete sources or receivers, or subscribe/unsubscribe from a <a class="el" href="umfeatures.html#spectrum">Spectrum</a> channel from a callback function executed by a context/XSP thread. </li>
<li>
You may schedule UM timers. </li>
</ul>
<p>If this is a Persistent receiver, see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/ume.tag:../UME/" href="../UME/designingpersistentreceivers.html#persistencemessageconsumption">Persistence Message Consumption</a>.</p>
<p><b>C: Message Is Fully Processed by the Application's Receiver Callback, Called by an <a class="el" href="umobjects.html#eventqueueobject">Event Queue</a> Dispatch Thread</b></p>
<p>The code is identical to the context/XSP thread case above.</p>
<p>The rules are similar, with some important differences (in bold): </p><ul>
<li>
The function must return 0. </li>
<li>
The passed-in message must not be modified. </li>
<li>
<b>The application is permitted to perform operations that are time consuming and/or blocking, as long as the average message processing rate is greater than the average message sending rate. Any temporary delays will buffer messages in the event queue.</b> </li>
<li>
<b>Blocking or non-blocking sends may be used, according to the application's preferences.</b> </li>
<li>
<b>You may create/delete sources or receivers, or subscribe/unsubscribe from a <a class="el" href="umfeatures.html#spectrum">Spectrum</a> channel. However, the receiver which is delivering the current message must not be deleted.</b> </li>
<li>
You may schedule UM timers. </li>
<li>
Informatica strongly recommends monitoring event queue length. See <a class="el" href="umobjects.html#eventqueuemonitor">Event Queue Monitor</a> for more information. </li>
</ul>
<p>If this is a Persistent receiver, see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/ume.tag:../UME/" href="../UME/designingpersistentreceivers.html#persistencemessageconsumption">Persistence Message Consumption</a>.</p>
<p><b>C: Message Is Retained by the Receiver Callback for Further Processing by a Different Application Thread</b></p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> my_receiver_callback(<a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a0a4af6b8247cc5a0a24a8578fb6e83bd">lbm_rcv_t</a> *rcv, <a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/structlbm__msg__t__stct.html">lbm_msg_t</a> *msg, <span class="keywordtype">void</span> *clientd)</div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span> err, more_processing_needed;</div><div class="line"></div><div class="line">  <span class="keywordflow">switch</span> (msg-&gt;<a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/structlbm__msg__t__stct.html#ab25327dc4b4ebf527106f6e708dbc05f">type</a>) {</div><div class="line">    <span class="keywordflow">case</span> <a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aa47eb604db7dc9fd53f9650ed940e058">LBM_MSG_DATA</a>:</div><div class="line">      more_processing_needed = my_process_received_message(msg);</div><div class="line">      <span class="keywordflow">if</span> (more_processing_needed) {</div><div class="line">        err = <a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a2b7788ff58f9e78bc89ea890dad0cccf">lbm_msg_retain</a>(msg);  <span class="comment">/* Check and handle errors. */</span></div><div class="line">        my_save_message_for_more_processing(msg);</div><div class="line">      }</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* Handle other receiver events. */</span></div><div class="line">  }  <span class="comment">/* switch */</span></div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}  <span class="comment">/* my_receiver_callback */</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">void my_additional_processing(<a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/structlbm__msg__t__stct.html">lbm_msg_t</a> *msg)</div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span> err;</div><div class="line"></div><div class="line">  <span class="comment">/* Process &quot;msg-&gt;len&quot; bytes in &quot;msg-&gt;data&quot;. */</span></div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="comment">/* Tell UM: finished with &quot;msg&quot;. */</span></div><div class="line">  err = <a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aa5fc1eb324a55b8c800c31460b0f0116">lbm_msg_delete</a>(msg);</div><div class="line">  <span class="comment">/* Check and handle errors. */</span></div><div class="line">}  <span class="comment">/* my_additional_processing */</span></div></div><!-- fragment --><p>This demonstrates the use of: </p><ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a2b7788ff58f9e78bc89ea890dad0cccf">lbm_msg_retain()</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aa5fc1eb324a55b8c800c31460b0f0116">lbm_msg_delete()</a> </li>
</ul>
<p>By default, when a receiver callback returns, the UM message is implicitly deleted. To prevent that from happening, the message must be "retained". The application must ensure that every message retained is eventually deleted.</p>
<p>The my_save_message_for_more_processing() function is just whatever you use to transfer the message to your processing thread. The my_additional_processing() function is typically called by your thread to process the message.</p>
<p>The rules for the message processing code are the same as the event queue case (above).</p>
<p>If this is a Persistent receiver, see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/ume.tag:../UME/" href="../UME/designingpersistentreceivers.html#persistencemessageconsumption">Persistence Message Consumption</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="javamessagereception"></a>
Java Message Reception&nbsp;&nbsp;<small><a href="#javamessagereception">&lt;-</a></small></h2>
<p><b>Java: Message Is Fully Processed by the Application's Receiver Callback, Called by a Context or <a class="el" href="umfeatures.html#transportservicesproviderxsp">XSP</a> Thread</b></p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keywordtype">int</span> onReceive(Object cbArg, LBMMessage msg)</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span> {</div><div class="line">    <span class="keywordflow">switch</span> (msg.type())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">case</span> LBM.MSG_DATA:</div><div class="line">        ByteBuffer message = msg.dataBuffer();</div><div class="line">        <span class="keywordtype">long</span> msgLen = msg.dataLength();</div><div class="line"></div><div class="line">        <span class="comment">// Process &quot;msgLen&quot; bytes in &quot;message&quot;.</span></div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="comment">// Tell UM: finished with &quot;msg&quot;.</span></div><div class="line">        msg.dispose();</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">      <span class="comment">/* Handle other receiver events. */</span></div><div class="line">    }  <span class="comment">/* switch */</span></div><div class="line">  } <span class="keywordflow">catch</span> (Exception e) {</div><div class="line">    <span class="comment">/* Handle exception. */</span></div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}  <span class="comment">/* onReceive */</span></div></div><!-- fragment --><p>This demonstrates the use of: </p><ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMMessage.html#a66588284dc0a60fdd0267f397f36c3c6">com.latencybusters.lbm.LBMMessage.dataBuffer()</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMMessage.html#a8480fa58f107456108732af3940efd59">com.latencybusters.lbm.LBMMessage.dataLength()</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMMessage.html#a963d0f07751ed176a97f3eff84740fb9">com.latencybusters.lbm.LBMMessage.dispose()</a> </li>
</ul>
<p>These functions prevent unnecessary garbage and are strongly recommended by Informatica (see <a class="el" href="advancedoptimizations.html#zeroobjectdelivery">Zero Object Delivery</a>).</p>
<p>Important rules regarding the receiver callback function when called by the context thread: </p><ul>
<li>
The function must return 0. </li>
<li>
The function must not be allowed to pass an unhandled exception back into UM. For example, you could have your entire callback function enclosed in a large try/catch. (This is true of all UM callbacks, not just receiver.) </li>
<li>
The passed-in message must not be modified. </li>
<li>
The passed-in message must be disposed. In Java, every message must explicitly be disposed, to properly clean up the native memory. Do not assume that GC will clean it up. </li>
<li>
The function should not perform any operation that might be time consuming or put the thread to sleep (block). This is because any delays in your callback prevents the context thread from servicing its sockets, increasing the risk of packet loss. </li>
<li>
If the receiver callback sends a message, non-blocking sends must be used (see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBM.html#afbb8a9ee8f1b5c98917feef2fd4e1fb0">com::latencybusters::lbm::LBM::SRC_NONBLOCK</a>). And the code should be written to handle a send failure of <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMEWouldBlockException.html">com::latencybusters::lbm::LBMEWouldBlockException</a>. </li>
<li>
It is not allowed to create/delete sources or receivers, or subscribe/unsubscribe from a <a class="el" href="umfeatures.html#spectrum">Spectrum</a> channel from a callback function executed by the context thread. </li>
<li>
You may schedule UM timers. </li>
</ul>
<p>Note the requirement to call <code>msg.dispose()</code> on every message. Prior to UM version 6.7, calling dispose() on every message was considered best practice, but was only <em>required</em> for certain use cases. UM version 6.7 introduced significant performance improvements with Java, but these improvements made calling <code>msg.dispose()</code> mandatory.</p>
<p>If this is a Persistent receiver, see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/ume.tag:../UME/" href="../UME/designingpersistentreceivers.html#persistencemessageconsumption">Persistence Message Consumption</a>.</p>
<p><b>Java: Message Is Fully Processed by the Application's Receiver Callback, Called by an <a class="el" href="umobjects.html#eventqueueobject">Event Queue</a> Dispatch Thread</b></p>
<p>The code is identical to the context thread case above.</p>
<p>The rules are similar, with some important differences (in bold): </p><ul>
<li>
The function must return 0. </li>
<li>
The function must not be allowed to pass an unhandled exception back into UM. For example, you could have your entire callback function enclosed in a large try/catch. (This is true of all UM callbacks, not just receiver.) </li>
<li>
The passed-in message must not be modified. </li>
<li>
The passed-in message must be disposed. In Java, every message must explicitly be disposed, to properly clean up the native memory. Do not assume that GC will clean it up. </li>
<li>
<b>The application is permitted to perform operations that are time consuming and/or blocking, as long as the average message processing rate is greater than the average message sending rate. Any temporary delays will buffer messages in the event queue.</b> </li>
<li>
<b>Blocking or non-blocking sends may be used, according to the application's preferences.</b> </li>
<li>
<b>You may create/delete sources or receivers, or subscribe/unsubscribe from a <a class="el" href="umfeatures.html#spectrum">Spectrum</a> channel. However, the receiver which is delivering the current message should not be deleted.</b> </li>
<li>
You may schedule UM timers. </li>
<li>
Informatica strongly recommends monitoring event queue length. See <a class="el" href="umobjects.html#eventqueuemonitor">Event Queue Monitor</a> for more information. </li>
</ul>
<p>If this is a Persistent receiver, see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/ume.tag:../UME/" href="../UME/designingpersistentreceivers.html#persistencemessageconsumption">Persistence Message Consumption</a>.</p>
<p><b>Java: Message Is Retained by the Receiver Callback for Further Processing by a Different Application Thread</b></p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keywordtype">void</span> init_UM()</div><div class="line">{</div><div class="line">  <span class="comment">// During initialization, the UM context and receiver(s) are</span></div><div class="line">  <span class="comment">// configured to use a recycler.</span></div><div class="line">  LBMObjectRecycler objRec = <span class="keyword">new</span> LBMObjectRecycler();</div><div class="line">...</div><div class="line">  <span class="comment">// Preparing to create context - set up attribute.</span></div><div class="line">  LBMContextAttributes ctx_attr = <span class="keyword">new</span> LBMContextAttributes();</div><div class="line">  ctx_attr.setObjectRecycler(objRec, null);</div><div class="line">  <span class="comment">// Proceed with creating context, using ctx_attr.</span></div><div class="line">...</div><div class="line">  <span class="comment">// Preparing to create receiver - set up attribute.</span></div><div class="line">  LBMReceiverAttributes rcv_attr = <span class="keyword">new</span> LBMReceiverAttributes();</div><div class="line">  rcv_attr.setObjectRecycler(objRec, null);</div><div class="line">  <span class="comment">// Proceed with creating receiver, using rcv_attr.</span></div><div class="line">...</div><div class="line">}</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">public <span class="keywordtype">int</span> onReceive(Object cbArg, LBMMessage msg)</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span> {</div><div class="line">    <span class="keywordflow">switch</span> (msg.type())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">case</span> LBM.MSG_DATA:</div><div class="line">        msg.promote();  <span class="comment">// Tell UM: not finished with &quot;msg&quot;.</span></div><div class="line">        saveMessageForMoreProcessing(msg);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">      <span class="comment">/* Handle other receiver events. */</span></div><div class="line">    }  <span class="comment">/* switch */</span></div><div class="line">  } <span class="keywordflow">catch</span> (Exception e) {</div><div class="line">    <span class="comment">/* Handle exception. */</span></div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}  <span class="comment">/* onReceive */</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">public <span class="keywordtype">int</span> myAdditionalProcessing(LBMMessage msg)</div><div class="line">{</div><div class="line">  ByteBuffer message = msg.dataBuffer();</div><div class="line">  <span class="keywordtype">long</span> msgLen = msg.dataLength();</div><div class="line"></div><div class="line">  <span class="comment">// Process &quot;msgLen&quot; bytes in &quot;message&quot;.</span></div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="comment">// Tell UM: finished with &quot;msg&quot;.</span></div><div class="line">  msg.dispose();</div><div class="line">  objRec.doneWithMessage(msg);</div><div class="line">}  <span class="comment">/* myAdditionalProcessing */</span></div></div><!-- fragment --><p>This demonstrates the use of: </p><ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMMessage.html#a2cda69ee0b33fe294d46761401e451ca">com.latencybusters.lbm.LBMMessage.promote()</a><ul>
<li>informs UM that the message is retained after the return of the receiver callback. </li>
</ul>
</li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMMessage.html#a66588284dc0a60fdd0267f397f36c3c6">com.latencybusters.lbm.LBMMessage.dataBuffer()</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMMessage.html#a8480fa58f107456108732af3940efd59">com.latencybusters.lbm.LBMMessage.dataLength()</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMMessage.html#a963d0f07751ed176a97f3eff84740fb9">com.latencybusters.lbm.LBMMessage.dispose()</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMObjectRecycler.html">com.latencybusters.lbm.LBMObjectRecycler</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMObjectRecycler.html#aa9e6a3f6604e64ea2d88f190f650baa1">com.latencybusters.lbm.LBMObjectRecycler.doneWithMessage()</a> </li>
</ul>
<p>These functions prevent unnecessary garbage and are strongly recommended by Informatica (see <a class="el" href="advancedoptimizations.html#zeroobjectdelivery">Zero Object Delivery</a>).</p>
<p>The mySaveMessageForMoreProcessing() function is just whatever you use to transfer the message to your processing thread. The myAdditionalProcessing() function is typically called by you when you are ready to complete processing of the message.</p>
<p>The rules for the message processing code are the same as the event queue case. However, the application must ensure that every message promoted is eventually disposed.</p>
<p>If this is a Persistent receiver, see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/ume.tag:../UME/" href="../UME/designingpersistentreceivers.html#persistencemessageconsumption">Persistence Message Consumption</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="netmessagereception"></a>
.NET Message Reception&nbsp;&nbsp;<small><a href="#netmessagereception">&lt;-</a></small></h2>
<p>Except where indicated, .NET coding for message reception is identical to that of Java.</p>
<dl class="section note"><dt>Note</dt><dd>Historically, .NET programs that receive UM messages were not required to call the message object's <a href="../DotNetAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMMessage.html#a963d0f07751ed176a97f3eff84740fb9">dispose()</a> method. However, it is now strongly recommended. Not calling dispose() will introduce significant latency outliers (<a class="el" href="umglossary.html#glossaryjitter">jitter</a>) when GC runs, and also makes persistence acknowledgements to the Store non-deterministic. Finally, in the future, performance improvements for .NET might require the use of "dispose()". <b>Informatica strongly recommends that .NET subscribers call "dispose()" for every message.</b></dd></dl>
<p><b>.NET: Message Is Fully Processed by the Application's Receiver Callback, Called by a Context or <a class="el" href="umfeatures.html#transportservicesproviderxsp">XSP</a> Thread</b></p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keywordtype">int</span> onReceive(Object cbArg, LBMMessage msg)</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span> {</div><div class="line">    <span class="keywordflow">switch</span> (msg.type())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">case</span> LBM.MSG_DATA:</div><div class="line">        byte * message = msg.dataPointer();  <span class="comment">// Different from java!</span></div><div class="line">        uint msgLen = msg.length();          <span class="comment">// Different from java!</span></div><div class="line"></div><div class="line">        <span class="comment">// Process &quot;msgLen&quot; bytes in &quot;message&quot;.</span></div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="comment">// Tell UM: finished with &quot;msg&quot;.</span></div><div class="line">        msg.dispose();</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">      <span class="comment">/* Handle other receiver events. */</span></div><div class="line">    }  <span class="comment">/* switch */</span></div><div class="line">  } <span class="keywordflow">catch</span> (Exception e) {</div><div class="line">    <span class="comment">/* Handle exception. */</span></div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}  <span class="comment">/* onReceive */</span></div></div><!-- fragment --><p>This demonstrates the use of: </p><ul>
<li>
<a href="../DotNetAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMMessage.html#a98f034f21af3ac96cc48cd90df73b48b">dataPointer()</a> </li>
<li>
<a href="../DotNetAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMMessage.html#a26ee9e9a8fa76302a91bcf77a60a9d26">length()</a> </li>
<li>
<a href="../DotNetAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMMessage.html#a963d0f07751ed176a97f3eff84740fb9">dispose()</a> </li>
</ul>
<p>These functions prevent unnecessary garbage and are strongly recommended by Informatica (see <a class="el" href="advancedoptimizations.html#zeroobjectdelivery">Zero Object Delivery</a>).</p>
<p>Important rules regarding the receiver callback function when called by the context thread: </p><ul>
<li>
The function must return 0. </li>
<li>
The function must not be allowed to pass an unhandled exception back into UM. For example, you could have your entire callback function enclosed in a large try/catch. (This is true of all UM callbacks, not just receiver.) </li>
<li>
The passed-in message must not be modified. </li>
<li>
The passed-in message must be disposed. In .NET, every message should explicitly be disposed, to properly clean up the native memory. Do not assume that GC will clean it up. </li>
<li>
The function should not perform any operation that might be time consuming or put the thread to sleep (block). This is because any delays in your callback prevents the context thread from servicing its sockets, increasing the risk of packet loss. </li>
<li>
If the receiver callback sends a message, non-blocking sends must be used (see <a href="../DotNetAPI/classcom_1_1latencybusters_1_1lbm_1_1LBM.html#ac90cdb59c9d78fcbf2f5a127df5381a7">SRC_NONBLOCK()</a>). And the code should be written to handle a send failure of <a href="../DotNetAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMEWouldBlockException.html">LBMEWouldBlockException()</a>. </li>
<li>
It is not allowed to create/delete sources or receivers, or subscribe/unsubscribe from a <a class="el" href="umfeatures.html#spectrum">Spectrum</a> channel from a callback function executed by the context thread. </li>
<li>
You may schedule UM timers. </li>
</ul>
<p>If this is a Persistent receiver, see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/ume.tag:../UME/" href="../UME/designingpersistentreceivers.html#persistencemessageconsumption">Persistence Message Consumption</a>.</p>
<p><b>.NET: Message Is Fully Processed by the Application's Receiver Callback, Called by an <a class="el" href="umobjects.html#eventqueueobject">Event Queue</a> Dispatch Thread</b></p>
<p>The code is identical to the context thread case above.</p>
<p>The rules are similar, with some important differences (in bold): </p><ul>
<li>
The function must return 0. </li>
<li>
The function must not be allowed to pass an unhandled exception back into UM. For example, you could have your entire callback function enclosed in a large try/catch. (This is true of all UM callbacks, not just receiver.) </li>
<li>
The passed-in message must not be modified. </li>
<li>
The passed-in message must be disposed. In .NET, every message should explicitly be disposed, to properly clean up the native memory. Do not assume that GC will clean it up. </li>
<li>
<b>The application is permitted to perform operations that are time consuming and/or blocking, as long as the average message processing rate is greater than the average message sending rate. Any temporary delays will buffer messages in the event queue.</b> </li>
<li>
<b>Blocking or non-blocking sends may be used, according to the application's preferences.</b> </li>
<li>
<b>You may create/delete sources or receivers, or subscribe/unsubscribe from a <a class="el" href="umfeatures.html#spectrum">Spectrum</a> channel. However, the receiver which is delivering the current message should not be deleted.</b> </li>
<li>
You may schedule UM timers. </li>
<li>
Informatica strongly recommends monitoring event queue length. See <a class="el" href="umobjects.html#eventqueuemonitor">Event Queue Monitor</a> for more information. </li>
</ul>
<p>If this is a Persistent receiver, see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/ume.tag:../UME/" href="../UME/designingpersistentreceivers.html#persistencemessageconsumption">Persistence Message Consumption</a>.</p>
<p><b>.NET: Message Is Retained by the Receiver Callback for Further Processing by a Different Application Thread</b></p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keywordtype">void</span> init_UM()</div><div class="line">{</div><div class="line">  <span class="comment">// During initialization, the UM context and receiver(s) must be</span></div><div class="line">  <span class="comment">// configured to use a recycler.</span></div><div class="line">  LBMObjectRecycler objRec = <span class="keyword">new</span> LBMObjectRecycler();</div><div class="line">...</div><div class="line">  <span class="comment">// Preparing to create context - set up attribute.</span></div><div class="line">  LBMContextAttributes ctx_attr = <span class="keyword">new</span> LBMContextAttributes();</div><div class="line">  ctx_attr.setObjectRecycler(objRec, null);</div><div class="line">  <span class="comment">// Proceed with creating context, using ctx_attr.</span></div><div class="line">...</div><div class="line">  <span class="comment">// Preparing to create receiver - set up attribute.</span></div><div class="line">  LBMReceiverAttributes rcv_attr = <span class="keyword">new</span> LBMReceiverAttributes();</div><div class="line">  rcv_attr.setObjectRecycler(objRec, null);</div><div class="line">  <span class="comment">// Proceed with creating receiver, using rcv_attr.</span></div><div class="line">...</div><div class="line">}</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">public <span class="keywordtype">int</span> onReceive(Object cbArg, LBMMessage msg)</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span> {</div><div class="line">    <span class="keywordflow">switch</span> (msg.type())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">case</span> LBM.MSG_DATA:</div><div class="line">        msg.promote();</div><div class="line">        <span class="comment">// Tell UM: not finished with &quot;msg&quot;.</span></div><div class="line">        saveMessageForMoreProcessing(msg);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">      <span class="comment">/* Handle other receiver events. */</span></div><div class="line">    }  <span class="comment">/* switch */</span></div><div class="line">  } <span class="keywordflow">catch</span> (Exception e) {</div><div class="line">    <span class="comment">/* Handle exception. */</span></div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}  <span class="comment">/* onReceive */</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">public <span class="keywordtype">int</span> myAdditionalProcessing(LBMMessage msg)</div><div class="line">{</div><div class="line">  byte * message = msg.dataPointer();  <span class="comment">// Different from java!</span></div><div class="line">  uint msgLen = msg.length();          <span class="comment">// Different from java!</span></div><div class="line"></div><div class="line">  <span class="comment">// Process &quot;msgLen&quot; bytes in &quot;message&quot;.</span></div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="comment">// Tell UM: finished with &quot;msg&quot;.</span></div><div class="line">  msg.dispose();</div><div class="line">  objRec.doneWithMessage(msg);</div><div class="line">}  <span class="comment">/* myAdditionalProcessing */</span></div></div><!-- fragment --><p>This demonstrates the use of: </p><ul>
<li>
<a href="../DotNetAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMMessage.html#a2cda69ee0b33fe294d46761401e451ca">promote()</a><ul>
<li>informs UM that the message is retained after the return of the receiver callback. </li>
</ul>
</li>
<li>
<a href="../DotNetAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMMessage.html#a98f034f21af3ac96cc48cd90df73b48b">dataPointer()</a> </li>
<li>
<a href="../DotNetAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMMessage.html#a26ee9e9a8fa76302a91bcf77a60a9d26">length()</a> </li>
<li>
<a href="../DotNetAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMMessage.html#a963d0f07751ed176a97f3eff84740fb9">dispose()</a> </li>
<li>
<a href="../DotNetAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMObjectRecycler.html">LBMObjectRecycler</a> </li>
<li>
<a href="../DotNetAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMObjectRecycler.html#ac9ad6974e2c0f094b7e2662ecc3e9157">LBMObjectRecycler.doneWithMessage()</a> </li>
</ul>
<p>These functions prevent unnecessary garbage and are strongly recommended by Informatica (see <a class="el" href="advancedoptimizations.html#zeroobjectdelivery">Zero Object Delivery</a>).</p>
<p>The mySaveMessageForMoreProcessing() function is just whatever you use to transfer the message to your processing thread. The myAdditionalProcessing() function is typically called by you when you are ready to complete processing of the message.</p>
<p>The rules for the message processing code are the same as the event queue case. However, the application must ensure that every message promoted is eventually disposed.</p>
<p>If this is a Persistent receiver, see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/ume.tag:../UME/" href="../UME/designingpersistentreceivers.html#persistencemessageconsumption">Persistence Message Consumption</a>.</p>
<p><br />
<br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
</body>
</html>
