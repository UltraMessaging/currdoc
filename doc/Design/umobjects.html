<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Concepts Guide: UM Objects</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen_manual.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Concepts Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('umobjects.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">UM Objects </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Many UM documents use the term object. Be aware that with the C API, they do not refer to formal class-based objects as supported by C++. The term is used here in an informal sense to denote an entity that can be created, used, and (usually) deleted, has functionality and data associated with it, and is managed through the API. The handle that is used to refer to an object is usually implemented as a pointer to a data structure (defined in <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html">lbm.h</a>), but the internal structure of an object is said to be opaque, meaning that application code should not read or write the structure directly.</p>
<p>However, the UM Java and .NET APIs <em>are</em> formally object oriented, with Java/C# class-based objects. See the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/index.html#umjavaapi">UM Java API</a> and the <a href="../DotNetAPI/index.html#umnetapi">UM .NET API</a> documentation.</p>
<p>The UM API is designed around a set of UM objects. The most-often used object types are: </p><ul>
<li>
<a class="el" href="umobjects.html#contextobject">Context</a> - a fairly "heavy-weight" parent object for most other UM objects. Also represents an "instance" of UM, with all foreground and background functions. </li>
<li>
<a class="el" href="umobjects.html#sourceobject">Source</a> - a publisher creates one or more Source objects, one per topic to be published. </li>
<li>
<a class="el" href="umobjects.html#receiverobject">Receiver</a> - a subscriber creates one or more Receivers, one per topic that is subscribed. </li>
<li>
<a class="el" href="umobjects.html#umwildcardreceivers">Wildcard Receiver</a> - a subscriber can optionally create Wildcard Receivers to subscribe to patterns that can match multiple topics. </li>
<li>
<a class="el" href="umfeatures.html#hotfailoverhf">Hot Failover Receiver</a> - a specialized type of Receiver object that allows for redundant publishing. </li>
<li>
<a class="el" href="umfeatures.html#hotfailoveracrossmultiplecontexts">HFX Receiver</a> - a specialized type of Hot Failover Receiver object that allows redundant sources across multiple Context objects. (Note: HFX is deprecated.) </li>
<li>
<a class="el" href="umobjects.html#eventqueueobject">Event Queue</a> - an active object (requires one or more threads) which is used to queue and deliver UM events (including received messages) to the application using a separate thread. Event queues are normally not required; by default UM delivers events using the Context's own thread. But there are circumstances where it is useful to transfer the received message or event to an independent thread for delivery. </li>
</ul>
<p>A typical UM application program manages UM objects following certain ordering rules: </p><ol>
<li>
If desired, Event Queues are typically created first. (Most UM applications do not use Event Queues.) </li>
<li>
Create a Context object. A typical application creates only one context, but there are some specialized use cases in which a small number of contexts (typically less than 5) are useful. </li>
<li>
Create one or more Source and Receiver objects. It is not unusual for an application to create thousands of sources or receivers. </li>
<li>
The application's main processing phase consists of publishing messages using the Source objects, and receiving messages using the Receiver objects. UM is most efficiently used if those Source and Receiver objects are created during initialization. Dynamic object creation during normal operation is possible, but can require special coding. </li>
<li>
When the application is ready to shut down, Sources and Receivers should be deleted. </li>
<li>
Contexts are deleted after all Sources and Receivers are deleted. Note that if the context uses <a class="el" href="fundamentalconcepts.html#sequentialmode">Sequential Mode</a>, the event processing thread should be unblocked and joined prior to Context deletion. </li>
<li>
Event Queues, if used, are deleted last. Note that the Event Queue dispatching thread(s) should be unblocked and joined prior to deletion of the Event Queue. </li>
</ol>
<p>Note that it is very important to enforce the above deletion order. For example, it can lead to crashes if you delete a context while it still has active Sources or Receivers associated with it. Similarly, crashes can result if you delete an event queue while it still has active Contexts associated with it.</p>
<p>Also, note that deletion of Source objects can affect the reliability of message delivery. UM Receivers are designed to detect lost packets and request retransmission. However, once a Source object is deleted, it can no longer fulfill retransmission requests. It is usually best for an application to delay a few seconds after sending its last messages before deleting the Sources. This is especially important if <a class="el" href="architecture.html#implicitbatching">Implicit Batching</a> is used since outgoing messages might be held in the Batcher.</p>
<p><br />
 </p>
<h1><a class="anchor" id="contextobject"></a>
Context Object&nbsp;&nbsp;<small><a href="#contextobject">&lt;-</a></small></h1>
<p>A UM context object conceptually is an environment in which UM runs. An application creates a context, typically during initialization, and uses it for most other UM operations. In the process of creating the context, UM normally starts an independent thread (the context thread) to do the necessary background processing such as the following: </p><ul>
<li>
Topic resolution </li>
<li>
Enforce rate controls for sending messages </li>
<li>
Manage timers </li>
<li>
Manage state </li>
<li>
Implement UM protocols </li>
<li>
Manage <a class="el" href="fundamentalconcepts.html#transportsessions">Transport Sessions</a> </li>
</ul>
<p>You create a context with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8058947690bd0995bc2c59d4a61b462f">lbm_context_create()</a>. When an application is finished with the context (no more message passing needed), it should delete the context by calling <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a962bfceb336c65191ba08497ac70602b">lbm_context_delete()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Before deleting a context, you must first delete all objects contained within that context (sources, receivers, wildcard receivers). See <a class="el" href="fundamentalconcepts.html#deletingumobjects">Deleting UM Objects</a>.</dd></dl>
<p>Your application can give a context a name, which are optional but should be unique across your UM network. You set a context name before calling <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8058947690bd0995bc2c59d4a61b462f">lbm_context_create()</a> in the following ways:</p>
<ul>
<li>
If you are using XML UM configuration files, call <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a3a97ec59981f5b863b0b40faf82eceb8">lbm_context_attr_set_from_xml()</a> or <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a04d99cc97d32f359888c5befcc50512e">lbm_context_attr_create_from_xml()</a> and set the name in the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#contextnamecontext">context_name (context)</a> parameter. </li>
<li>
If you are using plain text UM configuration files, call <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ab67f641d5a0ad1a9fe53d415da58d961">lbm_context_attr_setopt()</a> and specify <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#contextnamecontext">context_name (context)</a> as the optname and the context's name as the optval. Don't forget to set the optlen. </li>
<li>
Create a plain text UM configuration file with the option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#contextnamecontext">context_name (context)</a> set to the name of the context. </li>
</ul>
<p>Context names are optional but should be unique within a process. UM does not enforce uniqueness, rather issues a log warning if it encounters duplicate context names. Application context names are only used to load template and individual option values within an XML UM configuration file.</p>
<p>One of the more important functions of a context is to hold configuration information that is of context scope. See the <a href="../Config/index.html">UM Configuration Guide</a> for options that are of context scope.</p>
<p>Most UM applications create a single context. However, there are some specialized circumstances where an application would create multiple contexts. For example, with appropriate configuration options, two contexts can provide separate topic name spaces. Also, multiple contexts can be used to portion available bandwidth across topic sub-spaces (in effect allocating more bandwidth to high-priority topics).</p>
<dl class="section attention"><dt>Attention</dt><dd>Regardless of the number of contexts created by your application, a good practice is to keep them open throughout the life of your application. Do not close them until you close the application.</dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="topicobject"></a>
Topic Object&nbsp;&nbsp;<small><a href="#topicobject">&lt;-</a></small></h1>
<p>A UM topic object is conceptually very simple; it is little more than a container for a string (the topic name). However, UM uses the topic object to hold a variety of state information used by UM for internal processing. It is conceptually contained within a context. Topic objects are used by applications in the creation of <a class="el" href="umobjects.html#sourceobject">sources</a> and <a class="el" href="umobjects.html#receiverobject">receivers</a>.</p>
<p>Technically, the user's application does not create or delete topic objects. Their management is handled internally by UM, as needed. The application uses APIs to gain access to topic objects. A publishing application calls <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a1ba60407fa2bde0997aab6d5a5d2da1a">lbm_src_topic_alloc()</a> to get a reference to a topic object that it intends to use for creation of a <a class="el" href="umobjects.html#sourceobject">Source Object</a>. A subscribing application calls <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a3de8a6a659896f76475c453683db4e18">lbm_rcv_topic_lookup()</a> to get a reference to a topic object that it intends to use for creation of a <a class="el" href="umobjects.html#receiverobject">Receiver Object</a>.</p>
<p>The application does not need to explicitly tell UM when it no longer needs the topic object. The application's reference can simply be discarded.</p>
<p><br />
 </p>
<h1><a class="anchor" id="sourceobject"></a>
Source Object&nbsp;&nbsp;<small><a href="#sourceobject">&lt;-</a></small></h1>
<p>A UM source object is used to send messages to the topic that it is bound to. It is conceptually contained within a context.</p>
<p>You create a source object by calling <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ab8dd76271bf9df7a5f88476d431f523e">lbm_src_create()</a>. One of its parameters is a <a class="el" href="umobjects.html#topicobject">Topic Object</a>. A source object can be bound to only one topic. The application is responsible for deleting a source object when it is no longer needed by calling <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a29d45db8f76835b4ae78f4568c25712f">lbm_src_delete()</a>. See <a class="el" href="fundamentalconcepts.html#deletingumobjects">Deleting UM Objects</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="sourcestring"></a>
Source String&nbsp;&nbsp;<small><a href="#sourcestring">&lt;-</a></small></h2>
<p>Every source that a publishing application creates has associated with it a unique "source string". Note that if multiple publishing UM contexts (applications) create sources for the same topic, each context's source will have its own unique source string. Similarly, if one publishing UM context (application) creates multiple sources for different topics, each topic's source will have its own unique source string. So a source string identifies one specific instance of a topic within a UM context.</p>
<p>The source string is used in a few different ways in the UM API, for example to identify which <a class="el" href="fundamentalconcepts.html#transportsessions">Transport Session</a> to retrieve statistics for in <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a4094c703f97a7ebe340b985b2ed1ac2b">lbm_rcv_retrieve_transport_stats()</a>. The source string is made available to the application in several callbacks, for example <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a20d2e77507380a39c081a95462acb995">lbm_src_notify_function_cb</a>, or the "source" field of <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/structlbm__msg__t__stct.html">lbm_msg_t_stct</a> of a received message. See also <a class="el" href="umfeatures.html#sendingtosources">Sending to Sources</a>.</p>
<p>The format of a source string depends on the transport type: </p><ul>
<li>
<p class="startli">TCP:src_ip:src_port:session_id[topic_idx] <br />
 example: <code>TCP:10.29.3.88:45789:f1789bcc[1539853954]</code></p>
<p class="endli"></p>
</li>
<li>
<p class="startli">LBTRM:src_ip:src_port:session_id:mc_group:dest_port[topic_idx] <br />
 example: <code>LBTRM:10.29.3.88:14390:e0679abb:231.13.13.13:14400[1539853954]</code></p>
<p class="endli"></p>
</li>
<li>
<p class="startli">LBT-RU:src_ip:src_port:session_id[topic_idx] <br />
 example: <code>LBT-RU:10.29.3.88:14382:263170a3[1539853954]</code></p>
<p class="endli"></p>
</li>
<li>
<p class="startli">LBT-IPC:session_id:transport_id[topic_idx] <br />
 example: <code>LBT-IPC:6481f8d4:20000[1539853954]</code></p>
<p class="endli"></p>
</li>
<li>
<p class="startli">LBT-SMX:session_id:transport_id[topic_idx] <br />
 example: <code>LBT-SMX:6481f8d4:20000[1539853954]</code></p>
<p class="endli"></p>
</li>
<li>
BROKER <br />
 example: <code>BROKER</code> </li>
</ul>
<p>Please note that the topic index field (topic_idx) may or may not be included, depending on the context in which it is presented, your version of UM, and the setting for configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#sourceincludestopicindexcontext">source_includes_topic_index (context)</a>. For example, a receiver callback probably will include the topic index since the callback is specific to a topic, while <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/operations.tag:../Operations/" href="../Operations/monitoring.html">Monitoring</a> output will not, since it is referring to a transport session, not an individual topic.</p>
<p>See also <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#afa35ad2c7d5d473ffeda6727022f9b94">lbm_transport_source_format()</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a30bf33dce2021f6ea8915b45f511af56">lbm_transport_source_parse()</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="sourcestringsinaroutednetwork"></a>
Source Strings in a Routed Network&nbsp;&nbsp;<small><a href="#sourcestringsinaroutednetwork">&lt;-</a></small></h2>
<p>In a UM network consisting of multiple Topic Resolution Domains (TRDs) connected by <a class="el" href="fundamentalconcepts.html#umrouter">DROs</a>, a given source will be uniquely identifiable within a TRD by its source string. However, that same source will have different source strings in different TRDs. For receivers in the same TRD as the source, the source string will refer to the source. But in remote TRDs, that same source's source string will refer to the <em>proxy source</em> of the DRO on the shortest path to the source. The IP information contained in the source string will refer to the DRO.</p>
<p>This can lead to a situation where multiple originating sources located elsewhere in the UM network will have source strings with the same IP information in a given TRD. They will differ by Topic Index number, but even that topic index will be different in different TRDs.</p>
<p><br />
 </p>
<h2><a class="anchor" id="sourceconfigurationandtransportsessions"></a>
Source Configuration and Transport Sessions&nbsp;&nbsp;<small><a href="#sourceconfigurationandtransportsessions">&lt;-</a></small></h2>
<p>As with contexts, a source holds configuration information that is of source scope. This includes network options, operational options and reliability options for LBT-RU and LBT-RM. For example, each source can use a different transport and would therefore configure a different network address to which to send topic messages. See the <a href="../Config/index.html">UM Configuration Guide</a> for source configuration options.</p>
<p>As stated in <a class="el" href="fundamentalconcepts.html#umtransports">UM Transports</a>, many topics (and therefore sources) can be mapped to a single transport. Many of the configuration options for sources actually control or influence <a class="el" href="fundamentalconcepts.html#transportsessions">Transport Session</a> activity. If many sources are sending topic messages over a single Transport Session (TCP, LBT-RU or LBT-RM), UM only uses the configuration options for the first source assigned to the transport.</p>
<p>For example, if the first source to use a LBT-RM Transport Session sets the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmreliability.html#transportlbtrmnakgenerationintervalreceiver">transport_lbtrm_nak_generation_interval (receiver)</a> to 24 MB and the second source sets the same option to 2 MB, UM assigns 24 MB to the Transport Session's <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmreliability.html#transportlbtrmnakgenerationintervalreceiver">transport_lbtrm_nak_generation_interval (receiver)</a>.</p>
<p>The <a href="../Config/index.html">UM Configuration Guide</a> identifies the source configuration options that may be ignored when UM assigns the source to an existing Transport Session. Log file warnings also appear when UM ignores source configuration options.</p>
<p><br />
 </p>
<h1><a class="anchor" id="receiverobject"></a>
Receiver Object&nbsp;&nbsp;<small><a href="#receiverobject">&lt;-</a></small></h1>
<p>A UM receiver object is used to receive messages from the topic that it is bound to. It is conceptually contained within a context. Messages are delivered to the application by an application callback function, specified when the receiver object is created.</p>
<p>You create a receiver object by calling <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aa7491c50fefbc2b70f8035fce7ac1477">lbm_rcv_create()</a>. One of its parameters is a <a class="el" href="umobjects.html#topicobject">Topic Object</a>. A receiver object can be bound to only one topic. The application is responsible for deleting a receiver object when it is no longer needed by calling <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8d5e8713f5ae776330b23a1e371f934d">lbm_rcv_delete()</a>. See <a class="el" href="fundamentalconcepts.html#deletingumobjects">Deleting UM Objects</a>.</p>
<p>Multiple receiver objects can be created for the same topic within a single context, which can be used to trigger multiple delivery callbacks when messages arrive for that topic.</p>
<p><br />
 </p>
<h2><a class="anchor" id="receiverconfigurationandtransportsessions"></a>
Receiver Configuration and Transport Sessions&nbsp;&nbsp;<small><a href="#receiverconfigurationandtransportsessions">&lt;-</a></small></h2>
<p>A receiver holds configuration information that is of receiver scope. This includes network options, operational options and reliability options for LBT-RU and LBT-RM. See the <a href="../Config/index.html">UM Configuration Guide</a> for receiver configuration options.</p>
<p>As stated above in <a class="el" href="umobjects.html#sourceconfigurationandtransportsessions">Source Configuration and Transport Sessions</a>, multiple topics (and therefore receivers) can be mapped to a single transport. As with source configuration options, many receiver configuration options control or influence <a class="el" href="fundamentalconcepts.html#transportsessions">Transport Session</a> activity. If multiple receivers are receiving topic messages over a single Transport Session (TCP, LBT-RU or LBT-RM), UM only uses the configuration options for the first receiver assigned to the transport.</p>
<p>For example, if the first receiver to use a LBT-RM Transport Session sets <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmreliability.html#transportlbtrmnakgenerationintervalreceiver">transport_lbtrm_nak_generation_interval (receiver)</a> to 10 seconds, that value is applied to the Transport Session. If a second receiver using the same transport session sets the same option to 2 seconds, that value is ignored.</p>
<p>The <a href="../Config/index.html">UM Configuration Guide</a> identifies the receiver configuration options that may be ignored when UM assigns the receiver to an existing Transport Session. Log file warnings also appear when UM ignores receiver configuration options.</p>
<p><br />
 </p>
<h2><a class="anchor" id="umwildcardreceivers"></a>
UM Wildcard Receivers&nbsp;&nbsp;<small><a href="#umwildcardreceivers">&lt;-</a></small></h2>
<p>You create a wildcard receiver object by calling <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a5b5d52f6b87499213757b73b09bc8160">lbm_wildcard_rcv_create()</a>. Instead of a topic object, the caller supplies a pattern which UM uses to match multiple topics. Because the application does not explicitly lookup the topics, UM passes the topic attribute into <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a5b5d52f6b87499213757b73b09bc8160">lbm_wildcard_rcv_create()</a> so that it can set options. Also, wildcard receivers have their own set of options, such as pattern type. The application is responsible for deleting a wildcard receiver object when it is no longer needed by calling <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a64407f3874012efaebcba322ea6d229d">lbm_wildcard_rcv_delete()</a>.</p>
<p>The wildcard pattern supplied for matching is a PCRE regular expression that Perl recognizes. See <a href="http://perldoc.perl.org/perlrequick.html">http://perldoc.perl.org/perlrequick.html</a> for details about PCRE.</p>
<dl class="section note"><dt>Note</dt><dd>Ultra Messaging has deprecated two other wildcard receiver pattern types, regex POSIX extended regular expressions and appcb application callback, as of UM Version 6.1. Only PCRE is supported.</dd></dl>
<p>Be aware that some platforms may not support all of the regular expression wildcard types. For example, UM does not support the use of Unicode PCRE characters in wildcard receiver patterns on any system that communicates with a HP-UX or AIX system. See the Informatica Knowledge Base article, <a href="https://kb.informatica.com/faq/5/Pages/80077.aspx">Platform-Specific Dependencies</a> for details.</p>
<p>For examples of wildcard usage, see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/example.tag:../example/" href="../example/index.html#examplelbmwrcv_c">Example lbmwrcv.c</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/java_example.tag:../java_example/" href="../java_example/index.html#examplelbmwrcv_java">Example lbmwrcv.java</a>, and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/dotnet_example.tag:../dotnet_example/" href="../dotnet_example/index.html#examplelbmwrcv_cs">Example lbmwrcv.cs</a>.</p>
<p>For more information on wildcard receivers, see <a class="el" href="architecture.html#wildcardreceivertopicresolution">Wildcard Receiver Topic Resolution</a>, and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/config.tag:../Config/" href="../Config/grpwildcardreceiver.html">Wildcard Receiver Options</a>.</p>
<p>TIBCO users see the Informatica Knowledge Base articles, <a href="https://kb.informatica.com/faq/5/Pages/80075.aspx">Wildcard topic regular expressions and SmartSockets wildcards</a> and <a href="https://kb.informatica.com/faq/5/Pages/80277.aspx">Wildcard topic regular expressions and Rendezvous wildcards</a>.</p>
<p><a class="anchor" id="overlappingreceivers"></a><b>Overlapping Receivers</b></p>
<p>Suppose an application creates three receivers:</p>
<ol>
<li>
Wildcard receiver1: "^example[0-9]$" </li>
<li>
Single-topic receiver: "example1". </li>
<li>
Wildcard receiver2: "^[a-z]*1$" </li>
</ol>
<p>A source for topic "example1" will match all three receivers. Each receiver's object's "receiver callback" will be invoked sequentially for each received message. However, be aware that these are simply multiple callbacks from a single underlying UM receiver; they are not independent.</p>
<p>This becomes significant if different "receiver" scoped configuration options are specified for the different receiver objects, a usage that Informatica recommends against. Only one of the receiver object's configuration is used to create the underlying receiver; the others are ignored. In the above example, it is not necessarily the first receiver object which applies its configuration. If, for example, the source is not yet discovered until later, UM does not define which of the above three receiver objects will be used.</p>
<p>Informatica recommends users always use the same configuration options when creating multiple receiver objects that overlap.</p>
<p><br />
 </p>
<h2><a class="anchor" id="transportservicesproviderobject"></a>
Transport Services Provider Object&nbsp;&nbsp;<small><a href="#transportservicesproviderobject">&lt;-</a></small></h2>
<p>The Transport Services Provider object ("XSP") was introduced with UM version 6.11 to manage sockets, threads, and other receive-side resources associated with subscribed <a class="el" href="fundamentalconcepts.html#transportsessions">Transport Sessions</a>. The primary purpose for an XSP object is to allow the programmer to control the threading of received messages, based on the Transport Sessions of those messages.</p>
<p>For more information on XSP, see <a class="el" href="umfeatures.html#transportservicesproviderxsp">Transport Services Provider (XSP)</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="umhotfailoveracrosscontextsobjects"></a>
UM Hot Failover Across Contexts Objects (HFX)&nbsp;&nbsp;<small><a href="#umhotfailoveracrosscontextsobjects">&lt;-</a></small></h2>
<p>Hot Failover Across Contexts objects ("HFX") provide a form of hot failover that can operate across multiple network interfaces.</p>
<p>Note that the HFX feature is deprecated.</p>
<p>See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/gateway.tag:../Gateway/" href="../Gateway/umrouterconcepts.html#drohotlinks">DRO Hotlinks</a> for a similar feature.</p>
<p><br />
 </p>
<h1><a class="anchor" id="eventqueueobject"></a>
Event Queue Object&nbsp;&nbsp;<small><a href="#eventqueueobject">&lt;-</a></small></h1>
<p>Most UM events, like received messages, are delivered to the application via event handler callbacks, like a receiver callback. A UM "event queue" object is a queue for moving execution of a UM callbacks to a different thread - the event queue dispatch thread.</p>
<p>Note that unlike other UM objects, event queues are not owned by a context. An event queue is a top-level object, and can be associated with contexts, sources, and/or receivers.</p>
<dl class="section warning"><dt>Warning</dt><dd>Before deleting an event queue, you must first delete all objects associated with it (contexts, sources, receivers, timers). See <a class="el" href="fundamentalconcepts.html#deletingumobjects">Deleting UM Objects</a>.</dd></dl>
<p>By default, UM events will be delivered from a variety of different threads, frequently a context or XSP thread. Context/XSP thread callbacks are the most efficient form of event delivery, but place restrictions on your callback code. For example:</p>
<ul>
<li>
The application function is not allowed to make certain API calls (mostly having to do with creating or deleting UM objects). </li>
<li>
The application function must execute very quickly without blocking. </li>
<li>
The application does not have control over when the callback executes. For example, events might be delivered concurrently from different application and context/XSP threads. </li>
</ul>
<p>For these reasons, you might want to transfer handling of UM events to a different thread. This can impose strict serialization and remove restrictions.</p>
<p>You could make use of your own queue for this, perhaps a standard library queue (although be careful of multiple threads enqueuing on the same queue), or perhaps <a href="https://lmax-exchange.github.io/disruptor/disruptor.html">LMAX's "Disruptor"</a>. Or you can use the UM event queue.</p>
<p>An advantage of the UM event queue is that it retains all of the semantics of the UM callback. The callback code is structured the same, regardless of whether it is called from a context/XSP thread or from an event queue dispatch thread. A disadvantage of the UM event queue is efficiency: it makes a kernel call for each enqueue and each dequeue.</p>
<p>UM event queues are unbounded, non-blocking queues and provide the following features:</p>
<ul>
<li>
Queue length monitoring. Informatica strongly recommends using the event queue monitor callback to warn if the configured <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/config.tag:../Config/" href="../Config/grpeventqueue.html#queuesizewarningeventqueue">size</a> or <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/config.tag:../Config/" href="../Config/grpeventqueue.html#queuedelaywarningeventqueue">latency</a> thresholds are exceeded. (Note: exceeding a threshold does not prevent new events from being enqueued.) See <a class="el" href="umobjects.html#eventqueuemonitor">Event Queue Monitor</a> for more information. </li>
<li>
The application callback function has no UM API restrictions. </li>
<li>
Your application can control exactly when UM delivers queued events with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ac06b127bae882dd5fb68b7044fdceb5f">lbm_event_dispatch()</a>. And you can have control return to your application either when specifically asked to do so (by calling <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#af4b1b274cb142acefe0826673ecffdbe">lbm_event_dispatch_unblock()</a>), or optionally when there are no events left to deliver. </li>
<li>
Your application can take advantage of parallel processing on multiple processor hardware since UM processes asynchronously on a separate thread from your application's processing of received messages. By using multiple application threads to dispatch an event queue, or by using multiple event queues, each with its own dispatch thread, your application can further increase parallelism. </li>
</ul>
<p>You create an UM event queue in the C API by calling <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ac7ebe02319363c84bef08f34be7865ec">lbm_event_queue_create()</a>. When finished with an event queue, delete it by calling <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a189f4c0178374d488acacf592c3015e4">lbm_event_queue_delete()</a>.</p>
<p>In the Java API and the .NET API, use the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMEventQueue.html">LBMEventQueue</a> class.</p>
<p>See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/config.tag:../Config/" href="../Config/grpeventqueue.html">Event Queue Options</a> for configuration options related to event queues.</p>
<p><br />
 </p>
<h2><a class="anchor" id="usinganeventqueue"></a>
Using an Event Queue&nbsp;&nbsp;<small><a href="#usinganeventqueue">&lt;-</a></small></h2>
<p>To use an Event Queue, an application typically performs the following actions: </p><ol>
<li>
Create the Event Queue using <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ac7ebe02319363c84bef08f34be7865ec">lbm_event_queue_create()</a>. <div class="fragment"><div class="line"><a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a6897baf281a5b4729e05c873aacac420">lbm_event_queue_t</a> *evq;</div><div class="line">err = <a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ac7ebe02319363c84bef08f34be7865ec">lbm_event_queue_create</a>(&amp;evq, NULL, NULL, NULL);</div></div><!-- fragment --> </li>
<li>
Create a new thread of execution to be the dispatch thread. This new thread should call <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ac06b127bae882dd5fb68b7044fdceb5f">lbm_event_dispatch()</a> in a loop. <div class="fragment"><div class="line">evq_running = 1;</div><div class="line"><span class="keywordflow">while</span> (evq_running) {</div><div class="line">  err = <a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ac06b127bae882dd5fb68b7044fdceb5f">lbm_event_dispatch</a>(evq, LBM_EVENT_QUEUE_BLOCK);</div><div class="line">  <span class="keywordflow">if</span> (err == LBM_FAILURE) { ... handle error ... }</div><div class="line">}</div><div class="line"><span class="comment">/* Exit the thread (OS-dependent). */</span></div></div><!-- fragment --> Note that the return value should be compared to <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a06fc87d81c62e9abb8790b6e5713c55baf90fd7c1c303f82795102f289988877a">LBM_FAILURE</a> (-1), and not the normal success value of 0. This is because on success, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ac06b127bae882dd5fb68b7044fdceb5f">lbm_event_dispatch()</a> returns the number of events that were dispatched during its execution. </li>
<li>
Create other UM objects whose events you want processed by the event queue. For example, creating a UM Receiver object with the Event Queue will call your message receiver callback through the event queue, using your dispatch thread. <div class="fragment"><div class="line"><a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a0a4af6b8247cc5a0a24a8578fb6e83bd">lbm_rcv_t</a> *rcv;</div><div class="line">err = <a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aa7491c50fefbc2b70f8035fce7ac1477">lbm_rcv_create</a>(&amp;rcv, ctx, topic, app_rcv_callback, NULL, evq);</div></div><!-- fragment --> From this point, your application receiver callback function will be called from the dispatch loop for received messages and other receiver events. </li>
<li>
When it is time to shut down the program, the UM objects that refer to the event queue must first be deleted. <div class="fragment"><div class="line">err = <a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8d5e8713f5ae776330b23a1e371f934d">lbm_rcv_delete</a>(rcv);</div></div><!-- fragment --> Remember that an event queue might be handling events for many UM objects; they must all be deleted prior to deleting the event queue. </li>
<li>
Now shut down dispatching the event queue. <div class="fragment"><div class="line">evq_running = 0;</div><div class="line">err = <a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#af4b1b274cb142acefe0826673ecffdbe">lbm_event_dispatch_unblock</a>(evq);</div><div class="line"><span class="comment">/* &quot;Join&quot; the dispatch thread (OS-dependent). */</span></div></div><!-- fragment --> The unblock forces the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ac06b127bae882dd5fb68b7044fdceb5f">lbm_event_dispatch()</a> function to return. Typically at that point, the dispatch thread is "joined", which blocks until the dispatch thread exits. </li>
<li>
Delete the event queue. <div class="fragment"><div class="line">err = <a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a189f4c0178374d488acacf592c3015e4">lbm_event_queue_delete</a>(evq);</div></div><!-- fragment --> </li>
</ol>
<p>Here are some lesser used event queue APIs: </p><ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ab0a5134ef39fc7054e5d164f0a1889f7">lbm_event_queue_size()</a> - number of events in the queue. </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ad94310754a9f685693f789a017c7bb7e">lbm_event_queue_shutdown()</a> - purge events from the queue (risky). </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aeb9ed445a630f0db48f8c9d24bf23178">lbm_event_queue_retrieve_stats()</a> - retrieve statistics counters. </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a1838b8382eb314eed96e6ed48c0d1f5b">lbm_event_queue_reset_stats()</a> - reset statistics counters. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="deletinganeventqueue"></a>
"Deleting an Event Queue"&nbsp;&nbsp;<small><a href="#deletinganeventqueue">&lt;-</a></small></h2>
<p>Before you can delete an event queue, you must ensure that your application's dispatch thread is no longer running it. Here is the typical order of operation for deleting an event queue: </p><ol>
<li>
<p class="startli"><b>Unblock the event queue</b> (<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#af4b1b274cb142acefe0826673ecffdbe">C API</a> / <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMEventQueue.html#a7ab8e8a3b6cc2c82843acbd549f03b0b">Java and .NET API</a>). This causes the application's dispatch thread to return from the dispatch function (<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ac06b127bae882dd5fb68b7044fdceb5f">C API</a> / <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMEventQueue.html#ae39293f006fbec45d420b8794b1b4512">Java and .NET API</a>).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Exit the application's dispatch thread</b>, typically with a thread join function.</p>
<p class="endli"></p>
</li>
<li>
<b>Delete the event queue</b> (<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a189f4c0178374d488acacf592c3015e4">C API</a> / <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMEventQueue.html#af7293afb0a08887009264f98c0735192">Java and .NET API</a>). </li>
</ol>
<p><br />
 </p>
<h2><a class="anchor" id="eventqueueefficiency"></a>
Event Queue Efficiency&nbsp;&nbsp;<small><a href="#eventqueueefficiency">&lt;-</a></small></h2>
<p>A UM event queue introduces a kernel call with each enqueue and dequeue. Kernel calls are considered costly for very low latency or high throughput applications.</p>
<p>Compared with a lockless, busy waiting queue like <a href="https://lmax-exchange.github.io/disruptor/disruptor.html">LMAX's "Disruptor"</a>, the UM event queue will have a lower maximum sustainable throughput and higher latency. The latency penalty will be especially apparent at low message rates where the dispatch thread is put to sleep waiting for new events.</p>
<p>The performance of the UM event queue can be improved by using <a class="el" href="advancedoptimizations.html#receivesidebatching">Receive-Side Batching</a> and by polling the event queue in a tight loop (see <a class="el" href="umobjects.html#eventqueuetimeout">Event Queue Timeout</a>).</p>
<p><br />
 </p>
<h2><a class="anchor" id="eventqueuetimeout"></a>
Event Queue Timeout&nbsp;&nbsp;<small><a href="#eventqueuetimeout">&lt;-</a></small></h2>
<p>The second parameter passed to <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ac06b127bae882dd5fb68b7044fdceb5f">lbm_event_dispatch()</a> is a timeout. There are two special values: </p><ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a2c6b535637bfd72be2905b0cd4782140">LBM_EVENT_QUEUE_BLOCK</a> - no timeout. Do not return until <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#af4b1b274cb142acefe0826673ecffdbe">lbm_event_dispatch_unblock()</a> is called. </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a1995a85e2c983f6b38322c5c5784f32e">LBM_EVENT_QUEUE_POLL</a> - no wait. If there are one or more events in the queue, process exactly one of them and return. Otherwise, return immediately without waiting. </li>
</ul>
<p>Any other value specifies a timeout in milliseconds.</p>
<p>However, this timeout does not necessarily limit the time spent waiting inside the dispatch function. The purpose of the timeout is to set a <em>minimum</em> time that the dispatch function will process events, not a maximum.</p>
<p>The implementation of the event queue uses an unbounded wait for incoming events. When an event is delivered to the queue, the dispatch function wakes up and processes the event (calls the appropriate application callback). Then the dispatch function checks the time to see if the timeout has been exceeded. If so, the dispatch function returns. Otherwise, it waits for the next event.</p>
<p>However, suppose that no further events are delivered to the event queue. In this case, the dispatch function will wait without bound. The timeout parameter will not cause the dispatch function to stop waiting.</p>
<p>If the application needs an upper limit to the time spent dispatching, the timeout can be combined with the use of an external timer that calls <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#af4b1b274cb142acefe0826673ecffdbe">lbm_event_dispatch_unblock()</a> when the maximum time has expired. UM's timer system may be used by calling <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a6ddbee95ee1eb4e6b98b177f84157f8a">lbm_schedule_timer()</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="eventqueuemonitor"></a>
Event Queue Monitor&nbsp;&nbsp;<small><a href="#eventqueuemonitor">&lt;-</a></small></h2>
<p>The UM event queue is unbounded, meaning that it doesn't have a fixed maximum size. Rather, if the incoming event (e.g. message) rate exceeds the callback processing rate, the event queue will grow without bound, eventually consuming the maximum available memory, usually crashing the program.</p>
<p>The only way to prevent this unbounded memory growth is to ensure that your event handler callback can keep up with the incoming event rate. However, this is usually impossible to guarantee, so it is important for applications to monitor queue growth and at least raise an alert if it exceeds some threshold.</p>
<p>The event queue size can change very quickly during traffic bursts. <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/operations.tag:../Operations/" href="../Operations/monitoring.html#automaticmonitoring">Automatic Monitoring</a> is not a good solution for detecting these rapid spikes in queue length. UM has a special form of monitoring designed specifically for event queues: a monitoring callback.</p>
<p>You set the size threshold, in number of events, using <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/config.tag:../Config/" href="../Config/grpeventqueue.html#queuesizewarningeventqueue">queue_size_warning (event_queue)</a>. You can also set a latency threshold, in microseconds that events are waiting in the event queue, using <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/config.tag:../Config/" href="../Config/grpeventqueue.html#queuedelaywarningeventqueue">queue_delay_warning (event_queue)</a>. It is also possible to be notified every time an event is added to the event queue, using <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/config.tag:../Config/" href="../Config/grpeventqueue.html#queueenqueuenotificationeventqueue">queue_enqueue_notification (event_queue)</a> (no information is available about the event).</p>
<p>UM tests the queue against the thresholds during the process of dispatching events. When the dispatch thread dequeues an event, it checks the size of the queue and the amount of time the dequeued event spent in the queue. If either or both exceed their thresholds, the monitor callback is called. If there is a burst of traffic, the size threshold can be exceeded by many events. In that case, the monitor callback will be called repeatedly for each dequeued event that exceeds a threshold.</p>
<p>Informatica strongly recommends minimizing the monitor callback to perform as little work as possible. Remember that the event queue grows when the event handling callback cannot keep up with the incoming event rate. Given that the monitor callback is called by the dispatch thread, its execution time is added to your event handler, slowing it down even further. We recommend setting a "high water mark" of the maximum detected queue size, and letting a separate thread periodically check that high water mark and raise an alert.</p>
<p>Note that if an application event handling callback were to deadlock and never return, the dispatch thread would be effectively halted, and the monitor callback would never be called. The monitor callback cannot be used to detect a hung application.</p>
<p><b>C Code Example:</b> </p><div class="fragment"><div class="line"><span class="comment">/* Define monitor callback. */</span></div><div class="line"><span class="keywordtype">int</span> evq_monitor(<a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a6897baf281a5b4729e05c873aacac420">lbm_event_queue_t</a> *evq, <span class="keywordtype">int</span> event, <span class="keywordtype">size_t</span> evq_size,</div><div class="line">                <a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a72438fab15bf500af58d2a8a521e470d">lbm_ulong_t</a> evq_delay_usec, <span class="keywordtype">void</span> *clientd)</div><div class="line">{</div><div class="line">  <span class="comment">/* The &quot;event&quot; parameter is sometimes used as a bitmap, and other times</span></div><div class="line"><span class="comment">   * used as an absolute value. */</span></div><div class="line">  <span class="keywordflow">if</span> ((event == LBM_EVENT_QUEUE_ENQUEUE_NOTIFICATION)</div><div class="line">       &amp;&amp; (evq_size == 1) &amp;&amp; (evq_delay_usec == 0)) {</div><div class="line">    <span class="comment">/* This is an ENQUEUE notification. No info available on the event. */</span></div><div class="line">    ...</div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span> {</div><div class="line">    <span class="comment">/* &quot;event&quot; is a bitmap; one or both conditions might be active. */</span></div><div class="line">    <span class="keywordflow">if</span> (event &amp; LBM_EVENT_QUEUE_SIZE_WARNING) {</div><div class="line">      <span class="comment">/* The size threshold is exceeded for the next event to be dispatched.</span></div><div class="line"><span class="comment">       * There are evq_size events in the queue. */</span></div><div class="line">      ...</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (event &amp; LBM_EVENT_QUEUE_DELAY_WARNING) {</div><div class="line">      <span class="comment">/* The delay threshold is exceeded for the next event to be dispatched.</span></div><div class="line"><span class="comment">       * The next event to be dispatched waited in the queue for evq_delay_usec */</span></div><div class="line">      ...</div><div class="line">    }</div><div class="line">  }</div><div class="line">}  <span class="comment">/* evq_monitor */</span></div><div class="line"></div><div class="line">  ...</div><div class="line">  <span class="comment">/* Initialization code, create event queue. */</span></div><div class="line">  <a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a6897baf281a5b4729e05c873aacac420">lbm_event_queue_t</a> *evq;</div><div class="line">  ...</div><div class="line">  err = <a class="codeRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ac7ebe02319363c84bef08f34be7865ec">lbm_event_queue_create</a>(&amp;evq, evq_monitor, NULL, NULL);</div></div><!-- fragment --><p><b>Java and .NET Code Example:</b> </p><div class="fragment"><div class="line"><span class="comment">/* Define monitor callback. */</span></div><div class="line"><span class="keyword">class </span>MyEventQueue <span class="keyword">extends</span> LBMEventQueue implements LBMEventQueueCallback</div><div class="line">{</div><div class="line">  <span class="keyword">public</span> MyEventQueue() throws LBMException</div><div class="line">  {</div><div class="line">      super();</div><div class="line">      addMonitor(<span class="keyword">this</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keywordtype">void</span> monitor(Object cbArg, <span class="keywordtype">int</span> event, <span class="keywordtype">int</span> evqSize, <span class="keywordtype">long</span> evqDelayUsec)</div><div class="line">  {</div><div class="line">    <span class="comment">/* The &quot;event&quot; parameter is sometimes used as a bitmap, and other times</span></div><div class="line"><span class="comment">     * used as an absolute value. */</span></div><div class="line">    <span class="keywordflow">if</span> ((event == LBM.EVENT_QUEUE_ENQUEUE_NOTIFICATION)</div><div class="line">         &amp;&amp; (evqSize == 1) &amp;&amp; (evqDelayUsec == 0)) {</div><div class="line">      <span class="comment">/* This is an ENQUEUE notification. No info available on the event. */</span></div><div class="line">      ...</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> {</div><div class="line">      <span class="comment">/* &quot;event&quot; is a bitmap; one or both conditions might be active. */</span></div><div class="line">      <span class="keywordflow">if</span> (event &amp; LBM.EVENT_QUEUE_SIZE_WARNING) {</div><div class="line">        <span class="comment">/* The size threshold is exceeded for the next event to be dispatched. */</span></div><div class="line">        ...</div><div class="line">      }</div><div class="line">      <span class="keywordflow">if</span> (event &amp; LBM.EVENT_QUEUE_DELAY_WARNING) {</div><div class="line">        <span class="comment">/* The delay threshold is exceeded for the next event to be dispatched. */</span></div><div class="line">        ...</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }  <span class="comment">/* monitor */</span></div><div class="line">}</div><div class="line">...</div><div class="line"></div><div class="line">  <span class="comment">/* Initialization, create event queue. */</span></div><div class="line">  MyEventQueue evq = <span class="keyword">new</span> MyEventQueue();</div></div><!-- fragment --><p><br />
 </p>
<h1><a class="anchor" id="messageobject"></a>
Message Object&nbsp;&nbsp;<small><a href="#messageobject">&lt;-</a></small></h1>
<p>When an application subscribes to a topic to which publishers are sending messages, the received messages are delivered to the application by an application callback function (see <a class="el" href="fundamentalconcepts.html#eventdelivery">Event Delivery</a>). One of the parameters that UM passes to the application callback is a message object. This object gives the application access to the content of the message, as well as some metadata about the message, such as the topic.</p>
<p>Unlike other objects described above, the user does not create these message objects by API call. UM creates and initializes the objects internally.</p>
<p>The default life-span of a message object is different between C and Java or .NET.</p>
<p><br />
 </p>
<h2><a class="anchor" id="messageobjectdeletion"></a>
Message Object Deletion&nbsp;&nbsp;<small><a href="#messageobjectdeletion">&lt;-</a></small></h2>
<p><b>C API</b></p>
<p>In C, by default, the message object is deleted when the receiver callback returns. No action is necessary by the application to trigger that deletion.</p>
<p>See <a class="el" href="applicationdesignprinciples.html#messagereception">Message Reception</a> for details, including code examples.</p>
<p><b>Java or .NET API</b></p>
<p>In Java or .NET, the passed-in message object is <em>not</em> automatically deleted when the receiver application callback returns. Instead, the message object is fully deleted only when all references to the object are lost and the garbage collector reclaims the object.</p>
<p>However, applications which allow this kind of garbage buildup and collection usually suffer from large latency outliers (<a class="el" href="umglossary.html#glossaryjitter">jitter</a>), and while garbage collection can be tuned to minimize its impact, it is usually recommended that latency-sensitive applications manage their objects more carefully to prevent creation of garbage. See <a class="el" href="advancedoptimizations.html#zeroobjectdelivery">Zero Object Delivery</a>.</p>
<p>Also, there are some UM features in which specific actions are triggered by the deletion of messages, and the application designer usually wants to control when those actions are performed (for example, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/ume.tag:../UME/" href="../UME/designingpersistentreceivers.html#persistencemessageconsumption">Persistence Message Consumption</a>).</p>
<p>For these reasons, Java and .NET developers are strongly advised to explicitly dispose of a message object when the application is finished with it. It does this by calling the "dispose()" method of the message object. In the simple case, this should be done in the receiver application callback just before returning.</p>
<p>See <a class="el" href="applicationdesignprinciples.html#messagereception">Message Reception</a> for details, including code examples.</p>
<p><br />
 </p>
<h2><a class="anchor" id="messageobjectretention"></a>
Message Object Retention&nbsp;&nbsp;<small><a href="#messageobjectretention">&lt;-</a></small></h2>
<p>Some applications are designed to process received messages in ways that cannot be completed by the time the receiver callback returns. In these cases, the application must extend the life span of the message object beyond the return from the receiver application callback. This is called "message retention".</p>
<p>Note that message retention prevents the recycling of the UM receive buffer in the UM library. See <a class="el" href="advancedoptimizations.html#receivebufferrecycling">Receive Buffer Recycling</a>.</p>
<p><b>C API</b></p>
<p>To prevent automatic deletion of the message object when the receiver application callback returns, the callback must call <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a2b7788ff58f9e78bc89ea890dad0cccf">lbm_msg_retain()</a>. This allows the application to transfer the message object to another thread, work queue, or control flow.</p>
<p>When a received message is retained, it becomes the application's responsibility to delete the message explicitly by calling <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aa5fc1eb324a55b8c800c31460b0f0116">lbm_msg_delete()</a>. Failure to delete retained messages can lead to unbounded memory growth.</p>
<p>See <a class="el" href="applicationdesignprinciples.html#messagereception">Message Reception</a> for details, including code examples.</p>
<p><b>Java or .NET</b></p>
<p>The receiver application callback typically calls the "promote()" method of the message object prior to returning. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/index.html#retainingmessages">Retaining Messages</a>.</p>
<p>See <a class="el" href="applicationdesignprinciples.html#messagereception">Message Reception</a> for details, including code examples.</p>
<p><br />
 </p>
<h1><a class="anchor" id="attributesobject"></a>
Attributes Object&nbsp;&nbsp;<small><a href="#attributesobject">&lt;-</a></small></h1>
<p>An attribute object is used to programmatically configure other UM objects. Their use is usually optional; omitting them results in default configurations (potentially overridden by configuration files). See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/config.tag:../Config/" href="../Config/index.html#configurationoverview">Configuration Overview</a> for details.</p>
<p>However, there is a class of configuration options that require the use of an attribute object: configuring application callbacks. With these options, you are setting a value that includes a pointer to a C function. This cannot be done from a configuration file. For example, see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/config.tag:../Config/" href="../Config/grpdeliverycontrol.html#sourcenotificationfunctionreceiver">source_notification_function (receiver)</a>.</p>
<p>See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/config.tag:../Config/" href="../Config/attributesobjects.html">Attributes Objects</a> for more details on the types, creation, use, and deletion of attributes objects.</p>
<p><br />
 </p>
<h1><a class="anchor" id="umtimers"></a>
UM Timers&nbsp;&nbsp;<small><a href="#umtimers">&lt;-</a></small></h1>
<p>UM also provides a timer function whereby the application can schedule callbacks to be made some number of milliseconds in the future. When a given timer expires, its callback is made. A timer can also be canceled prior to expiration.</p>
<p>These timers are not designed like other UM objects. For example, in the C API, you don't "create" and "delete" them, you "schedule" and optionally "cancel" them. In the Java and .NET APIs, you do instantiate a timer object in the normal way, but you don't "close" them when done.</p>
<dl class="section warning"><dt>Warning</dt><dd>UM timers are not designed for high accuracy. For example, to improve internal efficiency, UM will sometimes expire a timer up to 3 milliseconds early. Also, depending on other work being done, a timer can expire but its callback execution can be delayed an undefined amount of time.</dd></dl>
<p>Main timer API functions: </p><ul>
<li>
<b>Schedule</b> - <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a6ddbee95ee1eb4e6b98b177f84157f8a">C API</a> / <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMTimer.html#ae0fab63f7bfc8a590048c47a1ef5e4c9">Java and .NET API</a>. </li>
<li>
<b>Cancel</b> - <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aac8fc2f828cdcd6a44282c950ee01fb0">C API</a> / <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.17_RC3/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMTimer.html#ae12107268ca270c63bcc56ca8a5cb100">Java and .NET API</a>. </li>
</ul>
<p><br />
<br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
</body>
</html>
