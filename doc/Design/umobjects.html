<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Concepts Guide: UM Objects</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen_manual.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Concepts Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('umobjects.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">UM Objects </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Many UM documents use the term object. Be aware that with the C API, they do not refer to formal objects as supported by C++ (i.e. class instances). The term is used here in an informal sense to denote an entity that can be created, used, and (usually) deleted, has functionality and data associated with it, and is managed through the API. The handle that is used to refer to an object is usually implemented as a pointer to a data structure (defined in <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html">lbm.h</a>), but the internal structure of an object is said to be opaque, meaning that application code should not read or write the structure directly.</p>
<p>However, the UM Java JNI and C# .NET APIs are object oriented, with formal Java/C# objects. See the Java API documentation and .NET API documentation for more information.</p>
<p><br />
 </p>
<h1><a class="anchor" id="messageproperties"></a>
Message Properties&nbsp;&nbsp;<small><a href="#messageproperties">&lt;-</a></small></h1>
<p>The message property object <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a9155c3d6d70b67c426089d53b3eacaac">lbm_msg_properties_t</a> allows your application to insert named, typed metadata to topic messages and implement functionality that depends on the message properties. UM allows eight property types: boolean, byte, short, int, long, float, double, and string.</p>
<p>To use message properties, create a message properties object with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#abda1a4224f1c3e94b10b74051be3dd53">lbm_msg_properties_create()</a>. Then set the desired message properties using <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#acec18484fc06996fe3b61e76a593d5fb">lbm_msg_properties_set()</a>. Then send topic messages with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a091b5806bf18d10ebd0d9117e0c70229">lbm_src_send_ex()</a> (or LBMSource.send() in the Java API or .NET API) passing the message properties object through <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a21504de56612c7c6e4be655402b47a37">lbm_src_send_ex_info_t</a> object. Set the LBM_SRC_SEND_EX_FLAG_PROPERTIES flag on the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a21504de56612c7c6e4be655402b47a37">lbm_src_send_ex_info_t</a> object to indicate that it includes properties.</p>
<p>Upon a receipt of a message with properties, your application can access the properties directly through the messages properties field, which is null if no properties are present. Individual property values can be retrieved directly by name, or you can iterate over the collection of properties to determine which properties are present at runtime. For an example on how to iterate received message properties, see <a href="../example/lbmrcv.c">lbmrcv.c</a>.</p>
<p>To mitigate any performance impacts in the C API, reuse properties objects, <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a21504de56612c7c6e4be655402b47a37">lbm_src_send_ex_info_t</a> objects and iterators whenever possible. Also limit the number of properties associated with a message. (UM sends the property name and additional indexing information with every message.) In the Java API or .NET API, also make use of the ZOD feature by calling dispose() on each message before returning from the application callback. This allows property objects to be reused as well. See <a class="el" href="fundamentalconcepts.html#zeroobjectdelivery">Zero Object Delivery</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The Message Properties Object does not support receivers using the arrival order without reassembly setting (option value = 0) of <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#ordereddeliveryreceiver">ordered_delivery (receiver)</a>.</dd></dl>
<p>With the UMQ product, the UM message property object supports the standard JMS message properties specification.</p>
<p><br />
 </p>
<h2><a class="anchor" id="messagepropertiesperformanceconsiderations"></a>
Message Properties Performance Considerations&nbsp;&nbsp;<small><a href="#messagepropertiesperformanceconsiderations">&lt;-</a></small></h2>
<p>Ultra Messaging sends property names on the wire with every message. To reduce bandwidth requirements, minimize the length and number of properties. When coding sources, consider the following sequence of guidelines:</p>
<ol>
<li>
Allocate a data structure to store message properties objects. This can be a thread-local structure if you use a relatively small number of threads, or a thread-safe pool of objects. </li>
<li>
Before sending, retrieve a message properties object from the pool. If an object is not available, create a new object. </li>
<li>
Set properties for the message. </li>
<li>
Send the message using the appropriate API call, passing in the properties object. </li>
<li>
After the send completes, clear the message properties object and return it to the pool. </li>
</ol>
<p>When coding receivers in Java or .NET, call Dispose() on messages before returning from the application callback. This allows Ultra Messaging to internally recycle objects, and limits object allocation.</p>
<p><br />
 </p>
<h2><a class="anchor" id="smartsourcesandmessageproperties"></a>
Smart Sources and Message Properties&nbsp;&nbsp;<small><a href="#smartsourcesandmessageproperties">&lt;-</a></small></h2>
<p><a class="el" href="advancedoptimizations.html#smartsources">Smart Sources</a> support a limited form of message properties. Only 32-bit integer property types are allowed with Smart Sources. Also, property names are limited to 7 ASCII characters. Finally, the normal message properties object <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a9155c3d6d70b67c426089d53b3eacaac">lbm_msg_properties_t</a> and its APIs <em>are not used</em> on the sending side. Rather a streamlined method of specifying message properties for sending is used.</p>
<p>As with most of Smart Source's internal design, the message header for message properties must be pre-allocated with the maximum number of desired message properties. This is done at creation time for the Smart Source using the configuration option <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpsmartsource.html#smartsrcmessagepropertyintcountsource">smart_src_message_property_int_count (source)</a>.</p>
<p>Sending messages with message properties must be done using the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a2f50f56536778332e9f5712b06546425">lbm_ssrc_send_ex()</a> API, passing it the desired properties with the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a33886eeac2e67170effea009d2dc3a35">lbm_ssrc_send_ex_info_t</a> structure. The first call to send with message properties will serialize the supplied properties and encode them into the pre-allocated message header.</p>
<p>Subsequent calls to send with message properties will ignore the passed-in properties and simply re-send the previously-serialized header.</p>
<p>If an application needs to change the message property values after that initial send, the "update" flag flag can be used, which will trigger modification of the property values. This "update" flag cannot be used to change the number of properties, or the key names of the properties.</p>
<p>If an application needs messages with different numbers of properties and/or different key names of properties, the most efficient way to accomplish this is with multiple message buffers. Each buffer should be associated with a desired set of properties. When a message needs to be sent, the proper buffer is selected for building the message. This avoid the overhead of serializing the properties with each send call.</p>
<p>However, if the application requires dynamic construction of properties, a single buffer can be used along with the "rebuild" flag to trigger a full serialization of the properties.</p>
<dl class="section note"><dt>Note</dt><dd>If using both message properties and <a class="el" href="umobjects.html#spectrum">Spectrum</a> with a single Smart Source, there is an added restriction: it is not possible to send a message omitting only one of those features. I.e. if both are enabled when the Smart Source is created, it is not possible to send a message with a message property and not a channel, and it is not possible to send a message with a channel and not a property. This is because the message header is defined at Smart Source creation, and the header either must contain both or neither.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="smartsourcemessagepropertiesusage"></a>
Smart Source Message Properties Usage&nbsp;&nbsp;<small><a href="#smartsourcemessagepropertiesusage">&lt;-</a></small></h2>
<p>For a full example of message property usage with Smart Source, see <a href="../example/lbmssrc.c">lbmssrc.c</a> or <a href="../java_example/lbmssrc.java">lbmssrc.java</a>.</p>
<p>The first message with a message property sent to a Smart Source follows a specific sequence:</p>
<ol>
<li>
<p class="startli">Create the topic object with the configuration option <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpsmartsource.html#smartsrcmessagepropertyintcountsource">smart_src_message_property_int_count (source)</a> set to the maximum number of properties desired on a message.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Create the Smart Source with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a9a8d169a8c2a90b8442d4eb3e3711c9c">lbm_ssrc_create()</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Allocate one or more message buffers with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a98c5450e9fb93f30bd80fa33a2380dfc">lbm_ssrc_buff_get()</a>. You might allocate one for messages that have properties, and another for messages that don't.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">When preparing the first message with message properties to be sent, define the properties using a <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a33886eeac2e67170effea009d2dc3a35">lbm_ssrc_send_ex_info_t</a> structure: </p><pre class="fragment">  char *prop_name_array[3]; /* Array of property names. */
  prop_name_array[0] = "abc"; /* 7 ascii characters or less. */
  prop_name_array[1] = "XYZ";
  prop_name_array[2] = "123";

  lbm_int32_t prop_value_array[3]; /* Array of property values. */
  prop_value_array[0] = 29;
  prop_value_array[1] = -300;
  prop_value_array[2] = 0;

  lbm_ssrc_send_ex_info_t ss_send_info;
  memset((char *)&amp;ss_send_info, 0, sizeof(ss_send_info));
  ss_send_info.mprop_int_cnt = 3;
  ss_send_info.mprop_int_keys = prop_name_array;
  ss_send_info.mprop_int_vals = prop_value_array;
</pre><p class="endli"></p>
</li>
<li>
<p class="startli">Send the message using <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a2f50f56536778332e9f5712b06546425">lbm_ssrc_send_ex()</a> and the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#af00465b8e9c560959351ec92f62a190e">LBM_SSRC_SEND_EX_FLAG_PROPERTIES</a> flag: </p><pre class="fragment">  ss_send_info.flags = LBM_SSRC_SEND_EX_FLAG_PROPERTIES;
  err = lbm_ssrc_send_ex(ss, msg_buff, msg_size, 0, &amp;ss_send_info);
</pre><p class="endli">Since this is the first send with message properties, UM will serialize the properties and set up the message header. (It is not valid to set the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a40748fccf40f69c2029d68c16f923704">LBM_SSRC_SEND_EX_FLAG_UPDATE_PROPERTY_VALUES</a> flag on this first send with message properties.) </p>
</li>
</ol>
<p>For subsequent sends, there are different use cases: </p><ul>
<li>
<p class="startli">Send the message with the same properties and values. You can re-use the same message buffer and <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a33886eeac2e67170effea009d2dc3a35">lbm_ssrc_send_ex_info_t</a> structure: </p><pre class="fragment">  /* The ss_send_info.flags still has LBM_SSRC_SEND_EX_FLAG_PROPERTIES set */
  err = lbm_ssrc_send_ex(ss, msg_buff, msg_size, 0, &amp;ss_send_info);
</pre><p class="endli"></p>
</li>
<li>
<p class="startli">Send with message properties after having made changes to the property values (but not the keys or the number of properties) by setting the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a40748fccf40f69c2029d68c16f923704">LBM_SSRC_SEND_EX_FLAG_UPDATE_PROPERTY_VALUES</a> flag: </p><pre class="fragment">  prop_value_array[0] = 28;  /* Change property value. */
  ss_send_info.flags |= LBM_SSRC_SEND_EX_FLAG_UPDATE_PROPERTY_VALUES;
  err = lbm_ssrc_send_ex(ss, msg_buff, msg_size, 0, &amp;ss_send_info);
  ss_send_info.flags &amp;= ~LBM_SSRC_SEND_EX_FLAG_UPDATE_PROPERTY_VALUES;
</pre><p class="endli"></p>
</li>
<li>
<p class="startli">Send a message with either a different number of properties, and/or different key names by setting the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8e81e2661e6d2845790041d170864b1e">LBM_SSRC_SEND_EX_FLAG_REBUILD_BUFFER</a> flag: </p><pre class="fragment">  /* Send with only the first 2 properties. */
  ss_send_info.mprop_int_cnt = 2;
  ss_send_info.flags |= LBM_SSRC_SEND_EX_FLAG_REBUILD_BUFFER;
  err = lbm_ssrc_send_ex(ss, msg_buff, msg_size, 0, &amp;ss_send_info);
  ss_send_info.flags &amp;= ~ LBM_SSRC_SEND_EX_FLAG_REBUILD_BUFFER;
</pre><p class="endli"></p>
</li>
<li>
Send a message without any message properties. This is a subset of the previous case (changing the number of properties). Use the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8e81e2661e6d2845790041d170864b1e">LBM_SSRC_SEND_EX_FLAG_REBUILD_BUFFER</a> flag and clear the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#af00465b8e9c560959351ec92f62a190e">LBM_SSRC_SEND_EX_FLAG_PROPERTIES</a> flag: <pre class="fragment">  /* Clear the properties flag so no properties will be sent. */
  ss_send_info.flags &amp;= ~ LBM_SSRC_SEND_EX_FLAG_PROPERTIES;
  ss_send_info.flags |= LBM_SSRC_SEND_EX_FLAG_REBUILD_BUFFER;
  err = lbm_ssrc_send_ex(ss, msg_buff, msg_size, 0, &amp;ss_send_info);
  ss_send_info.flags &amp;= ~ LBM_SSRC_SEND_EX_FLAG_REBUILD_BUFFER;
</pre> </li>
</ul>
<p>To be more efficient, instead of using the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8e81e2661e6d2845790041d170864b1e">LBM_SSRC_SEND_EX_FLAG_REBUILD_BUFFER</a> flag, you can use different message buffers (allocated with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a98c5450e9fb93f30bd80fa33a2380dfc">lbm_ssrc_buff_get()</a>) for each message property structure. This saves the time required to re-serialize the message properties each time you want to use a different property structure.</p>
<p><br />
 </p>
<h1><a class="anchor" id="requestresponsemodel"></a>
Request/Response Model&nbsp;&nbsp;<small><a href="#requestresponsemodel">&lt;-</a></small></h1>
<p>Request/response is a very common messaging model whereby a client sends a "request" message to a server and expects a response. The server processes the request and return a response message to the originating client.</p>
<p>The UM request/response feature simplifies implementation of this model in the following ways: </p><ul>
<li>
Handling the request's "return address", eliminating the need for the client to create an artificial guaranteed-unique topic for the response. </li>
<li>
Establishing a linkage between a request and its response(s), allowing multiple requests to be outstanding, and associating each response message with its corresponding request message. </li>
<li>
Supporting multiple responses per request, both by allowing multiple servers to receive the request and each one responding, and by allowing a given server to respond with multiple messages. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="requestmessage"></a>
Request Message&nbsp;&nbsp;<small><a href="#requestmessage">&lt;-</a></small></h2>
<p>UM provides three ways to send a request message.</p>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ad4d06f66b8404684e191ca178e0cc09b">lbm_send_request()</a> to send a request to a topic via a source object. Uses the standard source-based transports (TCP, LBT-RM, LBT-RU). </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a54f3933e4dd154a9c7bb72598d0d9ef1">lbm_multicast_immediate_request()</a> to send a request to a topic as a multicast immediate message. See <a class="el" href="umfeatures.html#multicastimmediatemessaging">Multicast Immediate Messaging</a>. </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ae011c7a66e1db1f012d7f9633dbd321d">lbm_unicast_immediate_request()</a> to send a request to a topic as a unicast immediate message. </li>
</ul>
<p>When the client application sends a request message, it references an application callback function for responses and a client data pointer for application state. The send call returns a "request object". As one or more responses are returned, the callback is invoked to deliver the response messages, associated with the request's client data pointer. The requesting application decides when its request is satisfied (perhaps by completeness of a response, or by timeout), and it calls <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a0abaa1c2ba62bba7a5eaf1f7f2abbac0">lbm_request_delete()</a> to delete the request object. Even if the server chooses to send additional responses, they will not be delivered to the requesting application after it has deleted the corresponding request object.</p>
<p><br />
 </p>
<h2><a class="anchor" id="responsemessage"></a>
Response Message&nbsp;&nbsp;<small><a href="#responsemessage">&lt;-</a></small></h2>
<p>The server application receives a request via the normal message receive mechanism, but the message is identified as type "request". Contained within that request message's header is a response object, which serves as a return address to the requester. The server application responds to an UM request message by calling <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a0bbc01b600ccc2ae874474e35955eb85">lbm_send_response()</a>. The response message is sent unicast via a dynamic TCP connection managed by UM.</p>
<dl class="section warning"><dt>Warning</dt><dd>The <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a0bbc01b600ccc2ae874474e35955eb85">lbm_send_response()</a> function may not be called from a context thread callback. If the application needs to send the response from the receiver callback, it must associate that receiver callback with an <a class="el" href="fundamentalconcepts.html#eventqueueobject">event queue</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since the response object is part of the message header, it is normally deleted at the same time that the message is deleted, which typically happens automatically when the receiver callback returns. However, there are times when the application needs the scope of the response object to extend beyond the execution of the receiver callback. One method of extending the lifetime of the response object is to "retain" the request message, using <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a2b7788ff58f9e78bc89ea890dad0cccf">lbm_msg_retain()</a>. </dd></dl>
<dl class="section user"><dt></dt><dd>However, there are times when the size of the request message makes retention of the entire message undesirable. In those cases, the response object itself can be extracted and retained separately by saving a copy of the response object pointer and setting the message header's response pointer to NULL (to prevent UM from deleting the response object when the message is deleted). </dd></dl>
<dl class="section user"><dt></dt><dd>There are even occasions when an application needs to transfer the responsibility of responding to a request message to a different process entirely. I.e. the server which receives the request is not itself able to respond, and needs to send a message (not necessarily the original request message) to a different server. In that case, the first server which receives the request must serialize the response object to type <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a54cfbb23ab41a8d22968f68df015e246">lbm_serialized_response_t</a> by calling <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a7595677bf01cb9397d1fd174bd095e9f">lbm_serialize_response()</a>. It includes the serialized response object in the message forwarded to the second server. That server de-serializes the response object by calling <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ad74f47a1e021b2422b80c0bf8d03f7a9">lbm_deserialize_response()</a>, allowing it to send a response message to the original requesting client.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="tcpmanagement"></a>
TCP Management&nbsp;&nbsp;<small><a href="#tcpmanagement">&lt;-</a></small></h2>
<p>UM creates and manages the special TCP connections for responses, maintaining a list of active response connections. When an application sends a response, UM scans that list for an active connection to the destination. If it doesn't find a connection for the response, it creates a new connection and adds it to the list. After the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a0bbc01b600ccc2ae874474e35955eb85">lbm_send_response()</a> function returns, UM schedules the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpunicastimmediatemessagingoperation.html#responsetcpdeletiontimeoutcontext">response_tcp_deletion_timeout (context)</a>, which defaults to 2 seconds. If a second request comes in from the same application before the timer expires, the responding application simply uses the existing connection and restarts the deletion timer.</p>
<p>It is conceivable that a very large response could take more than the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpunicastimmediatemessagingoperation.html#responsetcpdeletiontimeoutcontext">response_tcp_deletion_timeout (context)</a> default (2 seconds) to send to a slow-running receiver. In this case, UM automatically increases the deletion timer as needed to ensure the last message completes.</p>
<p><br />
 </p>
<h2><a class="anchor" id="requestresponseconfiguration"></a>
Request/Response Configuration&nbsp;&nbsp;<small><a href="#requestresponseconfiguration">&lt;-</a></small></h2>
<p>See the <a href="../Config/index.html">UM Configuration Guide</a> for the descriptions of the Request/Response configuration options:</p>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpunicastimmediatemessagingnetwork.html">Unicast Immediate Messaging Network Options</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpunicastimmediatemessagingoperation.html">Unicast Immediate Messaging Operation Options</a> </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>If your application is running within an UM context where the configuration option, <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpunicastimmediatemessagingnetwork.html#requesttcpbindrequestportcontext">request_tcp_bind_request_port (context)</a> has been set to zero, UIM port binding has been turned off, which also disables the Request/Response feature.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="requestresponseexampleapplications"></a>
Request/Response Example Applications&nbsp;&nbsp;<small><a href="#requestresponseexampleapplications">&lt;-</a></small></h2>
<p>UM includes two example applications that illustrate Request/Response.</p>
<ul>
<li>
<a href="../example/lbmreq.c">lbmreq.c</a> - application that sends requests on a given topic (single source) and waits for responses. See also the Java example, <a href="../java_example/lbmreq.java">lbmreq.java</a> and the .NET example, <a href="../dotnet_example/lbmreq.cs">lbmreq.cs</a>. </li>
<li>
<a href="../example/lbmresp.c">lbmresp.c</a> - application that waits for requests and sends responses back on a given topic (single receiver). See also the Java example, <a href="../java_example/lbmresp.java">lbmresp.java</a> and the .NET example, <a href="../dotnet_example/lbmresp.cs">lbmresp.cs</a>. </li>
</ul>
<p>We can demonstrate a series of 5 requests and responses with the following procedure:</p>
<ul>
<li>
Run <b>lbmresp -v topicname</b> </li>
<li>
Run <b>lbmreq -R 5 -v topicname</b> </li>
</ul>
<p><b>LBMREQ</b></p>
<p>Output for lbmreq should resemble the following:</p>
<pre class="fragment">$ lbmreq -R 5 -q topicname
Event queue in use
Using TCP port 4392 for responses
Delaying requests for 1000 milliseconds
Sending request 0
Starting event pump for 5 seconds.
Receiver connect [TCP:10.29.1.78:4958]
Done waiting for responses. 1 responses (25 bytes) received. Deleting request. Sending request 1
Starting event pump for 5 seconds.
Done waiting for responses. 1 responses (25 bytes) received. Deleting request. Sending request 2
Starting event pump for 5 seconds.
Done waiting for responses. 1 responses (25 bytes) received. Deleting request. Sending request 3
Starting event pump for 5 seconds.
Done waiting for responses. 1 responses (25 bytes) received. Deleting request. Sending request 4
Starting event pump for 5 seconds.
Done waiting for responses. 1 responses (25 bytes) received. Deleting request.
Quitting...
</pre><p><b>LBMRESP</b></p>
<p>Output for lbmresp should resemble the following:</p>
<pre class="fragment">$ lbmresp -v topicname
Request [topicname][TCP:10.29.1.78:14371][0], 25 bytes
Sending response. 1 responses of 25 bytes each (25 total bytes).
Done sending responses. Deleting response.
Request [topicname][TCP:10.29.1.78:14371][1], 25 bytes
Sending response. 1 responses of 25 bytes each (25 total bytes).
Done sending responses. Deleting response.
Request [topicname][TCP:10.29.1.78:14371][2], 25 bytes
Sending response. 1 responses of 25 bytes each (25 total bytes).
Done sending responses. Deleting response.
Request [topicname][TCP:10.29.1.78:14371][3], 25 bytes
Sending response. 1 responses of 25 bytes each (25 total bytes).
Done sending responses. Deleting response.
Request [topicname][TCP:10.29.1.78:14371][4], 25 bytes
Sending response. 1 responses of 25 bytes each (25 total bytes).
Done sending responses. Deleting response.
[topicname][TCP:10.29.1.78:14371], End of Transport Session
</pre><p><br />
 </p>
<h1><a class="anchor" id="selfdescribingmessaging"></a>
Self Describing Messaging&nbsp;&nbsp;<small><a href="#selfdescribingmessaging">&lt;-</a></small></h1>
<p>The UM Self-Describing Messaging (SDM) feature provides an API that simplifies the creation and use of messages by your applications. An SDM message contains one or more fields and each field consists of the following:</p>
<ul>
<li>
A name </li>
<li>
A type </li>
<li>
A value </li>
</ul>
<p>Each named field may appear only once in a message. If multiple fields of the same name and type are needed, array fields are available. A field in a nested message may have the same name as a field in the outer message.</p>
<p>SDM is particularly helpful for creating messages sent across platforms by simplifying the creation of data formats. SDM automatically performs platform-specific data translations, eliminating endian conflicts.</p>
<p>Using SDM also simplifies message maintenance because the message format or structure can be independent of the source and receiver applications. For example, if your receivers query SDM messages for particular fields and ignore the order of the fields within the message, a source can change the field order if necessary with no modification of the receivers needed.</p>
<p>See the C, Java, and .NET API guides for details.</p>
<p><br />
 </p>
<h1><a class="anchor" id="predefinedmessages"></a>
Pre-Defined Messages&nbsp;&nbsp;<small><a href="#predefinedmessages">&lt;-</a></small></h1>
<p>The UM Pre-Defined Messages (PDM) feature provides an API similar to the SDM API, but allows you to define messages once and then use the definition to create messages that may contain self-describing data. Eliminating the need to repeatedly send a message definition increases the speed of PDM over SDM. The ability to use arrays created in a different programming language also improves performance.</p>
<p>The PDM library lets you create, serialize, and deserialize messages using pre-defined knowledge about the possible fields that may be used. You can create a definition that a) describes the fields to be sent and received in a message, b) creates the corresponding message, and c) adds field values to the message. This approach offers several performance advantages over SDM, as the definition is known in advance. However, the usage pattern is slightly different than the SDM library, where fields are added directly to a message without any type of definition.</p>
<p>A PDM message contains one or more fields and each field consists of the following:</p>
<ul>
<li>
A name </li>
<li>
A type </li>
<li>
A value </li>
</ul>
<p>Each named field may appear only once in a message. If multiple fields of the same name and type are needed, array fields are available. A field in a nested message may have the same name as a field in the outer message.</p>
<p>See the C, Java, and .NET Application Programmer's Interfaces for complete references of PDM functions, field types and message field operations. The C API also has information and code samples about how to create definitions and messages, set field values in a message, set the value of array fields in a message, serialize, deserialize and dispose of messages, and fetch values from a message.</p>
<p><br />
 </p>
<h2><a class="anchor" id="typicalpdmusagepatterns"></a>
Typical PDM Usage Patterns&nbsp;&nbsp;<small><a href="#typicalpdmusagepatterns">&lt;-</a></small></h2>
<p>The typical PDM usage patterns can usually be broken down into two categories: sources (which need to serialize a message for sending) and receivers (which need to deserialize a message to extract field values). However, for optimum performance for both sources and receivers, first set up the definition and a single instance of the message only once during a setup or initialization phase, as in the following example workflow:</p>
<ol>
<li>
Create a definition and set its id and version. </li>
<li>
Add field information to the definition to describe the types of fields to be in the message. </li>
<li>
Create a single instance of a message based on the definition. </li>
<li>
Set up a source to do the following: <ul>
<li>
Add field values to the message instance. </li>
<li>
Serialize the message so that it can be sent. </li>
</ul>
</li>
<li>
Likewise, set up a receiver to do the following: <ul>
<li>
Deserialize the received bytes into the message instance. </li>
<li>
Extract the field values from the message. </li>
</ul>
</li>
</ol>
<p><br />
 </p>
<h2><a class="anchor" id="gettingstartedwithpdm"></a>
Getting Started with PDM&nbsp;&nbsp;<small><a href="#gettingstartedwithpdm">&lt;-</a></small></h2>
<p>PDM APIs are provided in C, Java, and C#, however, the examples in this section are Java based.</p>
<p><b>PDM Code Example, Source</b></p>
<p>Translating the Typical PDM Usage Patterns to Java for a source produces the following:</p>
<pre class="fragment">private PDMDefinition defn;
private PDMMessage msg;
private PDMFieldInfo fldInfo100;
private PDMFieldInfo fldInfo101;
private PDMFieldInfo fldInfo102;

public void setupPDM() {
  //Create the definition with 3 fields and using int field names
  defn = new PDMDefinition(3, true);

  //Set the definition id and version
  defn.setId(1001);
  defn.setMsgVersMajor((byte)1);
  defn.setMsgVersMinor((byte)0);

  //Create information for a boolean, int32, and float fields (all required)
  fldInfo100 = defn.addFieldInfo(100, PDMFieldType.BOOLEAN, true);
  fldInfo101 = defn.addFieldInfo(101, PDMFieldType.INT32, true);
  fldInfo102 = defn.addFieldInfo(102, PDMFieldType.FLOAT, true);

  //Finalize the definition and create the message defn.finalizeDef();
  msg = new PDMMessage(defn);
}

public void sourceUsePDM() {
  //Call the function to setup the definition and message
  setupPDM();

  //Example values for the message boolean
  fld100Val = true;
  int fld101Val = 7;
  float fld102Val = 3.14F;

  //Set each field value in the message
  msg.setFieldValue(fldInfo100, fld100Val);
  msg.setFieldValue(fldInfo101, fld101Val);
  msg.setFieldValue(fldInfo102, fld102Val);

  //Serialize the message to bytes
  byte[] buffer = msg.toBytes();
}
</pre><p><b>PDM Code Example, Receiver</b></p>
<p>Translating the Typical PDM Usage Patterns to Java for a receiver produces the following:</p>
<pre class="fragment">private PDMDefinition defn;
private PDMMessage msg;
private PDMFieldInfo fldInfo100;
private PDMFieldInfo fldInfo101;
private PDMFieldInfo fldInfo102;

public void setupPDM() {
  //Create the definition with 3 fields and using int field names
  defn = new PDMDefinition(3, true);

  //Set the definition id and version
  defn.setId(1001);
  defn.setMsgVersMajor((byte)1);
  defn.setMsgVersMinor((byte)0);

  //Create information for a boolean, int32, and float field (all required)
  fldInfo100 = defn.addFieldInfo(100, PDMFieldType.BOOLEAN, true);
  fldInfo101 = defn.addFieldInfo(101, PDMFieldType.INT32, true);
  fldInfo102 = defn.addFieldInfo(102, PDMFieldType.FLOAT, true);

  //Finalize the definition and create the message
  defn.finalizeDef();
  msg = new PDMMessage(defn);
}

public void receiverUsePDM(byte[] buffer) {
  //Call the function to setup the definition and message
  setupPDM();

  //Values to be retrieved from the message
  boolean fld100Val;
  int fld101Val;
  float fld102Val;

  //Deserialize the bytes into a message
  msg.parse(buffer);

  //Get each field value from the message
  fld100Val = msg.getFieldValueAsBoolean(fldInfo100);
  fld101Val = msg.getFieldValueAsInt32(fldInfo101);
  fld102Val = msg.getFieldValueAsFloat(fldInfo102);
}
</pre><p><b>PDM Code Example Notes</b></p>
<p>In the examples above, the setupPDM() function is called once to set up the PDM definition and message. It is identical in both the source and receiver cases and simply sets up a definition that contains three required fields with integer names (100, 101, 102). Once finalized, it can create a message that leverages its pre-defined knowledge about these three required fields. The source example adds the three sample field values (a boolean, int32, and float) to the message, which is then serialized to a byte array. In the receiver example, the message parses a byte array into the message and then extracts the three field values.</p>
<p><br />
 </p>
<h2><a class="anchor" id="usingthepdmapi"></a>
Using the PDM API&nbsp;&nbsp;<small><a href="#usingthepdmapi">&lt;-</a></small></h2>
<p>The following code snippets expand upon the previous examples to demonstrate the usage of additional PDM functionality (but use "..." to eliminate redundant code).</p>
<p><b>Reusing the Message Object</b></p>
<p>Although the examples use a single message object (which provides performance benefits due to reduced message creation and garbage collection), it is not explicitly required to reuse a single instance. However, multiple threads should not access a single message instance.</p>
<p><b>Number of Fields</b></p>
<p>Although the number of fields above is initially set to 3 in the PDMDefinition constructor, if you add more fields to the definition with the addFieldInfo method, the definition grows to accommodate each field. Once the definition is finalized, you cannot add additional field information because the definition is now locked and ready for use in a message.</p>
<p><b>String Field Names</b></p>
<p>The examples above use integer field names in the setupPDM() function when creating the definition. You can also use string field names when setting up the definition. However, you still must use a FieldInfo object to set or get a field value from a message, regardless of field name type. Notice that false is passed to the PDMDefinition constructor to indicate string field names should be used. Also, the overloaded addFieldInfo function uses string field names (.Field100.) instead of the integer field names.</p>
<pre class="fragment">...
public void setupPDM() {
  //Create the definition with 3 fields and using string field names
  defn = new PDMDefinition(3, false);
  ...
  //Create information for a boolean, int32, and float field (all required)
  fldInfo100 = defn.addFieldInfo("Field100", PDMFieldType.BOOLEAN, true);
  fldInfo101 = defn.addFieldInfo("Field101", PDMFieldType.INT32, true);
  fldInfo102 = defn.addFieldInfo("Field102", PDMFieldType.FLOAT, true);
  ...
}
...
</pre><p><b>Retrieving FieldInfo from the Definition</b></p>
<p>At times, it may be easier to lookup the FieldInfo from the definition using the integer name (or string name if used). This eliminates the need to store the reference to the FieldInfo when getting or setting a field value in a message, but it does incur a performance penalty due to the lookup in the definition to retrieve the FieldInfo. Notice that there are no longer FieldInfo objects being used when calling addFieldInfo and a lookup is being done for each call to msg.getFieldValueAs* to retrieve the FieldInfo by integer name.</p>
<pre class="fragment">private PDMDefinition defn;
private PDMMessage msg;

public void setupPDM() {
  ...
  //Create information for a boolean, int32, and float field (all required)
  defn.addFieldInfo(100, PDMFieldType.BOOLEAN, true);
  defn.addFieldInfo(101, PDMFieldType.INT32, true);
  defn.addFieldInfo(102, PDMFieldType.FLOAT, true);
  ...
}

public void receiverUsePDM(byte[] buffer) {
  ...
  //Get each field value from the message
  fld100Val = msg.getFieldValueAsBoolean(defn.getFieldInfo(100));
  fld101Val = msg.getFieldValueAsInt32(defn.getFieldInfo(101));
  fld102Val = msg.getFieldValueAsFloat(defn.getFieldInfo(102));
}
</pre><p><b>Required and Optional Fields</b></p>
<p>When adding field information to a definition, you can indicate that the field is optional and may not be set for every message that uses the definition. Do this by passing false as the third parameter to the addFieldInfo function. Using required fields (fixed-required fields specifically) produces the best performance when serializing and deserializing messages, but causes an exception if all required fields are not set before serializing the message. Optional fields allow the concept of sending "null" as a value for a field by simply not setting that field value on the source side before serializing the message. However, after parsing a message, a receiver should check the isFieldValueSet function for an optional field before attempting to read the value from the field to avoid the exception mentioned above.</p>
<pre class="fragment">...
private PDMFieldInfo fldInfo103;
...
public void setupPDM() {
  ...
  //Create information for a boolean, int32, and float field (all required)
  // as well as an optional int8 field
  fldInfo100 = defn.addFieldInfo(100, PDMFieldType.BOOLEAN, true);
  fldInfo101 = defn.addFieldInfo(101, PDMFieldType.INT32, true);
  fldInfo102 = defn.addFieldInfo(102, PDMFieldType.FLOAT, true);
  fldInfo103 = defn.addFieldInfo(103, PDMFieldType.INT8, false);
  ...
}

public void sourceUsePDM() {
  ...
  //Set each field value in the message
  // except do not set the optional field
  msg.setFieldValue(fldInfo100, fld100Val);
  msg.setFieldValue(fldInfo101, fld101Val);
  msg.setFieldValue(fldInfo102, fld102Val);
  ...
}

...
private PDMFieldInfo fldInfo103;
...
public void setupPDM() {
  ...
  //Create information for a boolean, int32, and float field (all required)
  // as well as an optional int8 field
  fldInfo103 = defn.addFieldInfo(103, PDMFieldType.INT8, false);
  ...
}

public void receiverUsePDM(byte[] buffer) {
  ...
  byte fld103Val;
  ...
  if(msg.isFieldValueSet(fldInfo103)) {
    fld103Val = msg.getFieldValueAsInt8(fldInfo103);
  }
}
</pre><p><b>Fixed String and Fixed Unicode Field Types</b></p>
<p>A variable length string typically does not have the performance optimizations of fixed-required fields. However, by indicating "required", as well as the field type FIX_STRING or FIX_UNICODE and specifying an integer number of fixed characters, PDM sets aside an appropriate fixed amount of space in the message for that field and treats it as an optimized fixed-required field. Strings of a smaller length can still be set as the value for the field, but the message allocates the specified fixed number of bytes for the string. Specify Unicode strings in the same manner (with FIX_UNICODE as the type) and in "UTF-8" format.</p>
<pre class="fragment">...
private PDMFieldInfo fldInfo104;
...
public void setupPDM() {
  ...
  fldInfo104 = defn.addFieldInfo(104, PDMFieldType.FIX_STRING, 12, true);
  ...
}

public void sourceUsePDM() {
  ...
  String fld104Val = "Hello World!";

  //Set each field value in the message
  // except do not set the optional field
  msg.setFieldValue(fldInfo100, fld100Val);
  msg.setFieldValue(fldInfo101, fld101Val);
  msg.setFieldValue(fldInfo102, fld102Val);
  msg.setFieldValue(fldInfo104, fld104Val);
  ...
}

...
private PDMFieldInfo fldInfo104;
...
public void setupPDM() {
  ...
  fldInfo104 = defn.addFieldInfo(104, PDMFieldType.FIX_STRING, 12, true);
  ...
}
public void receiverUsePDM(byte[] buffer) {
  ...
  String fld104Val;
  ...

  fld104Val = msg.getFieldValueAsString(fldInfo104);
}
</pre><p><b>Variable Field Types</b></p>
<p>The field types of STRING, UNICODE, BLOB, and MESSAGE are all variable length field types. They do not require a length to be specified when adding field info to the definition. You can use a BLOB field to store an arbitrary binary objects (in Java as an array of bytes) and a MESSAGE field to store a PDMMessage object,</p>
<p>which enables "nesting" PDMMessages inside other PDMMessages. Creating and using a variable length string field is nearly identical to the previous fixed string example.</p>
<pre class="fragment">...
private PDMFieldInfo fldInfo105;
...
public void setupPDM() {
  ...
  fldInfo105 = defn.addFieldInfo(105, PDMFieldType.STRING, true);
  ...
}

public void sourceUsePDM() {
  ...
  String fld105Val = "variable length value";
  ...
  msg.setFieldValue(fldInfo105, fld105Val);
  ...
}

...
private PDMFieldInfo fldInfo105;
...
public void setupPDM() {
  ...
  fldInfo105 = defn.addFieldInfo(105, PDMFieldType.STRING, true);
  ...
}
public void receiverUsePDM(byte[] buffer) {
  ...
  String fld105Val;
  ...

  fld105Val = msg.getFieldValueAsString(fldInfo105);
}
</pre><p>Retrieve the BLOB field values with the getFieldValueAsBlob function, and the MESSAGE field values with the getFieldValueAsMessage function.</p>
<p><b>Array Field Types</b></p>
<p>For each of the scalar field types (fixed and variable length), a corresponding array field type uses the convention *_ARR for the type name (ex: BOOLEAN_ARR, INT32_ARR, STRING_ARR, etc.). This lets you set and get Java values such as an int[] or string[] directly into a single field. In addition, all of the array field types can specify a fixed number of elements for the size of the array when they are defined, or if not specified, behave as variable size arrays. Do this by passing an extra parameter to the addFieldInfo function of the definition.</p>
<p>To be treated as a fixed-required field, an array type field must be required as well as be specified as a fixed size array of fixed length elements. For instance, a required BOOLEAN_ARR field defined with a size of 3 would be treated as a fixed-required field. Also, a required FIX_STRING_ARR field defined with a size of 5 and fixed string length of 7 would be treated as a fixed-required field. However, neither a STRING_ARR field nor a BLOB_ARR field are treated as a fixed length field even if the size of the array is specified, since each element of the array can be variable in length. In the example below, field 106 and field 108 are both treated as fixed-required fields, but field 107 is not because it is a variable size array field type.</p>
<pre class="fragment">...
private PDMFieldInfo fldInfo106;
private PDMFieldInfo fldInfo107;
private PDMFieldInfo fldInfo108;
...

public void setupPDM() {
  ...
  //Create information for a boolean, int32, and float field (all required)
  // as well as an optional int8 field
  ...
  //A required, fixed size array of 3 boolean elements
  fldInfo106 = defn.addFieldInfo(106, PDMFieldType.BOOLEAN_ARR, true, 3);
  //An optional, variable size array of int32 elements
  fldInfo107 = defn.addFieldInfo(107, PDMFieldType.INT32_ARR, false);
  //A required, fixed size array of 2 element which are each 5 character strings
  fldInfo108 = defn.addFieldInfo(108, PDMFieldType.FIX_STRING_ARR, 5, true, 2);
  ...
}

public void sourceUsePDM() {
  ...
  //Example values for the message
  ...
  boolean fld106Val[] = {true, false, true};
  int fld107Val[] = {1, 2, 3, 4, 5};
  String fld108Val[] = {"aaaaa", "bbbbb"};

  //Set each field value in the message
  ...
  msg.setFieldValue(fldInfo106, fld106Val);
  msg.setFieldValue(fldInfo107, fld107Val);
  msg.setFieldValue(fldInfo108, fld108Val);
  ...
}

...
private PDMFieldInfo fldInfo106;
private PDMFieldInfo fldInfo107;
private PDMFieldInfo fldInfo108;
...
public void setupPDM() {
  ...
  //Create information for a boolean, int32, and float field (all required)
  // as well as an optional int8 field
  ...
  //A required, fixed size array of 3 boolean elements
  fldInfo106 = defn.addFieldInfo(106, PDMFieldType.BOOLEAN_ARR, true, 3);
  //An optional, variable size array of int32 elements
  fldInfo107 = defn.addFieldInfo(107, PDMFieldType.INT32_ARR, false);
  //A required, fixed size array of 2 element which are each 5 character strings
  fldInfo108 = defn.addFieldInfo(108, PDMFieldType.FIX_STRING_ARR, 5, true, 2);
  ...
}

public void receiverUsePDM(byte[] buffer) {
  ...
  //Values to be retrieved from the message
  ...
  boolean fld106Val[];
  int fld107Val[];
  String fld108Val[];

  //Deserialize the bytes into a message
  msg.parse(buffer);

  //Get each field value from the message
  ...
  fld106Val = msg.getFieldValueAsBooleanArray(fldInfo106);
  if(msg.isFieldValueSet(fldInfo107)) {
    fld107Val = msg.getFieldValueAsInt32Array(fldInfo107);
  }

  fld108Val = msg.getFieldValueAsStringArray(fldInfo108);
}
</pre><p><b>Definition Included In Message</b></p>
<p>Optionally, a PDM message can also include the definition when it is serialized to bytes. This enables receivers to parse a PDM message without having pre-defined knowledge of the message, although including the definition with the message affects message size and performance of message deserialization. Notice that the setIncludeDefinition function is called with an argument of true for a source that serializes the definition as part of the message.</p>
<pre class="fragment">private PDMDefinition defn;
private PDMMessage msg;

public void setupPDM() {
  //Create the definition with 3 fields and using int field names
  defn = new PDMDefinition(3, true);
  ...

  //Finalize the definition and create the message
  defn.finalizeDef();
  msg = new PDMMessage(defn);

  //Set the flag to indicate that the definition should also be serialized
  msg.setIncludeDefinition(true);
}
...
</pre><p>For a receiver, the setupPDM function does not need to set any flags for the message but rather should define a message without a definition, since we assume the source provides the definition. If a definition is set for a message, it will attempt to use that definition instead of the definition on the incoming message (unless the ids are different).</p>
<pre class="fragment">private PDMDefinition defn;
private PDMMessage msg;

public void setupPDM() {
  //Don't define a definition

  //Create a message without a definition since the incoming message will have it
  msg = new PDMMessage();
}
...
</pre><p><b>The PDM Field Iterator</b></p>
<p>You can use the PDM Field Iterator to check all defined message fields to see if set, or to extract their values. You can extract a field value as an Object using this method, but due to the casting involved, we recommend you use the type specific get method to extract the exact value. Notice the use of field.isValueSet to check to see if the field value is set and the type specific get methods such as getBooleanValue and getFloatValue.</p>
<pre class="fragment">...

public void setupPDM() {
  //Create the definition with 3 fields and using int field names
  defn = new PDMDefinition(3, true);

  //Set the definition id and version
  defn.setId(1001);
  defn.setMsgVersMajor((byte)1);
  defn.setMsgVersMinor((byte)0);

  //Create information for a boolean, int32, and float field (all required)
  // as well as an optional int8 field
  fldInfo100 = defn.addFieldInfo(100, PDMFieldType.BOOLEAN, true);
  fldInfo101 = defn.addFieldInfo(101, PDMFieldType.INT32, true);
  fldInfo102 = defn.addFieldInfo(102, PDMFieldType.FLOAT, true);
  fldInfo103 = defn.addFieldInfo(103, PDMFieldType.INT8, false);
  fldInfo104 = defn.addFieldInfo(104, PDMFieldType.FIX_STRING, 12, true);
  fldInfo105 = defn.addFieldInfo(105, PDMFieldType.STRING, true);
  //A required, fixed size array of 3 boolean elements
  fldInfo106 = defn.addFieldInfo(106, PDMFieldType.BOOLEAN_ARR, true, 3);
  //An optional, variable size array of int32 elements
  fldInfo107 = defn.addFieldInfo(107, PDMFieldType.INT32_ARR, false);
  //A required, fixed size array of 2 element which are each 5 character strings
  fldInfo108 = defn.addFieldInfo(108, PDMFieldType.FIX_STRING_ARR, 5, true, 2);

  //Finalize the definition and create the message
  defn.finalizeDef();
  msg = new PDMMessage(defn);
}

public void receiveAndIterateMessage(byte[] buffer) {
  msg.parse(buffer);
  PDMFieldIterator iterator = msg.createFieldIterator();
  PDMField field = null;
  while(iterator.hasNext()) {
    field = iterator.next();
    System.out.println("Field set? " +field.isValueSet());
    switch(field.getIntName()) {
      case 100:
        boolean val100 = field.getBooleanValue();
        System.out.println("Field 100's value is: " + val100);
        break;
      case 101:
        int val101 = field.getInt32Value();
        System.out.println("Field 101's value is: " + val101);
        break;
      case 102:
        float val102 = field.getFloatValue();
        System.out.println("Field 102's value is: " + val102);
        break;
      default:
        //Casting to object is possible but not recommended
        Object value = field.getValue();
        int name = field.getIntName();
        System.out.println("Field " + name + "'s value is: " + value);
        break;
    }
  }
}
</pre><p>Sample Output (106, 107, 108 are array objects as expected):</p>
<pre class="fragment">Field set? true
Field 100's value is: true
Field set? true
Field 101's value is: 7
Field set? true
Field 102's value is: 3.14
Field set? false
Field 103's value is: null
Field set? true
Field 104's value is: Hello World!
Field set? true
Field 105's value is: Variable
Field set? true
Field 106's value is: [Z@527736bd
Field set? true
Field 107's value is: [I@10aadc97
Field set? true
Field 108's value is: [Ljava.lang.String;@4178460d
</pre><p><b>Using the Definition Cache</b></p>
<p>The PDM Definition Cache assists with storing and looking up definitions by their id and version. In some scenarios, it may not be desirable to maintain the references to the message and the definition from a setup phase by the application. A source could optionally create the definition during the setup phase and store it in the definition cache. At a later point in time, it could retrieve the definition from the cache and use it to create the message without needing to maintain any references to the objects.</p>
<pre class="fragment">public void createAndStoreDefinition() {
  PDMDefinition myDefn = new PDMDefinition(3, true);
  //Set the definition id and version
  myDefn.setId(2001);
  myDefn.setMsgVersMajor((byte)1);
  myDefn.setMsgVersMinor((byte)0);

  //Create information for a boolean, int32, and float field (all required)
  myDefn.addFieldInfo(100, PDMFieldType.BOOLEAN, true);
  myDefn.addFieldInfo(101, PDMFieldType.INT32, true);
  myDefn.addFieldInfo(102, PDMFieldType.FLOAT, true);

  myDefn.finalizeDef();

  PDMDefinitionCache.getInstance().put(myDefn);
}

public void createMessageUsingCache() {
  PDMDefinition myFoundDefn = PDMDefinitionCache.getInstance().get(2001, 1, 0);
  if(myFoundDefn != null) {
    PDMMessage myMsg = new PDMMessage(myFoundDefn);
    //Get FieldInfo from defn and then set field values in myMsg
    //...
  }
}
</pre><p>A more advanced use of the PDM Definition Cache is by a receiver which may need to receive messages with different definitions and the definitions are not being included with the messages. The receiver can create the definitions in advance and then set a flag that allows automatic lookup into the definition cache when parsing a message (which is not on by default). Before receiving messages, the receiver should do something similar to createAndStoreDefinition (shown below) to set up definitions and put them in the definition cache. Then the flag to allow automatic lookup should be set as shown below in the call to setTryToLoadDefFromCache(true). This allows the PDMMessage to be created without a definition and still successfully parse a message by leveraging the definition cache.</p>
<pre class="fragment">public void createAndStoreDefinition() {
  PDMDefinition myDefn = new PDMDefinition(3, true);
  //Set the definition id and version
  myDefn.setId(2001);
  myDefn.setMsgVersMajor((byte)1);
  myDefn.setMsgVersMinor((byte)0);

  //Create information for a boolean, int32, and float field (all required)
  myDefn.addFieldInfo(100, PDMFieldType.BOOLEAN, true);
  myDefn.addFieldInfo(101, PDMFieldType.INT32, true);
  myDefn.addFieldInfo(102, PDMFieldType.FLOAT, true);

  myDefn.finalizeDef();
  PDMDefinitionCache.getInstance().put(myDefn);

  //Create and store other definitions
  //...
}

public void receiveKnownMessages(byte[] buffer) {
  PDMMessage myMsg = new PDMMessage();
  //Set the flag that enables messages to try
  // looking up the definition in the cache automatically
  // when parsing a byte buffer
  myMsg.setTryToLoadDefFromCache(true);
  myMsg.parse(buffer);

  if (myMsg.getDefinition().getId() == 2001
      &amp;&amp; myMsg.getDefinition().getMsgVersMajor() == 1
      &amp;&amp; myMsg.getDefinition().getMsgVersMinor() == 0) {
    PDMDefinition myDefn = PDMDefinitionCache.getInstance().get(2001, 1, 0);
    PDMFieldInfo fldInfo100 = myDefn.getFieldInfo(100);
    PDMFieldInfo fldInfo101 = myDefn.getFieldInfo(101);
    PDMFieldInfo fldInfo102 = myDefn.getFieldInfo(102);

    boolean fld100Val;
    int fld101Val;
    float fld102Val;

    //Get each field value from the message
    fld100Val = myMsg.getFieldValueAsBoolean(fldInfo100);
    fld101Val = myMsg.getFieldValueAsInt32(fldInfo101);
    fld102Val = myMsg.getFieldValueAsFloat(fldInfo102);

    System.out.println(fld100Val + " " + fld101Val + " " + fld102Val);
  }
}
</pre><p><br />
 </p>
<h2><a class="anchor" id="migratingfromsdm"></a>
Migrating from SDM&nbsp;&nbsp;<small><a href="#migratingfromsdm">&lt;-</a></small></h2>
<p>Applications using SDM with a known set of message fields are good candidates for migrating from SDM to PDM. With SDM, the source typically adds fields to an SDM message without a definition. But, as shown above in the PDM examples, creating/adding a PDM definition before adding field values is fairly straightforward.</p>
<p>However, certain applications may be incapable of building a definition in advance due to the ad-hoc nature of their messaging needs, in which case a self-describing format like SDM may be preferred.</p>
<p><b>Simple Migration Example</b></p>
<p>The following source code shows a basic application that serializes and deserializes three fields using SDM and PDM. The setup method in both cases initializes the object instances so they can be reused by the source and receiver methods.</p>
<p>The goal of the sourceCreateMessageWith functions is to produce a byte array by setting field values in a message object. With SDM, actual Field classes are created, values are set, the Field classes are added to a</p>
<p>Fields class, and then the Fields class is added to the SDMessage. With PDM, FieldInfo objects are created during the setup phase and then used to set specific values in the PDMMessage.</p>
<p>The goal of the receiverParseMessageWith functions is to produce a message object by parsing the byte array and then extract the field values from the message. With SDM, the specific field is located and casted to the correct field class before getting the field value. With PDM, the appropriate getFieldValueAs function is called with the corresponding FieldInfo object created during the setup phase to extract the field value.</p>
<pre class="fragment">public class Migration {
  //SDM Variables
  private LBMSDMessage srcSDMMsg;
  private LBMSDMessage rcvSDMMsg;

  //PDM Variables
  private PDMDefinition defn;
  private PDMFieldInfo fldInfo100;
  private PDMFieldInfo fldInfo101;
  private PDMFieldInfo fldInfo102;
  private PDMMessage srcPDMMsg;
  private PDMMessage rcvPDMMsg;

  public static void main(String[] args) {
    Migration app = new Migration();
    System.out.println("Setting up PDM Definition and Message");
    app.setupPDM();
    System.out.println("Setting up SDM Messages");
    app.setupSDM();

    byte[] sdmBuffer;
    sdmBuffer = app.sourceCreateMessageWithSDM();
    app.receiverParseMessageWithSDM(sdmBuffer);

    byte[] pdmBuffer;
    pdmBuffer = app.sourceCreateMessageWithPDM();
    app.receiverParseMessageWithPDM(pdmBuffer);
  }

  public void setupSDM() {
    rcvSDMMsg = new LBMSDMessage();
    srcSDMMsg = new LBMSDMessage();
  }

  public void setupPDM() {
    //Create the definition with 3 fields and using int field names
    defn = new PDMDefinition(3, false);

    //Set the definition id and version
    defn.setId(1001);
    defn.setMsgVersMajor((byte)1);
    defn.setMsgVersMinor((byte)0);

    //Create information for a boolean, int32, and float field (all required)
    // as well as an optional int8 field
    fldInfo100 = defn.addFieldInfo("Field100", PDMFieldType.INT8, true);
    fldInfo101 = defn.addFieldInfo("Field101", PDMFieldType.INT16, true);
    fldInfo102 = defn.addFieldInfo("Field102", PDMFieldType.INT32, true);

    //Finalize the definition and create the message defn.finalizeDef();
    srcPDMMsg = new PDMMessage(defn);
    rcvPDMMsg = new PDMMessage(defn);
  }

  public byte[] sourceCreateMessageWithSDM() {
    byte[] buffer = null;

    LBMSDMField fld100 = new LBMSDMFieldInt8("Field100", (byte)0x42);
    LBMSDMField fld101 = new LBMSDMFieldInt16("Field101", (short)0x1ead);
    LBMSDMField fld102 = new LBMSDMFieldInt32("Field102", 12345);
    LBMSDMFields fset = new LBMSDMFields();

    try {
      fset.add(fld100);
      fset.add(fld101);
      fset.add(fld102);
    } catch (LBMSDMException e) {
      System.out.println ( e );
    }

    srcSDMMsg.set(fset);
    try {
      buffer = srcSDMMsg.data();
    } catch (IndexOutOfBoundsException e) {
      System.out.println ( "SDM Exception occurred during build of message:" );
      System.out.println ( e.toString() );
    } catch (LBMSDMException e) {
      System.out.println ( e.toString() );
    }
    return buffer;
  }

  public byte[] sourceCreateMessageWithPDM() {
    //Set each field value in the message
    srcPDMMsg.setFieldValue(fldInfo100, (byte)0x42);
    srcPDMMsg.setFieldValue(fldInfo101, (short)0x1ead);
    srcPDMMsg.setFieldValue(fldInfo102, 12345);

    //Serialize the message to bytes
    byte[] buffer = srcPDMMsg.toBytes();
    return buffer;
  }

  public void receiverParseMessageWithSDM(byte[] buffer) {
    //Values to be retrieved from the message byte fld100Val;
    short fld101Val;
    int fld102Val;

    //Deserialize the bytes into a message
    try {
      rcvSDMMsg.parse(buffer);
    } catch (LBMSDMException e) {
      System.out.println(e.toString());
    }

    LBMSDMField fld100 = rcvSDMMsg.locate("Field100");
    LBMSDMField fld101 = rcvSDMMsg.locate("Field101");
    LBMSDMField fld102 = rcvSDMMsg.locate("Field102");

    //Get each field value from the message
    fld100Val = ((LBMSDMFieldInt8)fld100).get();
    fld101Val = ((LBMSDMFieldInt16)fld101).get();
    fld102Val = ((LBMSDMFieldInt32)fld102).get();

    System.out.println("SDM Results: Field100=" + fld100Val +
                       ", Field101=" + fld101Val +
                       ", Field102=" + fld102Val);
  }

  public void receiverParseMessageWithPDM(byte[] buffer) {
    //Values to be retrieved from the message
    byte fld100Val;
    short fld101Val;
    int fld102Val;

    //Deserialize the bytes into a message
    rcvPDMMsg.parse(buffer);

    //Get each field value from the message
    fld100Val = rcvPDMMsg.getFieldValueAsInt8(fldInfo100);
    fld101Val = rcvPDMMsg.getFieldValueAsInt16(fldInfo101);
    fld102Val = rcvPDMMsg.getFieldValueAsInt32(fldInfo102);

    System.out.println("PDM Results: Field100=" + fld100Val +
                       ", Field101=" + fld101Val +
                       ", Field102=" + fld102Val);
  }
}
</pre><p>Notice that with sourceCreateMessageWithSDM function, the three fields (name and value) are created and added to the fset variable, which is then added to the SDM message. On the other hand, the sourceCreateMessageWithPDM function uses the FieldInfo object references to add the field values to the message for each of the three fields.</p>
<p>Also notice that the receiverParseMessageWithSDM requires a cast to the specific field class (like LBMSDMFieldInt8) once the field has been located. After the cast, calling the get method returns the expected value. On the other hand the receiverParseMessageWithPDM uses the FieldInfo object reference to directly retrieve the field value using the appropriate getFieldValueAs* method.</p>
<p><b>SDM Raw Classes</b></p>
<p>Several SDM classes with Raw in their name could be used as the value when creating an LBMSDMField. For example, an LBMSDMRawBlob instance could be created from a byte array and then that the LBMSDMRawBlob could be used as the value to a LBMSDMFieldBlob as shown in the following example.</p>
<pre class="fragment">byte[] blob = new byte[25];
LBMSDMRawBlob rawSDMBlob = new LBMSDMRawBlob(blob);
try {
  LBMSDMField fld103 = new LBMSDMFieldBlob("Field103",rawSDMBlob);
} catch (LBMSDMException e1) {
  System.out.println(e1);
}
</pre><p>The actual field named "Field103" is created in the try block using the rawSDMBlob variable which has been created to wrap the blob byte array. This field can be added to a LBMSDMFields object, which then uses it in a LBMSDMessage.</p>
<p>In PDM, there are no "Raw" classes that can be created. When setting the value for a field for a message, the appropriate variable type should be passed in as the value. For example, setting the field value for a BLOB field would mean simply passing the byte array directly in the setValue method as shown in the following code snippet since the field is defined as type BLOB.</p>
<pre class="fragment">private PDMFieldInfo fldInfo103;
public void setupPDM() {
  ...
  fldInfo103 = defn.addFieldInfo("Field103", PDMFieldType.BLOB, true);
  ...
  byte[] blob = new byte[25];

  srcPDMMsg.setFieldValue(fldInfo103, blob);
  ...
}
</pre><p>The PDM types of DECIMAL, TIMESTAMP, and MESSAGE expect a corresponding instance of PDMDecimal, PDMTimestamp, and PDMMessage as the field value when being set in the message so those types do require an instantiation instead of using a native Java type. For example, if "Field103" had been of type PDMFieldType.DECIMAL, the following code would be used to set the value.</p>
<pre class="fragment">PDMDecimal decimal = new PDMDecimal((long)2, (byte)32);
srcPDMMsg.setFieldValue(fldInfo103, decimal);
</pre><p><br />
 </p>
<h1><a class="anchor" id="sendingtosources"></a>
Sending to Sources&nbsp;&nbsp;<small><a href="#sendingtosources">&lt;-</a></small></h1>
<p>There are many use cases where a subscriber application wants to send a message to a publisher application. For example, a client application which subscribes to market data may want to send a refresh request to the publishing feed handler. While this is possible to do with normal sources and receivers, UM supports a streamlined method of doing this.</p>
<p>As of UM version 6.10, a <a class="el" href="fundamentalconcepts.html#sourcestring">Source String</a> can be used as a destination for sending a unicast immediate message. The UM library will establish a TCP connection to the publisher's context via its <em>UIM port</em> (also known as "request port"). The publishing application can receive this message either from a normal <a class="el" href="fundamentalconcepts.html#receiverobject">Receiver Object</a>, or from a context immediate message callback via configuration options <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpmulticastimmediatemessagingoperation.html#immediatemessagetopicreceiverfunctioncontext">immediate_message_topic_receiver_function (context)</a> or <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpmulticastimmediatemessagingoperation.html#immediatemessagereceiverfunctioncontext">immediate_message_receiver_function (context)</a> (for topicless messages).</p>
<p><br />
 </p>
<h2><a class="anchor" id="sourcestringfromreceiveevent"></a>
Source String from Receive Event&nbsp;&nbsp;<small><a href="#sourcestringfromreceiveevent">&lt;-</a></small></h2>
<p>A receiving application's receiver callback function can obtain a source's source string from the message structure. However, that string is not suitable to being passed directly to the unicast immediate message send function.</p>
<p>Here's a code fragment in C for receiving a message from a source, and sending a message back to the originating source. For clarity, error detection and handling code is omitted.</p>
<pre class="fragment">int user_receiver_callback(lbm_rcv_t *rcv, lbm_msg_t *msg, void *clientd)
{
  ...
  switch (msg-&gt;type) {
    ...
  case LBM_MSG_DATA:
    /* user code which processes received message and sets up "msg_for_src" */
    ...
    /* A valid UIM destination is "SOURCE:" + source string. */
    char destination[LBM_MSG_MAX_SOURCE_LEN + 8];
    strcpy(destination, "SOURCE:");
    strcat(destination, msg-&gt;source);

    err = lbm_unicast_immediate_message(ctx, destination, NULL,   /* no topic */
                                       msg_for_src, sizeof(msg_for_src),
                                       LBM_SRC_NONBLOCK);  /* Called from context thread. */
    ...
  }  /* switch msg-&gt;type */
  ...
}  /* user_receiver_callback */
</pre><p>The <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aaa7a945411e63884f12918417e8d117c">lbm_msg_t</a> structure supplies the source string, and <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a497d77b133cea1547c3346fcba99872a">lbm_unicast_immediate_message()</a> is used to send a topicless immediate message to the source's context. Alternatively, a request message could be sent with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ae011c7a66e1db1f012d7f9633dbd321d">lbm_unicast_immediate_request()</a>. If the receive events are delivered without an <a class="el" href="fundamentalconcepts.html#eventqueueobject">event queue</a>, then <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ab8a470f02029480f179cc4872b7fa713">LBM_SRC_NONBLOCK</a> is needed.</p>
<p>The example above uses the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aa47eb604db7dc9fd53f9650ed940e058">LBM_MSG_DATA</a> message type. Most receiver event (message) types also contain a valid source string. Other likely candidates for this use case might be: <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ab5489080adc7157549a9930b30c68425">LBM_MSG_BOS</a>, <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a88920e0a4188081f9a14fc8f76c18578">LBM_MSG_UNRECOVERABLE_LOSS</a>, <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a6629139aaf902976c8df9de3f37d10db">LBM_MSG_UNRECOVERABLE_LOSS_BURST</a>.</p>
<p>Note that in this example, a topicless message is sent. This requires the publishing application to use the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpmulticastimmediatemessagingoperation.html#immediatemessagereceiverfunctioncontext">immediate_message_receiver_function (context)</a> option to set up a callback for receipt of topicless immediate messages. Alternatively, a topic name can be supplied to the unicast immediate message function, in which case the publishing application would either create a normal <a class="el" href="fundamentalconcepts.html#receiverobject">Receiver Object</a> for that topic, or would configure a callback with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpmulticastimmediatemessagingoperation.html#immediatemessagetopicreceiverfunctioncontext">immediate_message_topic_receiver_function (context)</a>.</p>
<p>A Java program obtains the source string via <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMMessage.html#a5691adf8b8b740c7813d2f8d605c394d">com::latencybusters::lbm::LBMMessage::source</a>, and sends topicless unicast immediate messages via <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMContext.html#af565951d6e1b6b974c8ebd42bc0cfe16">com::latencybusters::lbm::LBMContext::sendTopicless</a>.</p>
<p>A .NET implementation is essentially the same as Java.</p>
<p><br />
 </p>
<h2><a class="anchor" id="sourcestringfromsourcenotificationfunction"></a>
Source String from Source Notification Function&nbsp;&nbsp;<small><a href="#sourcestringfromsourcenotificationfunction">&lt;-</a></small></h2>
<p>Some subscribing applications need to send a message to the publisher as soon as possible after the publisher is subscribed. Receiver events can sometimes take significant time to be delivered. The source string can be obtained via the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpdeliverycontrol.html#sourcenotificationfunctionreceiver">source_notification_function (receiver)</a> configuration option. This defines a callback function which is called at the start of the process of subscribing to a source.</p>
<p>Here's a code fragment in C for sending a message to a newly-discovered source. For clarity, error detection and handling code is omitted.</p>
<p>During initialization, when the receiver is defined, the callback must be configured using the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/structlbm__rcv__src__notification__func__t__stct.html">lbm_rcv_src_notification_func_t_stct</a> structure:</p>
<pre class="fragment">  lbm_rcv_src_notification_func_t src_notif_callback_info;
  src_notif_callback_info.create_func = src_notif_callback_create;  /* User function. */
  src_notif_callback_info.delete_func = src_notif_callback_delete;  /* User function. */
  src_notif_callback_info.clientd = NULL;   /* Can be user's receiver-specific state. */
  ...
  lbm_rcv_topic_attr_t *rcv_topic_attr;
  err = lbm_rcv_topic_attr_create(&amp;rcv_topic_attr);

  err = lbm_rcv_topic_attr_setopt(rcv_topic_attr, "source_notification_function",
                                 &amp;src_notif_callback_info, sizeof(src_notif_callback_info));

  lbm_topic_t *receiver_topic;
  err = lbm_rcv_topic_lookup(&amp;receiver_topic, ctx, receiver_topic_name, rcv_topic_attr);

  lbm_rcv_t *receiver;
  err = lbm_rcv_create(&amp;receiver, ctx, receiver_topic, ...);
</pre><p>This creates the <a class="el" href="fundamentalconcepts.html#receiverobject">Receiver Object</a> with the source notification callback configured. Note that the source notification callback has both a create and a delete function, to facilitate state management by the user.</p>
<pre class="fragment">void * src_notif_callback_create(const char *source_name, void *clientd)
{
  /* This function is called when the subscription is being set up. */

  /* user code which sets up "msg_for_src" */
  ...
  /* A valid UIM destination is "SOURCE:" + source string. */
  char destination[LBM_MSG_MAX_SOURCE_LEN + 8];
  strcpy(destination, "SOURCE:");
  strcat(destination, source_name);

  err = lbm_unicast_immediate_message(ctx, destination, NULL,   /* no topic */
                                     msg_for_src, sizeof(msg_for_src),
                                     LBM_SRC_NONBLOCK);  /* Called from context thread. */
  ...
  return NULL;  /* Can be per-source state. */
}  /* src_notif_callback_create */


int src_notif_callback_delete(const char *source_name, void *clientd, void *source_clientd) {
  /* This function not used for anything in this example, but could be used to
   * to clean up per-source state. */
  return 0;
}  /* src_notif_callback_delete */
</pre><p>A Java program configures the source notification callback via <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMReceiverAttributes.html#ada8450c3e6c34d298256279418f026a4">com::latencybusters::lbm::LBMReceiverAttributes::setSourceNotificationCallbacks</a>.</p>
<p>A .NET implementation is essentially the same as Java.</p>
<p><br />
 </p>
<h2><a class="anchor" id="sendingtosourcereadiness"></a>
Sending to Source Readiness&nbsp;&nbsp;<small><a href="#sendingtosourcereadiness">&lt;-</a></small></h2>
<p>In most use cases for sending messages to a source, there is an implicit assumption that a subscribing receiver is fully set up and ready to receive messages from the publisher. However, due to the asynchronous nature of UM, there is no straight-forward way for a receiver to know the earliest point in time when messages sent by the source will be delivered to the receiver. For example, in a routed network (using the <a class="el" href="fundamentalconcepts.html#umrouter">UM Router</a>), a receiver might deliver BOS to the application, but that just means that the connection to the proper UM Router is complete. There could still be delays in the entire end-to-end path being able to deliver messages.</p>
<p>Also, be aware that although unicast immediate messages are delivered via TCP, these messages are not guaranteed. Especially in a routed network, there exists the possibility that a message will fail to reach the publisher.</p>
<p>In most cases, the immediate message is received by the publisher, and by the time the publisher reacts, the end-to-end source-to-receiver path is active. However, in the unlikely event that something goes wrong, a subscribing application should implement a timeout/retry mechanism. This advice is not specific to the "sending to source" use cases, and should be built into any kind of request/response-oriented use case.</p>
<p><br />
 </p>
<h1><a class="anchor" id="spectrum"></a>
Spectrum&nbsp;&nbsp;<small><a href="#spectrum">&lt;-</a></small></h1>
<p>UM Spectrum, which refers to a "spectrum of channels", allows the application designer to sub-divide a topic into any number of channels, which can be individually subscribed to by a receiving application. This provides an extra level of message filtering.</p>
<p>The sending application first allocates the desired number of source channel objects using <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a73298f53aa9c5572cd0b1e68a4ec435a">lbm_src_channel_create()</a>. Then it creates a topic source in the normal way. Finally, the application sends messages using <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a091b5806bf18d10ebd0d9117e0c70229">lbm_src_send_ex()</a>, specifying the source channel object in the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a21504de56612c7c6e4be655402b47a37">lbm_src_send_ex_info_t</a>'s channel_info field.</p>
<p>A receiving application first creates a topic receiver in the normal way. Then it subscribes to channels using <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aa8304114445d291e6f16472d733ab250">lbm_rcv_subscribe_channel()</a> or lbm_wrcv_subscribe_channel(). Since each channel requires a different receiver callback, the receiver application can achieve more granular filtering of messages. Moreover, messages are received in-order across channels since all messages are part of the same topic stream.</p>
<p>It should be noted that a regular topic receiver (one for which no spectrum channels are subscribed) delivers all received messages from a matching spectrum topic source to the receiver's callback without creating the channel_info object.</p>
<p>You can accomplish the same level of filtering with a topic space design that creates separate topics for each channel, however, UM cannot guarantee the delivery of messages from multiple sources/topics in any particular order. Not only can UM Spectrum deliver the messages over many channels in the order they were sent by the source, but it also reduces topic resolution traffic since UM advertises only topics, not channels.</p>
<dl class="section note"><dt>Note</dt><dd>With the UMQ product, you cannot use UM Spectrum with Queuing (both Brokered and ULB).</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="spectrumperformanceadvantages"></a>
Spectrum Performance Advantages&nbsp;&nbsp;<small><a href="#spectrumperformanceadvantages">&lt;-</a></small></h2>
<p>The use of separate callbacks for different channels improves filtering and also relieves the source application of the task of including filtering information in the message data.</p>
<p>Java and .NET performance also receives a boost because messages not of interest can be discarded before they transition to the Java or .NET level.</p>
<p><br />
 </p>
<h2><a class="anchor" id="spectrumconfigurationoptions"></a>
Spectrum Configuration Options&nbsp;&nbsp;<small><a href="#spectrumconfigurationoptions">&lt;-</a></small></h2>
<p>Spectrum's default behavior delivers messages on any channels the receiver has subscribed to on the callbacks specified when subscribing, and all other messages on the receiver's default callback. This behavior can be changed with the following configuration options.</p>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpdeliverycontrol.html#nullchannelbehaviorreceiver">null_channel_behavior (receiver)</a> - behavior for messages delivered with no channel information. </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpdeliverycontrol.html#unrecognizedchannelbehaviorreceiver">unrecognized_channel_behavior (receiver)</a> - behavior for messages delivered with channel information but are on a channel for which the receiver has not registered interest. </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpdeliverycontrol.html#channelmaptableszreceiver">channel_map_tablesz (receiver)</a> - controls the size of the table used by a receiver to store channel subscriptions. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="smartsourcesandspectrum"></a>
Smart Sources and Spectrum&nbsp;&nbsp;<small><a href="#smartsourcesandspectrum">&lt;-</a></small></h2>
<p><a class="el" href="advancedoptimizations.html#smartsources">Smart Sources</a> support Spectrum, but via different API functions. You need to tell UM that you intend to use spectrum at Smart Source creation time using the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpsmartsource.html#smartsrcenablespectrumchannelsource">smart_src_enable_spectrum_channel (source)</a> configuration option. This pre-allocates space in the message header for the spectrum channel.</p>
<p>With Smart Sources, there is no need to allocate a Spectrum source object with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a73298f53aa9c5572cd0b1e68a4ec435a">lbm_src_channel_create()</a>. Instead, you simply set the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a5aa5ef8cbf768dd5ad5bb8a709cf9d78">LBM_SSRC_SEND_EX_FLAG_CHANNEL</a> flag and the spectrum channel number in the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a33886eeac2e67170effea009d2dc3a35">lbm_ssrc_send_ex_info_t</a> passed to the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a2f50f56536778332e9f5712b06546425">lbm_ssrc_send_ex()</a> API function. For example:</p>
<pre class="fragment">  lbm_ssrc_send_ex_info_t ss_send_info;
  memset((char *)&amp;ss_send_info, 0, sizeof(ss_send_info));
  /* If this flag had been cleared previously, must set it. */
  ss_send_info.flags |= LBM_SSRC_SEND_EX_FLAG_CHANNEL;
  ss_send_info.channel = desired_channel_number;

  err = lbm_ssrc_send_ex(ss, msg_buff, msg_size, 0, &amp;ss_send_info);
</pre><p>When a Smart Source is created with Spectrum enabled, it is possible to send messages without a Spectrum channel, either by clearing the LBM_SSRC_SEND_EX_FLAG_CHANNEL flag in <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a33886eeac2e67170effea009d2dc3a35">lbm_ssrc_send_ex_info_t</a>, or by simply not supplying a <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a33886eeac2e67170effea009d2dc3a35">lbm_ssrc_send_ex_info_t</a> object by passing NULL for the <code>info</code> parameter. This suppresses all features enabled by that structure.</p>
<dl class="section note"><dt>Note</dt><dd>If using both Spectrum and <a class="el" href="umobjects.html#messageproperties">Message Properties</a> with a single Smart Source, there is an added restriction: it is not possible to send a message omitting only one of those features. I.e. if both are enabled when the Smart Source is created, it is not possible to send a message with a message property and not a channel, and it is not possible to send a message with a channel and not a property. This is because the message header is defined at Smart Source creation, and the header either must contain both or neither.</dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="hotfailoverhf"></a>
Hot Failover (HF)&nbsp;&nbsp;<small><a href="#hotfailoverhf">&lt;-</a></small></h1>
<p>UM Hot Failover (HF) lets you implement sender redundancy in your applications. You can create multiple HF senders in different UM contexts, or, for even greater resiliency, on separate machines. There is no hard limit to the number of HF sources, and different HF sources can use different transport types.</p>
<dl class="section note"><dt>Note</dt><dd>With the UMQ product, you cannot use Hot Failover with Queuing (both Brokered and ULB).</dd></dl>
<p>Hot Failover receivers filter out the duplicate messages and deliver one message to your application. Thus, sources can drop a few messages or even fail completely without causing message loss, as long as the HF receiver receives each message from at least one source.</p>
<p>The following diagram displays Hot Failover operation.</p>
<div class="image">
<img src="Hot_Failover.png" alt="Hot_Failover.png"/>
</div>
 <p>In the figure above, HF sources send copies of Message X. An HF receiver delivers the first copy of Message X it receives to the application, and discards subsequent copies coming from the other sources.</p>
<p><br />
 </p>
<h2><a class="anchor" id="implementinghotfailoversources"></a>
Implementing Hot Failover Sources&nbsp;&nbsp;<small><a href="#implementinghotfailoversources">&lt;-</a></small></h2>
<p>You create Hot Failover sources with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ab5f6226d21dd4294bbad7d9f3e7c0bf6">lbm_hf_src_create()</a>. This returns a source object with internal state information that lets it send HF messages. You delete HF sources with the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a29d45db8f76835b4ae78f4568c25712f">lbm_src_delete()</a> function.</p>
<p>HF sources send HF messages via <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ac515c1425d9b3f04f1e2cea5d66d3005">lbm_hf_src_send_ex()</a> or <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#acb6f42a8811cb998b4b19748b190f39b">lbm_hf_src_sendv_ex()</a>. These functions take a sequence number, supplied via the exinfo object, that HF receivers use to identify the same message sent from different HF sources. The exinfo has an hf_sequence_number, with a flag (LBM_SRC_SEND_EX_FLAG_HF_32 or LBM_SRC_SEND_EX_FLAG_HF_64) that identifies whether it's a 32- or 64-bit number. Each HF source sends the same message content for a given sequence number, which must be coordinated by your application.</p>
<p>If the source needs to restart its sequence number to an earlier value (e.g. start of day; not needed for normal wraparound), delete and re-create the source and receiver objects. Without re-creating the objects, the receiver sees the smaller sequence number, assumes the data are duplicate, and discards it. In (and only in) cases where this cannot be done, use <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a9f7ed3785938fcfd4771965d6430c4f2">lbm_hf_src_send_rcv_reset()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Your application must synchronize calling <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ac515c1425d9b3f04f1e2cea5d66d3005">lbm_hf_src_send_ex()</a> or <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#acb6f42a8811cb998b4b19748b190f39b">lbm_hf_src_sendv_ex()</a> with all threads sending on the same source. (One symptom of not doing so is messages appearing at the receiver as inside intentional gaps and being erroneously discarded.)</dd></dl>
<p>Please be aware that non-HF receivers created for an HF topic receive multiple copies of each message. We recommend you establish local conventions regarding the use of HF sources, such as including "HF" in the topic name.</p>
<p>For an example source application, see <a href="../example/lbmhfsrc.c">lbmhfsrc.c</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="implementinghotfailoverreceivers"></a>
Implementing Hot Failover Receivers&nbsp;&nbsp;<small><a href="#implementinghotfailoverreceivers">&lt;-</a></small></h2>
<p>You create HF receivers with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ac208c246a6e856e24e1130060e1806c3">lbm_hf_rcv_create()</a>, and delete them using <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#abc68152bcf4d18ef1d31d8f6a15ac080">lbm_hf_rcv_delete()</a> and <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a755bd1ee0a12622098b618cef46d254f">lbm_hf_rcv_delete_ex()</a>.</p>
<p>Incoming messages have an hf_sequence_number field containing the sequence number, and a message flag (LBM_MSG_FLAG_HF_32 or LBM_MSG_FLAG_HF_64) noting the bit size.</p>
<dl class="section note"><dt>Note</dt><dd>Previous UM versions used sequence_number for HF message identification. This field holds a 32-bit value and is still set for backwards compatibility, but if the HF sequence numbers are 64-bit lengths, this non-HF sequence number is set to 0. Also, you can retrieve the original (non-HF) topic sequence number via lbm_msg_retrieve_original_sequence_number() or, in Java and .NET, via LBMMessage.osqn().</dd></dl>
<p>For the maximum time period to recover lost messages, the HF receiver uses the minimum of the LBT-RM and LBT-RU NAK generation intervals (<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmreliability.html#transportlbtrmnakgenerationintervalreceiver">transport_lbtrm_nak_generation_interval (receiver)</a>, <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrureliability.html#transportlbtrunakgenerationintervalreceiver">transport_lbtru_nak_generation_interval (receiver)</a>). Each transport protocol is configured as normal, but the lost message recovery timer is the minimum of the two settings.</p>
<p>Some lbm_msg_t objects coming from HF receivers may be flagged as having "passed through" the HF receiver. This means that the message has not been ordered with other HF messages. These messages have the LBM_MSG_FLAG_HF_PASS_THROUGH flag set. UM flags messages sent from HF sources using <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a91f4b9cb04fe1323ec56833211cc5cb7">lbm_src_send()</a> in this manner, as do all non-HF sources. Also, UM flags EOS, no source notification, and requests in this manner as well.</p>
<p>For an example receiver application, see <a href="../example/lbmhfrcv.c">lbmhfrcv.c</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="implementinghotfailoverwildcardreceivers"></a>
Implementing Hot Failover Wildcard Receivers&nbsp;&nbsp;<small><a href="#implementinghotfailoverwildcardreceivers">&lt;-</a></small></h2>
<p>To create an HF wildcard receiver, set option <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grphotfailoveroperation.html#hfreceiverwildcardreceiver">hf_receiver (wildcard_receiver)</a> to 1, then create a wildcard receiver with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a5b5d52f6b87499213757b73b09bc8160">lbm_wildcard_rcv_create()</a>. This actually creates individual HF receivers on a per-topic basis, so that each topic can have its own set of HF sequence numbers. Once the HF wildcard receiver detects that all sources for a particular topic are gone it closes the individual topic HF receivers and discards the HF sequence information (unlike a standard HF receiver). You can extend or control the delete timeout period of individual HF receivers with option <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpwildcardreceiver.html#resolvernosourcelingertimeoutwildcardreceiver">resolver_no_source_linger_timeout (wildcard_receiver)</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="javaandnet"></a>
Java and .NET&nbsp;&nbsp;<small><a href="#javaandnet">&lt;-</a></small></h2>
<p>For information on implement the HF feature in a Java application, go to UM Java API and see the documentation for classes <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMHotFailoverReceiver.html">com::latencybusters::lbm::LBMHotFailoverReceiver</a> and <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMHotFailoverSource.html">com::latencybusters::lbm::LBMHotFailoverSource</a>.</p>
<p>For information on implement the HF feature in a .NET application, go to UM .NET API and navigate to Namespaces-&gt;<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBM.html">com.latencybusters.lbm</a>-&gt;LBMHotFailoverReceiver and LBMHotFailoverSource.</p>
<p><br />
 </p>
<h2><a class="anchor" id="usinghotfailoverwithpersistence"></a>
Using Hot Failover with Persistence&nbsp;&nbsp;<small><a href="#usinghotfailoverwithpersistence">&lt;-</a></small></h2>
<p>When implementing Hot Failover with Persistence, you must consider the following impact on hardware resources:</p>
<ul>
<li>
Additional storage space required for a Persistent Store </li>
<li>
Higher disk activity </li>
<li>
Higher network activity </li>
<li>
Increased application complexity regarding message filtering </li>
</ul>
<p>Also note that you must enable UME explicit ACKs and Hot Failover duplicate delivery in each Hot Failover receiving application.</p>
<p>For detailed information on using Hot Failover with Persistence, see the Knowledge Base article <a href="https://kb.informatica.com/faq/5/Pages/80173.aspx">FAQ: Is UMP compatible with Hot Failover?</a></p>
<p><br />
 </p>
<h2><a class="anchor" id="hotfailoverintentionalgapsupport"></a>
Hot Failover Intentional Gap Support&nbsp;&nbsp;<small><a href="#hotfailoverintentionalgapsupport">&lt;-</a></small></h2>
<p>UM supports intentional gaps in HF message streams. Your HF sources can supply message sequence numbers with number gaps up to 1073741824. HF receivers automatically detect the gaps and consider any missing message sequence numbers as not sent and do not attempt recovery for these missing sequence numbers. See the following example.</p>
<ol>
<li>
HF source 1 sends message sequence numbers: 10, 11, 12, 13, 25, 26, 38 </li>
<li>
HF source 2 sends message sequence numbers: 10, 11, 12, 13, 25, 26, 38 </li>
</ol>
<p>HF receiver 1 receives message sequence numbers in order with no pause between any messages: 10, 11, 12, 13, 25, 26, 38</p>
<p><br />
 </p>
<h2><a class="anchor" id="hotfailoveroptionalmessages"></a>
Hot Failover Optional Messages&nbsp;&nbsp;<small><a href="#hotfailoveroptionalmessages">&lt;-</a></small></h2>
<p>Hot Failover sources can send optional messages that HF receivers can be configured to receive or not receive (<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grphotfailoveroperation.html#hfoptionalmessagesreceiver">hf_optional_messages (receiver)</a>). HF receivers detect an optional message by checking <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/structlbm__msg__t__stct.html#a9041a176f44dca95c3a5c6cc23d32d6c">lbm_msg_t.flags</a> for LBM_MSG_FLAG_HF_OPTIONAL. HF sources indicate an optional message by passing <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a5bf62d916b1acee97156dc8077ac3584">LBM_SRC_SEND_EX_FLAG_HF_OPTIONAL</a> in the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/structlbm__src__send__ex__info__t__stct.html#aa450a079510ebdc97b19625d10bd18ea">lbm_src_send_ex_info_t.flags</a> field to <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ac515c1425d9b3f04f1e2cea5d66d3005">lbm_hf_src_send_ex()</a> or <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#acb6f42a8811cb998b4b19748b190f39b">lbm_hf_src_sendv_ex()</a>. In the examples below, optional messages appear with an "o" after the sequence number.</p>
<ol>
<li>
HF source 1 sends message sequence numbers: 10, 11, 12, 13o, 14o, 15, 16o, 17o, 18o, 19o, 20 </li>
<li>
HF source 2 sends message sequence numbers: 10, 11, 12, 13o, 14o, 15, 16o, 17o, 18o, 19o, 20 </li>
</ol>
<p>HF receiver 1 receives: 10, 11, 12, 13o, 14o, 15, 16o, 17o, 18o, 19o, 20</p>
<p>HF receiver 2, configured to ignore optional messages, receives: 10, 11, 12, 15, 20</p>
<p><br />
 </p>
<h2><a class="anchor" id="usinghotfailoverwithordereddelivery"></a>
Using Hot Failover with Ordered Delivery&nbsp;&nbsp;<small><a href="#usinghotfailoverwithordereddelivery">&lt;-</a></small></h2>
<p>An HF receiver takes some of its operating parameters directly from the receive topic attributes. The <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#ordereddeliveryreceiver">ordered_delivery (receiver)</a> setting indicates the ordering for the HF receiver.</p>
<dl class="section note"><dt>Note</dt><dd>UM supports Arrival Order with HF only when all sources use the same transport type.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="hotfailoveracrossmultiplecontexts"></a>
Hot Failover Across Multiple Contexts&nbsp;&nbsp;<small><a href="#hotfailoveracrossmultiplecontexts">&lt;-</a></small></h2>
<p>If you have a receiving application on a multi-homed machine receiving HF messages from HF sources, you can set up the Hot Failover Across Contexts (HFX) feature. This involves setting up a separate UM context to receive HF messages over each NIC and then creating an HFX Object, which drops duplicate HF messages arriving over all contexts. Your receiving application then receives only one copy of each HF message. The HFX feature achieves the same effect across multiple contexts as the normal Hot Failover feature does within a single context.</p>
<p>The following diagram displays Hot Failover operation across UM contexts.</p>
<div class="image">
<img src="Hot_Failover_X.png" alt="Hot_Failover_X.png"/>
</div>
 <p>For each context that receives HF messages, create one HFX Receiver per topic. Each HFX Receiver can be configured independently by passing in a UM Receiver attributes object during creation. A unique client data pointer can also be associated with each HFX Receiver. The HFX Object is a special Ultra Messaging object and does not live in any UM context.</p>
<p>Note: You never have to call lbm_topic_lookup() for a HFX Receiver. If you are creating HFX Receivers along with normal UM receivers for the same topic, do not interleave the calls. For example, call <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a82e9efbf70242d83ab287916ac497645">lbm_hfx_create()</a> and <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ae717b7b9923a6e4277ae9f7409983ffc">lbm_hfx_rcv_create()</a> for the topic. Then call lbm_topic_lookup() and <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aa7491c50fefbc2b70f8035fce7ac1477">lbm_rcv_create()</a> for the topic to create the normal UM receivers.</p>
<p>The following outlines the general procedure for HFX.</p>
<ol>
<li>
Create an HFX Object for every HF topic of interest with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a82e9efbf70242d83ab287916ac497645">lbm_hfx_create()</a>, passing in an attributes object created with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a0e904e14d61eee45af197c17f7e3dc08">lbm_hfx_attr_create()</a> to specify any attributes desired. </li>
<li>
Create a context for the first NIC receiving HF messages with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8058947690bd0995bc2c59d4a61b462f">lbm_context_create()</a>. </li>
<li>
Create a HFX Receiver for every HF topic with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ae717b7b9923a6e4277ae9f7409983ffc">lbm_hfx_rcv_create()</a>, passing in UM Receive Topic Attributes. </li>
<li>
Repeat steps 2 and 3 for all NICs receiving HF message </li>
<li>
Receive messages. The HFX Object identifies and drops all duplicates, delivering messages through a single callback (and optional event queue) specified when you created the HFX Object. </li>
</ol>
<p>Delete each HFX Receiver with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a096626db73533d6c39b22765014485b7">lbm_hfx_rcv_delete()</a> or <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a08d8cbd7f47af1d7b2199c85ecf7c44c">lbm_hfx_rcv_delete_ex()</a>. Delete the HFX Object with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#abc9924a0bd826db0c45a42d7199030b1">lbm_hfx_delete()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>When writing source-side HF applications for HFX, be aware that HFX receivers do not support hf_sequence, 64-bit sequence numbers, the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a9f7ed3785938fcfd4771965d6430c4f2">lbm_hf_src_send_rcv_reset()</a> function, or HF wildcard receivers. See <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grphotfailoveroperation.html">Hot Failover Operation Options</a>, especially HFX-specific options.</dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="daemonstatistics"></a>
Daemon Statistics&nbsp;&nbsp;<small><a href="#daemonstatistics">&lt;-</a></small></h1>
<p>The <a class="el" href="fundamentalconcepts.html#persistence">Persistence</a> Store daemon and the <a class="el" href="fundamentalconcepts.html#umrouter">UM Router</a> daemon each have a simple web server which provides operational information. This information is important for monitoring the operation and performance of these daemons. However, while the web-based presentation is convenient for manual, on-demand monitoring, it is not suitable for automated collection and recording of operational information for historical analysis.</p>
<p>Starting with UM version 6.11, a feature called "Daemon Statistics" has been added to the Store and Router daemons. The Stateful Resolver Service (SRS), added in UM version 6.12, supports Daemon Statistics only (no web server). The Daemon Statistics feature supports the background publishing of their operational information via UM messages. Monitoring systems can now subscribe to this information in much the same way that UM transport statistics can be subscribed.</p>
<p>While the information published by the Store, UM Router, and SRS daemon statistics differ in their content, the general feature usage is the same between them. When the feature is configured, the daemon will periodically collect and publish its operational information.</p>
<p>The following sections give general information which is common across daemons, followed by links to daemon-specific details.</p>
<p><br />
 </p>
<h2><a class="anchor" id="daemonstatisticsstructures"></a>
Daemon Statistics Structures&nbsp;&nbsp;<small><a href="#daemonstatisticsstructures">&lt;-</a></small></h2>
<p>The operational information is published as messages of different types sent over a normal UM topic source (topic name configurable). For the Store and Router daemons, each message is in the form of a binary, C-style data structure. For the SRS service, the messages are formatted as JSON.</p>
<p>There are generally two categories of messages: <em>config</em> and <em>stats</em>. A given instance of a category "config" message does not have content which changes over time. An instance of a category "stats" message has content that <em>does</em> change over time. The daemon-specific documentation indicates which messages are in which category.</p>
<p>Each message type is configured for a publishing interval. When the publishing interval for a message type expires, the possible messages are checked to see if its content has materially changed since the last interval. If not, then the message is <em>not</em> republished. The publishing interval for a stat message is typically set to shorter periods to see those changes as they occur.</p>
<p>Note that the SRS message format is JSON, and therefore the granularity of published data is finer. I.e. a given message type might be published, but only a subset of the fields within the message might be included. In contrast, the daemons which publish binary structures send the structures complete.</p>
<p>Finally, note that while the contents of a given instance of a config message does not change over time, new instances of the message type can be sent as a result of state changes. For example, a new instance of <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/umedmonmsgs_8h.html#a3e3a1b935708cc8ac42cb70b0caf6808">umestore_repo_dmon_config_msg_t</a> is published each time a new source registers with the store.</p>
<p>More detailed information is available in the daemon-specific documentation referenced below.</p>
<p><br />
 </p>
<h2><a class="anchor" id="daemonstatisticsbinarydata"></a>
Daemon Statistics Binary Data&nbsp;&nbsp;<small><a href="#daemonstatisticsbinarydata">&lt;-</a></small></h2>
<p>For the Store and Router daemons, the messages published are in binary form and map onto the C data structures defined for each message type.</p>
<p>For the SRS service, the messages are formatted as JSON, so this section does not apply to the SRS.</p>
<p>The byte order of the structure fields is defined as the host endian architecture of the publishing daemon. Thus, if a monitoring host receiving the messages has the same endian architecture, the binary structures can be used directly. If the monitoring host has the opposite endian architecture, the receiver must byte-swap the fields.</p>
<p>The message structure is designed to make it possible for a monitoring application to detect a mismatch in endian architecture. Detection and byte swapping is demonstrated with daemon-specific example monitoring applications.</p>
<p>More detailed information is available in the daemon-specific documentation referenced below.</p>
<p><br />
 </p>
<h2><a class="anchor" id="daemonstatisticsversioning"></a>
Daemon Statistics Versioning&nbsp;&nbsp;<small><a href="#daemonstatisticsversioning">&lt;-</a></small></h2>
<p>For the Store and Router daemons, each message sent by the daemon consists of a standard header followed by a message-type-specific set of fields. The standard header contains a <code>version</code> field which identifies the version of the C include file used to build the daemon.</p>
<p>For the SRS service, the messages are formatted as JSON, so this section does not apply to the SRS.</p>
<p>For example, the Store daemon is built with the include file <code><a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/umedmonmsgs_8h.html">umedmonmsgs.h</a></code>. With each daemon statistics message sent by the Store daemon, it sets the header version field to <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/umedmonmsgs_8h.html#af43ca32ea1917897c4ff1310d214c20b">LBM_UMESTORE_DMON_VERSION</a>. With each new release of the UM package, if that include file changes in a substantive way, the value of <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/umedmonmsgs_8h.html#af43ca32ea1917897c4ff1310d214c20b">LBM_UMESTORE_DMON_VERSION</a> is increased. In this way, a monitoring application can determine if it is receiving messages from a store daemon whose data structures match the monitoring application's structure definitions.</p>
<p>More detailed information is available in the daemon-specific documentation referenced below.</p>
<p><br />
 </p>
<h2><a class="anchor" id="daemonstatisticsrequests"></a>
Daemon Statistics Requests&nbsp;&nbsp;<small><a href="#daemonstatisticsrequests">&lt;-</a></small></h2>
<p>The daemon can optionally be configured to accept command-and-control requests from monitoring applications. There are two categories of these requests: <em>"snapshot"</em> and <em>"config"</em>. "Snapshot" requests tell the daemon to immediately republish the desired stats and/or configs without waiting until the next publishing interval. These requests might be sent by a monitoring application which has only just started running and needs a full snapshot of the operational information. "Config" requests tell the daemon to modify an operational parameter of the running daemon.</p>
<p>The monitoring application sends a request to the daemon, and the daemon sends status messages in response. The exchanges are made via standard UM topicless immediate <a class="el" href="fundamentalconcepts.html#requestresponse">Request/Response</a> messaging. Informatica recommends the use of Unicast Immediate Messaging (UIM) for sending the requests using <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ae011c7a66e1db1f012d7f9633dbd321d">lbm_unicast_immediate_request()</a>. See <a class="el" href="umfeatures.html#unicastimmediatemessaging">Unicast Immediate Messaging</a> for details on UIM. To use UIM effectively, Informatica recommends configuring the daemon monitor context for a specific UIM interface and port using: <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpunicastimmediatemessagingnetwork.html#requesttcpportcontext">request_tcp_port (context)</a> and <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpunicastimmediatemessagingnetwork.html#requesttcpinterfacecontext">request_tcp_interface (context)</a>. This enables the monitoring application to know how to address the request UIMs to the proper daemon.</p>
<p>For the Store and Router daemons, The request message is formatted as a simple ASCII string. For the SRS service, the request message is formatted as a JSON message. The request is sent as a non-topic unicast immediate request message. The daemon reacts by parsing the request and sending a UM response with a success/failure response. If the request was parsed successfully, the daemon then performs the requested operation (republishing the data or modifying the operational parameter). There are daemon-specific example applications which demonstrate the use of this request feature.</p>
<p>More detailed information is available in the daemon-specific documentation referenced below.</p>
<p><br />
 </p>
<h2><a class="anchor" id="daemonstatisticsdetails"></a>
Daemon Statistics Details&nbsp;&nbsp;<small><a href="#daemonstatisticsdetails">&lt;-</a></small></h2>
<p>For details on the Persistent Store's daemon statistics feature, see <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/ume.tag:../UME/" href="../UME/storedaemonstatistics.html">Store Daemon Statistics</a>.</p>
<p>For details on the <a class="el" href="fundamentalconcepts.html#umrouter">UM Router</a>'s daemon statistics feature, see <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/gateway.tag:../Gateway/" href="../Gateway/umrouterdaemonstatistics.html">UM Router Daemon Statistics</a>.</p>
<p>For details on the SRS's daemon statistics feature, see <a class="el" href="srsdaemonstatistics.html">SRS Daemon Statistics</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
</body>
</html>
