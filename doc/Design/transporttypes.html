<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Concepts Guide: Transport Types</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen_manual.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Concepts Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('transporttypes.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Transport Types </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><br />
 </p>
<h1><a class="anchor" id="transporttcp"></a>
Transport TCP&nbsp;&nbsp;<small><a href="#transporttcp">&lt;-</a></small></h1>
<p>The TCP UM transport uses normal TCP connections to send messages from sources to receivers. This is the default transport when it's not explicitly set. TCP is a good choice when:</p>
<p>LBT-TCP's <a class="el" href="fundamentalconcepts.html#transportpacing">Transport Pacing</a> can be either source-paced or receiver-paced. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransporttcpoperation.html#transporttcpmultiplereceiverbehaviorsource">transport_tcp_multiple_receiver_behavior (source)</a>.</p>
<ul>
<li>
Flow control is desired. For example, when one or more receivers cannot keep up, you wish to slow down the source. But see <a class="el" href="transporttypes.html#tcpflowcontrolrestrictions">TCP Flow Control Restrictions</a>. </li>
<li>
Equal bandwidth sharing with other TCP traffic is desired. I.e. when it is desired that the source slow down when general network traffic becomes heavy. </li>
<li>
There are few receivers listening to each topic. Multiple receivers for a topic requires multiple transmissions of each message, which places a scaling burden on the source machine and the network. </li>
<li>
The application is not sensitive to latency. Use of TCP as a messaging transport can result in unbounded latency. </li>
<li>
The messages must pass through a restrictive firewall which does not pass multicast traffic. </li>
</ul>
<p>Some users choose TCP to avoid unrecoverable loss. However, be aware that network failures can result in TCP disconnects, which can lead to missed messages. Also, if the DRO is being used, messages can be dropped due to full queues in an overloaded DRO, leading to unrecoverable loss.</p>
<p>UM's TCP transport includes a Session ID. A UM source using the TCP transport generates a unique, 32-bit non-zero random Session ID for each TCP transport (IP:port) it uses. The source also includes the Session ID in its Topic Resolution advertisement (TIR). When a receiver resolves its topic and discovers the transport information, the receiver also obtains the transport's Session ID. The receiver sends a message to the source to confirm the Session ID.</p>
<p>The TCP Session ID enables multiple receivers for a topic to connect to a source across a <a class="el" href="fundamentalconcepts.html#umrouter">DRO</a>. In the event of a DRO failure, UM establishes new topic routes which can cause cached Topic Resolution and transport information to be outdated. Receivers use this cached information to find sources. Session IDs add a unique identifier to the cached transport information. If a receiver tries to connect to a source with outdated transport information, the source recognizes an incorrect Session ID and disconnects the receiver. The receiver can then attempt to reconnect with different cached transport information.</p>
<dl class="section note"><dt>Note</dt><dd>To maintain interoperability between version pre-6.0 receivers and version 6.0 and beyond TCP sources, you can turn off TCP Session IDs with the UM configuration option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransporttcpoperation.html#transporttcpusesessionidsource">transport_tcp_use_session_id (source)</a>.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="tcpflowcontrolrestrictions"></a>
TCP Flow Control Restrictions&nbsp;&nbsp;<small><a href="#tcpflowcontrolrestrictions">&lt;-</a></small></h2>
<p>The TCP transport protocol can provide a limited form of flow control. I.e. if a publisher is sending messages faster than a subscriber can process them, the publisher's "send" call will "block" to force the sender to slow down to the receiver's rate. (Alternatively, a non-blocking send will return -1 with the error code <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a75f0f83b8684df30d9816210cc20b4b0">LBM_EWOULDBLOCK</a>.)</p>
<p>However, be aware that there are restrictions on this use case.</p>
<ul>
<li>
<b>DRO</b> - The DRO does not support end-to-end flow control. If a DRO is between a source and a slow receiver, the DRO will drop messages, resulting in unrecoverable loss in the receiver. </li>
<li>
<b>Event Queue</b> - If the receiver uses an event queue, a slow receiver can result in unbounded memory growth in the subscriber, rather than slowing down the publisher. </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransporttcpoperation.html#transporttcpmultiplereceiverbehaviorsource">transport_tcp_multiple_receiver_behavior (source)</a> - if set to "source_paced", the source will drop messages intended for a slow receiver when the socket buffers fill, resulting in unrecoverable loss in the receiver. </li>
</ul>
<p>If end-to-end application-level flow control is needed, users should implement their own handshakes.</p>
<p><br />
 </p>
<h1><a class="anchor" id="transportlbtru"></a>
Transport LBT-RU&nbsp;&nbsp;<small><a href="#transportlbtru">&lt;-</a></small></h1>
<p>The LBT-RU UM transport adds reliable delivery to unicast UDP to send messages from sources to receivers. This provides greater flexibility in the control of latency. For example, the application can further limit latency by allowing the use of arrival order delivery. See the Knowledge Base article, <a href="https://kb.informatica.com/faq/5/Pages/80043.aspx">FAQ: How do arrival-order delivery and in-order delivery affect latency?</a>. Also, LBT-RU is less sensitive to overall network load; it uses source rate controls to limit its maximum send rate.</p>
<p>LBT-RU's <a class="el" href="fundamentalconcepts.html#transportpacing">Transport Pacing</a> is source-paced.</p>
<p>Since it is based on unicast addressing, LBT-RU can pass through most firewalls. However, it has the same scaling issues as TCP when multiple receivers are present for each topic.</p>
<p>UM's LBT-RU transport includes a Session ID. A UM source using the LBT-RU transport generates a unique, 32-bit non-zero random Session ID for each transport it uses. The source also includes the Session ID in its Topic Resolution advertisement (TIR). When a receiver resolves its topic and discovers the transport information, the receiver also obtains the transport's Session ID.</p>
<p>The LBT-RU Session ID enables multiple receivers for a topic to connect to a source across a <a class="el" href="fundamentalconcepts.html#umrouter">DRO</a>. In the event of a DRO failure, UM establishes new topic routes which can cause cached Topic Resolution and transport information to be outdated. Receivers use this cached information to find sources. Session IDs add a unique identifier to the cached transport information. If a receiver tries to connect to a source with outdated transport information, the transport drops the received data and times out. The receiver can then attempt to reconnect with different cached transport information.</p>
<dl class="section note"><dt>Note</dt><dd>To maintain interoperability between version pre-3.3 receivers and version 3.3 and beyond LBT-RU sources, you can turn off LBT-RU Session IDs with the UM configuration option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtruoperation.html#transportlbtruusesessionidsource">transport_lbtru_use_session_id (source)</a>.</dd>
<dd>
LBT-RU can benefit from hardware acceleration. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportacceleration.html">Transport Acceleration Options</a> for more information.</dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="transportlbtrm"></a>
Transport LBT-RM&nbsp;&nbsp;<small><a href="#transportlbtrm">&lt;-</a></small></h1>
<p>The LBT-RM transport adds reliable multicast to UDP to send messages. This provides the maximum flexibility in the control of latency. In addition, LBT-RM can scale effectively to large numbers of receivers per topic using network hardware to duplicate messages only when necessary at wire speed. One limitation is that multicast is often blocked by firewalls.</p>
<p>LBT-RM's <a class="el" href="fundamentalconcepts.html#transportpacing">Transport Pacing</a> is source-paced.</p>
<p>LBT-RM is a UDP-based, reliable multicast protocol designed with the use of UM and its target applications specifically in mind.</p>
<p>UM's LBT-RM transport includes a Session ID. A UM source using the LBT-RM transport generates a unique, 32-bit non-zero random Session ID for each transport it uses. The source also includes the Session ID in its Topic Resolution advertisement (TIR). When a receiver resolves its topic and discovers the transport information, the receiver also obtains the transport's Session ID.</p>
<dl class="section note"><dt>Note</dt><dd>LBT-RM can benefit from hardware acceleration. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportacceleration.html">Transport Acceleration Options</a> for more information.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="naksuppression"></a>
NAK Suppression&nbsp;&nbsp;<small><a href="#naksuppression">&lt;-</a></small></h2>
<p>Some reliable multicast protocols are susceptible to "NAK storms" in which a subscriber experiences loss due to overload, and the publisher sends those retransmissions, which makes the subscriber's overload <em>more severe</em>, resulting in an even greater loss rate, which triggers an even greater NAK rate, which triggers an even greater retransmission rate, and so on. This self-reinforcing feedback loop can cause healthy, non-overloaded subscribers to become so overwhelmed with retransmissions that they also experience loss and send NAKs, making the storm worse. Some users of other protocols have experienced NAK storms so severe that their entire network "melts down" and becomes unresponsive.</p>
<p>The Ultra Messaging LBT-RM protocol was designed specifically to prevent this kind of run-away feedback loop using a set of algorithms collectively known as "NAK Suppression". These algorithms are designed to repair occasional loss reasonably quickly, while preventing a <a class="el" href="umglossary.html#crybabyreceiver">crybaby receiver</a> from degrading the overall system.</p>
<p>Note that although UM's <a class="el" href="transporttypes.html#transportlbtru">Transport LBT-RU</a> does not use Multicast, there are still dangers associated with crybaby receivers. LBT-RU implements most of the same NAK suppression algorithms.</p>
<p>Here are the major elements of UM's NAK suppression algorithms:</p>
<ul>
<li>
<p class="startli">When a receiver detects datagram loss (missing sequence number), it chooses a random amount of time to back off before sending a NAK (see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmreliability.html#transportlbtrmnakinitialbackoffintervalreceiver">transport_lbtrm_nak_initial_backoff_interval (receiver)</a>). If the receiver subsequently receives the missing datagram(s) before the timer expires, it cancels the timer and sends no NAK.</p>
<p>This reduces the load in the case of common loss patterns across multiple receivers. Whichever receiver chooses the smallest amount of time sends the NAK, and the retransmission prevents (suppresses) NAKs from the other receivers.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The source has a configurable limit on the rate of retransmissions allowed; see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmoperation.html#transportlbtrmretransmitratelimitcontext">transport_lbtrm_retransmit_rate_limit (context)</a>. When that rate is reached, the source rejects NAKs for the remainder of the rate limit interval and instead sends NCFs in response to the NAKs. (NCFs suppress receivers from sending NAKs for specific sequence numbers for configurable periods of time.)</p>
<p class="endli"></p>
</li>
<li>
The source has a configurable interval during which it will only send one retransmission for a given sequence number; see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmreliability.html#transportlbtrmignoreintervalsource">transport_lbtrm_ignore_interval (source)</a>. If a source receives multiple NAKs for the same sequence number within that interval, only the first will trigger a retransmission. Subsequent NAKs within the ignore interval are rejected, triggering one or more NCFs. </li>
</ul>
<p>Note that LBT-RM's NCF algorithm was improved in UM version 6.10. Prior to 6.10, the source responds to every rejected NAK with an NCF (if the reason for the rejection is temporary). In UM 6.10 and beyond, only the first rejected NAK within an ignore interval triggers an NCF. Any subsequent NAKs in the same ignore interval are silently discarded. This reduces the NCF rate in a wide variety of loss conditions, which reduces the stress on healthy receivers.</p>
<dl class="section warning"><dt>Warning</dt><dd>We have seen customers choose configuration values which reduce the protective characteristics of LBT-RM. For example, setting the retransmission rate too high, or the NAK backoff intervals too low. Doing so can reduce loss-induced latency, but can also risk disruptive NAK/retransmission storms which can stress otherwise healthy receivers. Users should request review of their configurations from Informatica's Ultra Messaging support organization.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="comparinglbtrmndpgm"></a>
Comparing LBT-RM and PGM&nbsp;&nbsp;<small><a href="#comparinglbtrmndpgm">&lt;-</a></small></h2>
<p>The LBT-RM protocol is very similar to <a href="http://www.ietf.org/rfc/rfc3208.txt">PGM</a>, but with changes to aid low latency messaging applications.</p>
<ul>
<li>
Topic Mapping - Several topics may map onto the same LBT-RM session. Thus a multiplexing mechanism to LBT-RM is used to distinguish topic level concerns from LBT-RM session level concerns (such as retransmissions, etc.). Each message to a topic is given a sequence number in addition to the sequence number used at the LBT-RM session level for packet retransmission. </li>
<li>
Negative Acknowledgments (NAKs) - LBT-RM uses NAKs as PGM does. NAKs are unicast to the sender. For simplicity, LBT-RM uses a similar NAK state management approach as PGM specifies. </li>
<li>
Time Bounded Recovery - LBT-RM allows receivers to specify a maximum time to wait for a lost piece of data to be retransmitted. This allows a recovery time bound to be placed on data that has a definite lifetime of usefulness. If this time limit is exceeded and no retransmission has been seen, then the piece of data is marked as an unrecoverable loss and the application is informed. The data stream may continue and the unrecoverable loss will be ordered as a discrete event in the data stream just as a normal piece of data. </li>
<li>
Flexible Delivery Ordering - LBT-RM receivers have the option to have the data for an individual topic delivered "in order" or "arrival order". Messages delivered "in order" will arrive in sequence number order to the application. Thus loss may delay messages from being delivered until the loss is recovered or unrecoverable loss is determined. With "arrival-order" delivery, messages will arrive at the application as they are received by the LBT-RM session. Duplicates are ignored and lost messages will have the same recovery methods applied, but the ordering may not be preserved. Delivery order is a topic level concern. Thus loss of messages in one topic will not interfere or delay delivery of messages in another topic. </li>
<li>
Session State Advertisements - In PGM, SPM packets are used to advertise session state and to perform PGM router assist in the routers. For LBT-RM, these advertisements are only used when data are not flowing. Once data stops on a session, advertisements are sent with an exponential back-off (to a configurable maximum interval) so that the bandwidth taken up by the session is minimal. </li>
<li>
Sender Rate Control - LBT-RM can control a sender's rate of injection of data into the network by use of a rate limiter. This rate is configurable and will back pressure the sender, not allowing the application to exceed the rate limit it has specified. In addition, LBT-RM senders have control over the rate of retransmissions separately from new data. This allows the publisher to guarantee a minimum transmission rate even in the face of massive loss at some or all receivers. </li>
<li>
Low Latency Retransmissions - LBT-RM senders do not mandate the use of NCF packets as PGM does. Because low latency retransmissions is such an important feature, LBT-RM senders by default send retransmissions immediately upon receiving a NAK. After sending a retransmission, the sender ignores additional NAKs for the same data and does not repeatedly send NCFs. The oldest data being requested in NAKs has priority over newer data so that if retransmissions are rate controlled, then LBT-RM sends the most important retransmissions as fast as possible. </li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="transportlbtipc"></a>
Transport LBT-IPC&nbsp;&nbsp;<small><a href="#transportlbtipc">&lt;-</a></small></h1>
<p>The LBT-IPC transport is an Interprocess Communication (IPC) UM transport that allows sources to publish topic messages to a shared memory area managed as a static ring buffer from which receivers can read topic messages. Message exchange takes place at memory access speed which can greatly improve throughput when sources and receivers can reside on the same host.</p>
<p>LBT-IPC's <a class="el" href="fundamentalconcepts.html#transportpacing">Transport Pacing</a> can be either source-paced or receiver-paced. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtipcoperation.html#transportlbtipcbehaviorsource">transport_lbtipc_behavior (source)</a>.</p>
<p>The LBT-IPC transport uses a "lock free" design that eliminates calls to the Operating System and allows receivers quicker access to messages. An internal validation method enacted by receivers while reading messages from the Shared Memory Area ensures message data integrity. The validation method compares IPC header information at different times to ensure consistent, and therefore, valid message data. Sources can send individual messages or a batch of messages, each of which possesses an IPC header.</p>
<p>Note that while the use of <a class="el" href="umfeatures.html#transportservicesproviderxsp">Transport Services Provider (XSP)</a> for network-based transports does not conflict with LBT-IPC, it does not apply to LBT-IPC. I.e. IPC data flows cannot be assigned to XSP threads.</p>
<p><br />
 </p>
<h2><a class="anchor" id="sourcesandlbtipc"></a>
Sources and LBT-IPC&nbsp;&nbsp;<small><a href="#sourcesandlbtipc">&lt;-</a></small></h2>
<p>When you create a source with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ab8dd76271bf9df7a5f88476d431f523e">lbm_src_create()</a> and you've set the transport option to IPC, UM creates a shared memory area object. UM assigns one of the transport IDs to this area specified with the UM context configuration options, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtipcoperation.html#transportlbtipcidhighcontext">transport_lbtipc_id_high (context)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtipcoperation.html#transportlbtipcidlowcontext">transport_lbtipc_id_low (context)</a>. You can also specify a shared memory location outside of this range with a source configuration option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtipcoperation.html#transportlbtipcidsource">transport_lbtipc_id (source)</a>, to prioritize certain topics, if needed.</p>
<p>UM names the shared memory area object according to the format, LBTIPC_x_d where x is the hexadecimal Session ID and d is the decimal Transport ID. Example names are <b>LBTIPC_42792ac_20000</b> or <b>LBTIPC_66e7c8f6_20001</b>. Receivers access a shared memory area with this object name to receive (read) topic messages.</p>
<p>See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtipcoperation.html">Transport LBT-IPC Operation Options</a> for configuration information.</p>
<p><b>Sending over LBT-IPC</b></p>
<p>To send on a topic (write to the shared memory area) the source writes to the Shared Memory Area starting at the Oldest Message Start position. It then increments each receiver's Signal Lock if the receiver has not set this to zero.</p>
<p><br />
 </p>
<h2><a class="anchor" id="receiversandlbtipc"></a>
Receivers and LBT-IPC&nbsp;&nbsp;<small><a href="#receiversandlbtipc">&lt;-</a></small></h2>
<p>Receivers operate identically to receivers for all other UM transports. A receiver can actually receive topic messages from a source sending on its topic over TCP, LBT-RU or LBT-RM and from a second source sending on LBT-IPC with out any special configuration. The receiver learns what it needs to join the LBT-IPC session through the topic advertisement.</p>
<p>The configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtipcoperation.html#transportlbtipcreceiverthreadbehaviorcontext">transport_lbtipc_receiver_thread_behavior (context)</a> controls the IPC receiving thread behavior when there are no messages available. The default behavior, '<b>pend</b>', has the receiving thread pend on a semaphore for a new message. When the source adds a message, it posts to each pending receiver's semaphore to wake the receiving thread up. Alternatively, <a class="el" href="umglossary.html#glossarybusywaiting">busy_wait</a> can be used to prevent the receiving thread going to sleep. In this case, the source does not need to post to the receiver's semaphore. It simply adds the message to shared memory, which the looping receiving thread detects with the lowest possible latency.</p>
<p>Although '<b>busy_wait</b>' has the lowest latency, it has the drawback of consuming 100% of a CPU core during periods of idleness. This limits the number of IPC data flows that can be used on a given machine to the number of available cores. (If more busy looping receivers are deployed than there are cores, then receivers can suffer 10 millisecond time sharing quantum latencies.)</p>
<p>For application that cannot afford '<b>busy_wait</b>', there is another configuration option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtipcoperation.html#transportlbtipcpendbehaviorlingerloopcountcontext">transport_lbtipc_pend_behavior_linger_loop_count (context)</a>, which allows a middle ground between '<b>pend</b>' and '<b>busy_wait</b>'. The receiver is still be configured as '<b>pend</b>', but instead of going to sleep on the semaphore <em>immediately</em> upon emptying the shared memory, it busy waits for the configured number of times. If a new message arrives, it processes the message immediately without a sleep/wakeup. This can be very useful during bursts of high incoming message rates to reduce latency. By making the loop count large enough to cover the incoming message interval during a burst, only the first message of the burst will incur the wakeup latency.</p>
<p><b>Topic Resolution and LBT-IPC</b></p>
<p>Topic resolution operates identically with LBT-IPC as other UM transports albeit with a new advertisement type, LBMIPC. Advertisements for LBT-IPC contain the Transport ID, Session ID and Host ID. Receivers obtain LBT-IPC advertisements in the normal manner (resolver cache, advertisements received on the multicast resolver address:port and responses to queries.) Advertisements for topics from LBT-IPC sources can reach receivers on different machines if they use the same topic resolution configuration, however, those receivers silently ignore those advertisements since they cannot join the IPC transport. See <a class="el" href="transporttypes.html#sendingtobothlocalandremotereceivers">Sending to Both Local and Remote Receivers</a>.</p>
<p><b>Receiver Pacing</b></p>
<p>Although <a class="el" href="fundamentalconcepts.html#transportpacing">receiver pacing</a> is a source behavior option, some different things must happen on the receiving side to ensure that a source does not reclaim (overwrite) a message until all receivers have read it. When you use the default <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtipcoperation.html#transportlbtipcbehaviorsource">transport_lbtipc_behavior (source)</a> (source-paced), each receiver's Oldest Message Start position in the Shared Memory Area is private to each receiver. The source writes to the Shared Memory Area independently of receivers' reading. For receiver-pacing, however, all receivers share their Oldest Message Start position with the source. The source will not reclaim a message until all receivers have successfully read that message.</p>
<p><b>Receiver Monitoring</b></p>
<p>To ensure that a source does not wait on a receiver that is not running, the source monitors a receiver via the Monitor Shared Lock allocated to each receiving context. (This lock is in addition to the semaphore already allocated for signaling new data.) A new receiver takes and holds the Monitor Shared Lock and releases the resource when it dies. If the source is able to obtain the resource, it knows the receiver has died. The source then clears the receiver's In Use flag in it's Receiver Pool Connection.</p>
<p><br />
 </p>
<h2><a class="anchor" id="similaritieswithotherumtransports"></a>
Similarities with Other UM Transports&nbsp;&nbsp;<small><a href="#similaritieswithotherumtransports">&lt;-</a></small></h2>
<p>Although no actual network transport occurs, IPC functions in much the same way as if you send packets across the network as with other UM transports.</p>
<ul>
<li>
If you use a range of LBT-IPC transport IDs, UM assigns multiple topics sent by multiple sources to all the Transport Sessions in a round robin manner just like other UM transports. </li>
<li>
Transport sessions assume the configuration option values of the first source assigned to the Transport Session. </li>
<li>
Sources are subject to message batching. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="differencesfromotherumtransports"></a>
Differences from Other UM Transports&nbsp;&nbsp;<small><a href="#differencesfromotherumtransports">&lt;-</a></small></h2>
<ul>
<li>
Unlike LBT-RM which uses a transmission window to specify a buffer size to retain messages in case they must be retransmitted, LBT-IPC uses the transmission window option to establish the size of the shared memory. </li>
<li>
LBT-IPC does not retransmit messages. Since LBT-IPC transport is essentially a memory write/read operation, messages should not be be lost in transit. However, if the shared memory area fills up, new messages overwrite old messages and the loss is absolute. No retransmission of old messages that have been overwritten occurs. (Note: while transport-level retransmission is not available, IPC is compatible with the <a class="el" href="umfeatures.html#offtransportrecoveryotr">Off-Transport Recovery (OTR)</a> feature, which allows for persistent message recovery from the Store, or streaming message recovery from the Source's <a class="el" href="fundamentalconcepts.html#latejoin">Late Join</a> buffer.) </li>
<li>
Receivers also do not send NAKs when using LBT-IPC. </li>
<li>
LBT-IPC does not support <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#ordereddeliveryreceiver">ordered_delivery (receiver)</a> options. However, if you set <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#ordereddeliveryreceiver">ordered_delivery (receiver)</a> 1 or -1, LBT-IPC reassembles any large messages. </li>
<li>
LBT-IPC does not support Rate Limiting. </li>
<li>
LBT-IPC creates a separate receiver thread in the receiving context. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="sendingtobothlocalandremotereceivers"></a>
Sending to Both Local and Remote Receivers&nbsp;&nbsp;<small><a href="#sendingtobothlocalandremotereceivers">&lt;-</a></small></h2>
<p>A source application that wants to support both local and remote receivers should create two UM Contexts with different topic resolution configurations, one for IPC sends and one for sends to remote receivers. Separate contexts allows you to use the same topic for both IPC and network sources. If you simply created two source objects (one IPC, one say LBT-RM) in the same UM Context, you would have to use separate topics and suffer possible higher latency because the sending thread would be blocked for the duration of two send calls.</p>
<p>A UM source will never automatically use IPC when the receivers are local and a network transport for remote receivers because the discovery of a remote receiver would hurt the performance of local receivers. An application that wants transparent switching can implement it in a simple wrapper.</p>
<p><br />
 </p>
<h2><a class="anchor" id="lbtipcconfigurationexample"></a>
LBT-IPC Configuration Example&nbsp;&nbsp;<small><a href="#lbtipcconfigurationexample">&lt;-</a></small></h2>
<p>The following diagram illustrates how sources and receivers interact with the shared memory area used in the LBT-IPC transport:</p>
<div class="image">
<img src="IPC_Objects.png" alt="IPC_Objects.png"/>
</div>
 <p>In the diagram above, 3 sources send (write) to two Shared Memory Areas while four receivers in two different contexts receive (read) from the areas. The assignment of sources to Shared Memory Areas demonstrate UM's round robin method. UM assigns the source sending on Topic A to Transport 20001, the source sending on Topic B to Transport 20002 and the source sending on Topic C back to the top of the transport ID range, 20001.</p>
<p>The diagram also shows the UM configuration options that set up this scenario:</p>
<ul>
<li>
The options <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtipcoperation.html#transportlbtipcidhighcontext">transport_lbtipc_id_high (context)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtipcoperation.html#transportlbtipcidlowcontext">transport_lbtipc_id_low (context)</a> establish the range of Transport IDs between 20001 and 20002. </li>
<li>
The option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#transportsource">transport (source)</a> is used to set the source's transport to LBT-IPC. </li>
<li>
The option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtipcoperation.html#transportlbtipctransmissionwindowsizesource">transport_lbtipc_transmission_window_size (source)</a> sets the size of each Shared Memory Area to 24 MB. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="requiredprivileges"></a>
Required privileges&nbsp;&nbsp;<small><a href="#requiredprivileges">&lt;-</a></small></h2>
<p>LBT-IPC requires no special operating system authorities, except on Microsoft Windows Vista and Microsoft Windows Server 2008, which require Administrator privileges. In addition, on Microsoft Windows XP, applications must be started by the same user, however, the user is not required to have administrator privileges. In order for applications to communicate with a service, the service must use a user account that has Administrator privileges.</p>
<p><br />
 </p>
<h2><a class="anchor" id="hostresourceusageandlimits"></a>
Host Resource Usage and Limits&nbsp;&nbsp;<small><a href="#hostresourceusageandlimits">&lt;-</a></small></h2>
<p>LBT-IPC contexts and sources consume host resources as follows:</p>
<ul>
<li>
Per Source - 1 shared memory area, 1 shared lock (semaphore on Linux, mutex on Microsoft Windows) </li>
<li>
Per Receiving Context - 2 shared locks (semaphores on Linux, one event and one mutex on Microsoft Windows) </li>
</ul>
<p>Across most operating system platforms, these resources have the following limits. </p><ul>
<li>
4096 shared memory areas, though some platforms use different limits </li>
<li>
32,000 shared semaphores (128 shared semaphore sets * 250 semaphores per set) </li>
</ul>
<p>Consult your operating system documentation for specific limits per type of resource. Resources may be displayed and reclaimed using the <a class="el" href="transporttypes.html#lbtipcresourcemanager">LBT-IPC Resource Manager</a>. See also the KB article <a href="https://kb.informatica.com/faq/5/Pages/80201.aspx">Managing LBT-IPC Host Resources</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="lbtipcresourcemanager"></a>
LBT-IPC Resource Manager&nbsp;&nbsp;<small><a href="#lbtipcresourcemanager">&lt;-</a></small></h2>
<p>Deleting an IPC source or deleting an IPC receiver reclaims the shared memory area and locks allocated by the IPC source or receiver. However, if a less than graceful exit from a process occurs, global resources remain allocated but unused. To address this possibility, the LBT-IPC Resource Manager maintains a resource allocation database with a record for each global resource (memory or semaphore) allocated or freed. You can use the LBT-IPC Resource Manager to discover and reclaim resources. See the three example outputs below.</p>
<p><b>Displaying Resources</b></p>
<pre class="fragment">$&gt; lbtipc_resource_manager
Displaying Resources (to reclaim you must type '-reclaim' exactly)

--Memory Resources--
Memory resource: Process ID: 24441 SessionID: ab569cec XportID: 20001

--Semaphore Resources-- Semaphore key: 0x68871d75
Semaphore resource Index 0: reserved

Semaphore resource: Process ID: 24441 Sem Index: 1
Semaphore resource: Process ID: 24436 Sem Index: 2
</pre><p><b>Reclaiming Unused Resources</b></p>
<pre class="fragment">$&gt; lbtipc_resource_manager -reclaim
Reclaiming Resources
Process 24441 not found: reclaiming Memory resource (SessionID: ab569cec XPortID: 20001)
Process 24441 not found: reclaiming Semaphore resource: Key: 0x68871d75 Sem Index: 1
Process 24436 not found: reclaiming Semaphore resource: Key: 0x68871d75 Sem Index: 2
</pre><p><br />
 </p>
<h1><a class="anchor" id="transportlbtsmx"></a>
Transport LBT-SMX&nbsp;&nbsp;<small><a href="#transportlbtsmx">&lt;-</a></small></h1>
<p>The LBT-SMX (shared memory acceleration) transport is an Interprocess Communication (IPC) transport you can use for the lowest latency message Streaming.</p>
<p>LBT-RU's <a class="el" href="fundamentalconcepts.html#transportpacing">Transport Pacing</a> is receiver-paced. If you need source pacing, see <a class="el" href="transporttypes.html#transportlbtipc">Transport LBT-IPC</a>.</p>
<p>Like LBT-IPC, sources can publish topic messages to a shared memory area from which receivers can read topic messages. LBT-SMX is slightly faster than <a class="el" href="transporttypes.html#transportlbtipc">Transport LBT-IPC</a>. However, SMX imposes more limitations than LBT-IPC; see <a class="el" href="transporttypes.html#differencesbetweenlbtsmxandotherumtransports">Differences Between LBT-SMX and Other UM Transports</a>.</p>
<p>To achieve the minimum possible latency and <a class="el" href="umglossary.html#glossaryjitter">jitter</a>, the receive side uses <a class="el" href="umglossary.html#glossarybusywaiting">busy waiting</a> exclusively. This means that while waiting for a message, the receiving context has a thread running at 100% CPU utilization. To avoid latency <a class="el" href="umglossary.html#glossaryjitter">jitter</a>, Informatica strongly recommends <a class="el" href="umglossary.html#glossarypinning">pinning</a> the thread to a single core to prevent the operating system from migrating the thread across cores.</p>
<p>Although busy waiting has the lowest latency, it has the drawback of consuming 100% of a CPU core, even during periods of no messages. This limits the number of SMX data flows that can be used on a given machine to the number of available cores. If this is not practical for your use case, Informatica recommends the use of <a class="el" href="transporttypes.html#transportlbtipc">Transport LBT-IPC</a>.</p>
<p>There are two forms of API calls available with LBT-SMX: </p><ul>
<li>
General APIs - the same APIs used with other transports, such as sending messages with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a91f4b9cb04fe1323ec56833211cc5cb7">lbm_src_send()</a>. </li>
<li>
SMX-specific APIs - APIs that further reduce overhead and latency but require a somewhat different code design, such as sending messages with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8a56e2f08924d25caea26d205cf730c5">lbm_src_buff_acquire()</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a4f857abe9088918c618cdd248ccf7d83">lbm_src_buffs_complete()</a>. </li>
</ul>
<p>Note that the SMX-specific APIs are not thread safe, and require that the calling application guarantee serialization of calls on a given <a class="el" href="fundamentalconcepts.html#transportsessions">Transport Sessions</a>.</p>
<p>LBT-SMX operates on the following Ultra Messaging platforms: </p><ul>
<li>
64-bit SunOS (X86 only) </li>
<li>
64-bit Linux </li>
<li>
64-bit Windows </li>
</ul>
<p>The "latency ping/pong" example programs demonstrate how to use the SMX-specific API.</p>
<p>For C: <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/example.tag:../example/" href="../example/index.html#examplelbmlatping_c">Example lbmlatping.c</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/example.tag:../example/" href="../example/index.html#examplelbmlatpong_c">Example lbmlatpong.c</a>.</p>
<p>For Java: <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/java_example.tag:../java_example/" href="../java_example/index.html#examplelbmlatping_java">Example lbmlatping.java</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/java_example.tag:../java_example/" href="../java_example/index.html#examplelbmlatpong_java">Example lbmlatpong.java</a>.</p>
<p>For .NET: <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/dotnet_example.tag:../dotnet_example/" href="../dotnet_example/index.html#examplelbmlatping_cs">Example lbmlatping.cs</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/dotnet_example.tag:../dotnet_example/" href="../dotnet_example/index.html#examplelbmlatpong_cs">Example lbmlatpong.cs</a>.</p>
<p>Many other example applications can use the LBT-SMX transport by setting the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#transportsource">transport (source)</a> configuration option to "LBT-SMX": </p><pre class="fragment">source transport LBT-SMX
</pre><p> However, you cannot use LBT-SMX with example applications for features not supported by LBT-SMX, such as <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/example.tag:../example/" href="../example/index.html#examplelbmreq_c">Example lbmreq.c</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/example.tag:../example/" href="../example/index.html#examplelbmresp_c">Example lbmresp.c</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/example.tag:../example/" href="../example/index.html#examplelbmrcvq_c">Example lbmrcvq.c</a>, or <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/example.tag:../example/" href="../example/index.html#examplelbmwrcvq_c">Example lbmwrcvq.c</a>.</p>
<p>The LBT-SMX configuration options are similar to the LBT-IPC transport options. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtsmxoperation.html">Transport LBT-SMX Operation Options</a> for more information.</p>
<p>You can use Automatic Monitoring, UM API retrieve/reset calls, and LBMMON APIs to access LBT-SMX source and receiver transport statistics. To increase performance, the LBT-SMX transport does not collect statistics by default. Set the UM configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtsmxoperation.html#transportlbtsmxmessagestatisticsenabledcontext">transport_lbtsmx_message_statistics_enabled (context)</a> to 1 to enable the collection of transport statistics.</p>
<p>The next few sections provide an in-depth understanding of how SMX works, using the C API as the model. Java and .NET programmers are encouraged to read these sections for the understanding of SMX. There are also sections specific to Java and .NET near the end to provide API details.</p>
<p><br />
 </p>
<h2><a class="anchor" id="sourcesandlbtsmx"></a>
Sources and LBT-SMX&nbsp;&nbsp;<small><a href="#sourcesandlbtsmx">&lt;-</a></small></h2>
<p>When you create a source with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ab8dd76271bf9df7a5f88476d431f523e">lbm_src_create()</a> and you've set the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#transportsource">transport (source)</a> option to "LBT-SMX", UM creates a shared memory area object. UM assigns one of the transport IDs to this area from a range of transport IDs specified with the UM context configuration options <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtsmxoperation.html#transportlbtsmxidhighcontext">transport_lbtsmx_id_high (context)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtsmxoperation.html#transportlbtsmxidlowcontext">transport_lbtsmx_id_low (context)</a>. You can also specify a shared memory location inside or outside of this range with the option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtsmxoperation.html#transportlbtsmxidsource">transport_lbtsmx_id (source)</a> to group certain topics in the same shared memory area, if needed. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtsmxoperation.html">Transport LBT-SMX Operation Options</a> for configuration details.</p>
<p>UM names the shared memory area object according to the format, <b>LBTSMX_x_d</b> where <b>x</b> is the hexadecimal Session ID and <b>d</b> is the decimal Transport ID. Example names are <b>LBTSMX_42792ac_20000</b> or <b>LBTSMX_66e7c8f6_20001</b>. Receivers access a shared memory area with this object name to receive (read) topic messages.</p>
<dl class="section note"><dt>Note</dt><dd>For every context created by your application, UM creates an additional shared memory area for control information. The name for these control information memory areas ends with the suffix, _0, which is the Transport ID.</dd></dl>
<p>Here are the SMX-specific in C: </p><ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8a56e2f08924d25caea26d205cf730c5">lbm_src_buff_acquire()</a> - obtains a pointer into the source's shared buffer for a new message of the specified length. </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a4f857abe9088918c618cdd248ccf7d83">lbm_src_buffs_complete()</a> - informs UM that one or more acquired messages are complete and ready to be delivered to receivers. </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a661393cae3ab4f8c90d26ce0a27e8d33">lbm_src_buffs_complete_and_acquire()</a> - a convenience function that is the same as calling <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8a56e2f08924d25caea26d205cf730c5">lbm_src_buff_acquire()</a> followed immediately by <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a4f857abe9088918c618cdd248ccf7d83">lbm_src_buffs_complete()</a>. </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ae28c5fac3f27e3d4ee50c0cbd02d1180">lbm_src_buffs_cancel()</a> - cancels all message buffers acquired but not yet completed. </li>
</ul>
<p>The SMX-specific APIs fail with an appropriate error message if a sending application uses them for a source configured to use a transport other than LBT-SMX.</p>
<dl class="section note"><dt>Note</dt><dd>The SMX-specific APIs are not thread safe at the source object or LBT-SMX Transport Session levels for performance reasons. Applications that use the SMX-specific APIs for either the same source or a group of sources that map to the same LBT-SMX Transport Session must serialize the calls either directly in the application or through their own mutex.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="sendingoverlbtsmxwithnativeapis"></a>
Sending with SMX-specific APIs&nbsp;&nbsp;<small><a href="#sendingoverlbtsmxwithnativeapis">&lt;-</a></small></h2>
<p>Sending with SMX-specific APIs is a two-step process.</p>
<ol>
<li>
<p class="startli">The publisher first calls <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8a56e2f08924d25caea26d205cf730c5">lbm_src_buff_acquire()</a>, which returns a pointer into which the publisher writes the message data.</p>
<p>The pointer points directly into the shared memory area. UM guarantees that the shared memory area has at least the value specified with the len parameter of contiguous bytes available for writing when <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8a56e2f08924d25caea26d205cf730c5">lbm_src_buff_acquire()</a> returns. Note that the acquire function has the potential of blocking (spinning), if the shared memory area is full of messages that are unread by at least one subscribed receiver. If your application set the LBM_SRC_NONBLOCK flag with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8a56e2f08924d25caea26d205cf730c5">lbm_src_buff_acquire()</a>, UM immediately returns an LBM_EWOULDBLOCK error condition if the function detects the blocking condition.</p>
<p>Because LBT-SMX does not support <a class="el" href="umglossary.html#glossaryumfragmentation">fragmentation</a>, your application must limit message lengths to a maximum equal to the value of the source's configured <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtsmxoperation.html#transportlbtsmxdatagrammaxsizesource">transport_lbtsmx_datagram_max_size (source)</a> option minus 16 bytes for headers. In a system deployment that includes the DRO, this value should be the same as the <a class="el" href="architecture.html#datagrammaxsizes">Datagram Max Sizes</a> of other transport types. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/gateway.tag:../Gateway/" href="../Gateway/umrouterconcepts.html#protocolconversion">Protocol Conversion</a>.</p>
<p>After the user acquires the pointer into shared memory and writes the message data, the application may call <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8a56e2f08924d25caea26d205cf730c5">lbm_src_buff_acquire()</a> repeatedly to send a batch of messages to the shared memory area. If your application writes multiple messages in this manner, sufficient space must exist in the shared memory area. <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8a56e2f08924d25caea26d205cf730c5">lbm_src_buff_acquire()</a> returns an error if the available shared memory space is less than the size of the next message.</p>
<p class="endli"></p>
</li>
<li>
The publisher calls one of the two following APIs. <ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a4f857abe9088918c618cdd248ccf7d83">lbm_src_buffs_complete()</a>, which publishes the message or messages to all listening receivers. </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a661393cae3ab4f8c90d26ce0a27e8d33">lbm_src_buffs_complete_and_acquire()</a>, which publishes the message or messages to all listening receivers and acquires a new pointer. </li>
</ul>
</li>
</ol>
<p><br />
 </p>
<h2><a class="anchor" id="sendingoverlbtsmxwithexistingapis"></a>
Sending over LBT-SMX with General APIs&nbsp;&nbsp;<small><a href="#sendingoverlbtsmxwithexistingapis">&lt;-</a></small></h2>
<p>LBT-SMX supports the general send API functions, like <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a91f4b9cb04fe1323ec56833211cc5cb7">lbm_src_send()</a>. These API calls are fully thread-safe. The LBT-SMX feature restrictions still apply (see <a class="el" href="transporttypes.html#differencesbetweenlbtsmxandotherumtransports">Differences Between LBT-SMX and Other UM Transports</a>). The lbm_src_send_ex_info_t argument to the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a091b5806bf18d10ebd0d9117e0c70229">lbm_src_send_ex()</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a4d883eaaa22baf81abf21d495f471c8b">lbm_src_sendv_ex()</a> APIs must be NULL when using an LBT-SMX source, because LBT-SMX does not support any of the features that the lbm_src_send_ex_info_t parameter can enable.</p>
<p>Since LBT-SMX does not support an implicit batcher or corresponding implicit batch timer, UM flushes all messages for all sends on LBT-SMX transports done with general APIs, which is similar to setting the LBM_MSG_FLUSH flag. LBT-SMX also supports the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#afec0ee6822fe721f21c67536660506ea">lbm_src_flush()</a> API call, which behaves like a thread-safe version of <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a4f857abe9088918c618cdd248ccf7d83">lbm_src_buffs_complete()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Users should not use both the SMX-specific APIs and the general API calls in the same application. Users should choose one or the other type of API for consistency and to avoid thread safety problems.</dd></dl>
<p>The <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a1ba60407fa2bde0997aab6d5a5d2da1a">lbm_src_topic_alloc()</a> API call generates log warnings if the given attributes specify an LBT-SMX transport and enable any of the features that LBT-SMX does not support. The <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a1ba60407fa2bde0997aab6d5a5d2da1a">lbm_src_topic_alloc()</a> returns 0 (success), but UM does not enable the unsupported features indicated in the log warnings. Other API functions that operate on lbm_src_t objects, such as <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ab8dd76271bf9df7a5f88476d431f523e">lbm_src_create()</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a29d45db8f76835b4ae78f4568c25712f">lbm_src_delete()</a>, or <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a33d3ee1d815f4a51b68653d8a063f87f">lbm_src_topic_dump()</a>, operate with LBT-SMX sources normally.</p>
<p>Because LBT-SMX does not support <a class="el" href="umglossary.html#glossaryumfragmentation">fragmentation</a>, your application must limit message lengths to a maximum equal to the value of the source's configured <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtsmxoperation.html#transportlbtsmxdatagrammaxsizesource">transport_lbtsmx_datagram_max_size (source)</a> option minus 16 bytes for headers. Any send API calls with a length parameter greater than this configured value fail. In a system deployment that includes the DRO, this value should be the same as the <a class="el" href="architecture.html#datagrammaxsizes">Datagram Max Sizes</a> of other transport types. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/gateway.tag:../Gateway/" href="../Gateway/umrouterconcepts.html#protocolconversion">Protocol Conversion</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="receiversandlbtsmx"></a>
Receivers and LBT-SMX&nbsp;&nbsp;<small><a href="#receiversandlbtsmx">&lt;-</a></small></h2>
<p>LBT-SMX receivers can be coded the same as receivers on other UM transports. The msg-&gt;data pointer of a delivered lbm_msg_t object points directly into the shared memory area. However, Java and .NET receivers can benefit from some alternate coding techniques. See <a class="el" href="transporttypes.html#javacodeexamplesforlbtsmx">Java Coding for LBT-SMX</a> and <a class="el" href="transporttypes.html#netcodeexamplesforlbtsmx">.NET Coding for LBT-SMX</a>.</p>
<p>The <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a2b7788ff58f9e78bc89ea890dad0cccf">lbm_msg_retain()</a> API function operates differently for LBT-SMX. <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a2b7788ff58f9e78bc89ea890dad0cccf">lbm_msg_retain()</a> creates a full copy of the message in order to access the data outside the receiver callback.</p>
<dl class="section attention"><dt>Attention</dt><dd>You application should not pass the msg-&gt;data pointer to other threads or outside the receiver callback until your application has called <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a2b7788ff58f9e78bc89ea890dad0cccf">lbm_msg_retain()</a> on the message.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Any API calls documented as not safe to call from a context thread callback are also not safe to call from an LBT-SMX receiver thread.</dd></dl>
<p><b>Topic Resolution and LBT-SMX</b></p>
<p>Topic resolution operates identically with LBT-SMX as other UM transports albeit with the advertisement type, LBMSMX. Advertisements for LBT-SMX contain the Transport ID, Session ID, and Host ID. Receivers get LBT-SMX advertisements in the normal manner, either from the resolver cache, advertisements received on the multicast resolver address:port, or responses to queries.</p>
<p><br />
 </p>
<h2><a class="anchor" id="similaritiesbetweenlbtsmxandotherumtransports"></a>
Similarities Between LBT-SMX and Other UM Transports&nbsp;&nbsp;<small><a href="#similaritiesbetweenlbtsmxandotherumtransports">&lt;-</a></small></h2>
<p>Although no actual network transport occurs, SMX functions in much the same way as if you send packets across the network as with other UM transports.</p>
<ul>
<li>
If you use a range of LBT-SMX transport IDs, UM assigns multiple topics sent by multiple sources to all the Transport Sessions in a round robin manner just like other UM transports. </li>
<li>
Transport sessions assume the configuration option values of the first source assigned to the Transport Session. </li>
<li>
Source applications and receiver applications based on any of the three available APIs can interoperate with each other. For example, sources created by a C publisher can send to receivers created by a Java receiving application. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="differencesbetweenlbtsmxandotherumtransports"></a>
Differences Between LBT-SMX and Other UM Transports&nbsp;&nbsp;<small><a href="#differencesbetweenlbtsmxandotherumtransports">&lt;-</a></small></h2>
<ul>
<li>
Unlike LBT-RM which uses a transmission window to specify a buffer size to retain messages for retransmission, LBT-SMX uses the transmission window option to establish the size of the shared memory. LBT-SMX uses transmission window sizes that are powers of 2. You can set <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtsmxoperation.html#transportlbtsmxtransmissionwindowsizesource">transport_lbtsmx_transmission_window_size (source)</a> to any value, but UM rounds the option value up to the nearest power of 2. </li>
<li>
The largest transmission window size for Java applications is 1 GB. </li>
<li>
The largest possible message size for Java applications is 1 GB. </li>
<li>
LBT-SMX does not retransmit messages. Since LBT-SMX transport only supports <a class="el" href="fundamentalconcepts.html#transportpacing">receiver pacing</a>, messages are never lost in transit. </li>
<li>
Receivers do not send NAKs when using LBT-SMX. </li>
</ul>
<p><b>LBT-SMX is <b>not</b> compatible with the following UM features:</b> </p><ul>
<li>
<a class="el" href="architecture.html#arrivalorderfragmentsnotreassembled">Arrival Order, Fragments Not Reassembled</a> (ordered_delivery 0). </li>
<li>
<a class="el" href="fundamentalconcepts.html#transportpacing">Source Pacing</a>. </li>
<li>
<a class="el" href="fundamentalconcepts.html#latejoin">Late Join</a>. </li>
<li>
<a class="el" href="umfeatures.html#offtransportrecoveryotr">Off-Transport Recovery (OTR)</a>. </li>
<li>
<a class="el" href="fundamentalconcepts.html#requestresponse">Request/Response</a>. </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#transportsourcesidefilteringbehaviorsource">Source-side Filtering</a>. </li>
<li>
<a class="el" href="umfeatures.html#hotfailoverhf">Hot Failover (HF)</a>. </li>
<li>
<a class="el" href="umfeatures.html#messageproperties">Message Properties</a>. </li>
<li>
<a class="el" href="umfeatures.html#applicationheaders">Application Headers</a>. </li>
<li>
<a class="el" href="architecture.html#implicitbatching">Implicit Batching</a> and <a class="el" href="architecture.html#explicitbatching">Explicit Batching</a>. </li>
<li>
<a class="el" href="architecture.html#messagefragmentationandreassembly">Message Fragmentation and Reassembly</a>. </li>
<li>
<a class="el" href="umfeatures.html#unicastimmediatemessaging">Unicast Immediate Messaging</a>. </li>
<li>
<a class="el" href="umfeatures.html#multicastimmediatemessaging">Multicast Immediate Messaging</a>. </li>
<li>
The "pend"-style of Receiver thread behavior; SMX only supports <a class="el" href="umglossary.html#glossarybusywaiting">busy_wait</a>-style. </li>
<li>
<a class="el" href="fundamentalconcepts.html#persistence">Persistence</a>. </li>
<li>
<a class="el" href="fundamentalconcepts.html#queuing">Queuing</a>. </li>
</ul>
<p>Note that while the use of <a class="el" href="umfeatures.html#transportservicesproviderxsp">Transport Services Provider (XSP)</a> for network-based transports does not conflict with LBT-SMX, it does not apply to LBT-SMX. I.e. SMX data flows cannot be assigned to XSP threads.</p>
<p>You also cannot use LBT-SMX to send outgoing traffic from a UM daemon, such as the <a class="el" href="fundamentalconcepts.html#persistence">persistent Store</a>, <a class="el" href="fundamentalconcepts.html#umrouter">DRO</a>, or <a class="el" href="umglossary.html#glossaryumds">UMDS</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="lbtsmxconfigurationexample"></a>
LBT-SMX Configuration Example&nbsp;&nbsp;<small><a href="#lbtsmxconfigurationexample">&lt;-</a></small></h2>
<p>The following diagram illustrates how sources and receivers interact with the shared memory area used in the LBT-SMX transport.</p>
<div class="image">
<img src="SMX_Objects.png" alt="SMX_Objects.png"/>
</div>
 <p>In the diagram above, three sources send (write) to two Shared Memory Areas while four receivers in two different contexts receive (read) from the areas. The assignment of sources to Shared Memory Areas demonstrate UM's round robin method. UM assigns the source sending on Topic A to Transport 30001, the source sending on Topic B to Transport 30002 and the source sending on Topic C back to the top of the transport ID range, 30001.</p>
<p>The diagram also shows the UM configuration options that set up this scenario.</p>
<ul>
<li>
The options <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtsmxoperation.html#transportlbtsmxidhighcontext">transport_lbtsmx_id_high (context)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtsmxoperation.html#transportlbtsmxidlowcontext">transport_lbtsmx_id_low (context)</a> establish the range of Transport IDs between 30001 and 30002. </li>
<li>
The option "source transport lbtsmx" sets the source's transport to LBT-SMX. </li>
<li>
<p class="startli">The option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtsmxoperation.html#transportlbtsmxtransmissionwindowsizesource">transport_lbtsmx_transmission_window_size (source)</a> sets the size of each Shared Memory Area to 33554432 bytes or 32 MB. This option's value must be a power of 2. If you configured the transmission window size to 25165824 bytes (24 MB) for example, UM logs a warning message and then rounds the value of this option up to the next power of 2 or 33554432 bytes or 32 MB.</p>
<p class="endli"><br />
 </p>
</li>
</ul>
<h2><a class="anchor" id="javacodeexamplesforlbtsmx"></a>
Java Coding for LBT-SMX&nbsp;&nbsp;<small><a href="#javacodeexamplesforlbtsmx">&lt;-</a></small></h2>
<p>Java-based SMX works by wrapping the shared memory area in a <a href="https://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html">ByteBuffer</a> object. This lets the sender call the put methods to build your application message directly in the shared memory, and the receiver calls the get methods to extract the message directly from the shared memory.</p>
<p>Here are the SMX-specific APIs in Java: </p><ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMSource.html#aa3b22f5397febbd6b8bdabdf69c7ab76">LBMSource.getMessagesBuffer()</a> - obtains a reference to the source's ByteBuffer, which does not change for the lifetime of the source object. </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMSource.html#a030f598cdedc72194eb7eeaa80654f48">LBMSource.acquireMessageBufferPosition()</a> - obtains an offset into the source's ByteBuffer for a new message of the specified length. </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMSource.html#a33bd5aff25d81c59b88b679475bffb38">LBMSource.messageBuffersComplete()</a> - informs UM that one or more acquired messages are complete and ready to be delivered to receivers. </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMSource.html#a1e36494baf4946296b674c49aeadfbae">LBMSource.messageBuffersCompleteAndAcquirePosition()</a> - a convenience function that is the same as calling messageBuffersComplete() followed immediately by acquireMessageBufferPosition(). </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMSource.html#a58fdb6755ddf1d2cde693defea57912b">LBMSource.messageBuffersCancel()</a> - cancels all message buffers acquired but not yet completed. </li>
</ul>
<p>Notice that while the normal source send can accept either a byte array or a ByteBuffer, the Java SMX-specific APIs only accept a ByteBuffer. Also note that the ByteBuffer does not necessarily start at position 0. You must call acquireMessageBufferPosition() to determine the offset.</p>
<p>The Java example programs <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/java_example.tag:../java_example/" href="../java_example/index.html#examplelbmlatping_java">Example lbmlatping.java</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/java_example.tag:../java_example/" href="../java_example/index.html#examplelbmlatpong_java">Example lbmlatpong.java</a> illustrates how a Java-based SMX source and receiver is written.</p>
<p>For message reception, see the "onReceive" function. Note that there is no SMX-specific code. However, to maintain high performance, the user should call <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMSource.html#aa3b22f5397febbd6b8bdabdf69c7ab76">LBMSource.getMessagesBuffer()</a> to obtain direct access to the source's ByteBuffer. The position and limit set according to the message to be read.</p>
<p>To save on some front-end latency, the "lat" ping/pong programs pre-acquire a buffer which is filled in when a messages needs to be sent (the call to <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMSource.html#a030f598cdedc72194eb7eeaa80654f48">src.acquireMessageBufferPosition()</a>). After each send, another buffer is acquired for the next (future) message (the call to <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMSource.html#a1e36494baf4946296b674c49aeadfbae">src.messageBuffersCompleteAndAcquirePosition()</a>). This moves the overhead of acquiring a message buffer to <em>after</em> the message was sent.</p>
<p><b>Batching</b></p>
<p>SMX does not support the normal UM feature <a class="el" href="architecture.html#implicitbatching">Implicit Batching</a>. However, it does support a method of <a class="el" href="architecture.html#intelligentbatching">Intelligent Batching</a> whereby multiple messages may be added to the source's ByteBuffer before being released to UM for delivery.</p>
<p>Note that unlike network-based transports, batching will give only minor benefits for SMX, mostly in the form of reduced memory contention.</p>
<div class="fragment"><div class="line"><span class="comment">/* Acquire a position in the buffer */</span></div><div class="line">buf.position(src.acquireMessageBufferPosition(msglen, 0));</div><div class="line">... <span class="comment">/* Construct a message in &quot;buf&quot;. */</span></div><div class="line"></div><div class="line">buf.position(src.acquireMessageBufferPosition(msglen, 0));</div><div class="line">... <span class="comment">/* Construct a second message in &quot;buf&quot;. */</span></div><div class="line"></div><div class="line"><span class="comment">/* Tell UM that all acquired message buffers are now complete. */</span></div><div class="line">src.messageBuffersComplete();</div></div><!-- fragment --><p>Notice that the same ByteBuffer "buf" is used for both messages. This is because it is backed by the entire shared memory buffer. The current position of "buf" is set to the start of the message space acquired by acquireMessageBufferPosition().</p>
<p><b>Non-blocking</b></p>
<p>In the example code presented, calls to acquireMessageBufferPosition() passed zero for flags. This means that the call has the potential to block. Blocking happens if the sender outpaces the slowest receiver and the shared buffer fills. Because of <a class="el" href="fundamentalconcepts.html#transportpacing">receiver pacing</a>, the source must not overwrite sent messages that have not been consumed by one or more subscribed receivers.</p>
<p>It is also possible to pass LBM.SRC_NONBLOCK as a flag to acquireMessageBufferPosition(). In that case, acquireMessageBufferPosition() will immediately return -1 if the shared buffer does not have enough space for the request.</p>
<div class="fragment"><div class="line">pos = src.acquireMessageBufferPosition(msgLength, flags);</div><div class="line"><span class="keywordflow">if</span> (pos == -1) {</div><div class="line">  <span class="comment">/* Can&#39;t send the message yet. Handle this error. */</span></div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> {</div><div class="line">  <span class="comment">/* Successful acquisition, set up buffer. */</span></div><div class="line">  buf.position(pos);</div><div class="line">  ... <span class="comment">/* Construct a message in &quot;buf&quot;. */</span></div><div class="line">  <span class="comment">/* Tell UM that all acquired message buffers are now complete. */</span></div><div class="line">  src.messageBuffersComplete();</div><div class="line">}</div></div><!-- fragment --><p>For performance reasons, acquireMessageBufferPosition() does not throw LBMEWouldBlock exceptions, like the standard send APIs do.</p>
<p><b>Reduce Overhead</b></p>
<p>Normally, UM allows an application to add multiple receiver callbacks for the same topic receiver. This adds a small amount of overhead for a feature that is not used very often. This overhead can be eliminated by setting the "single receiver callback" attribute when creating the receiver object. This is done by calling <a href="../DotNetAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMReceiverAttributes.html#ae29ba2851a3bb0f19866199390ab1ff3">LBMReceiverAttributes.enableSingleReceiverCallback()</a>.</p>
<div class="fragment"><div class="line">LBMReceiverAttributes rattr = <span class="keyword">new</span> LBMReceiverAttributes();</div><div class="line">rattr.enableSingleReceiverCallback(<span class="keyword">true</span>);</div><div class="line">LBMTopic topic = ctx.lookupTopic(<span class="stringliteral">&quot;lbmpong/pong&quot;</span>, rattr);</div><div class="line"></div><div class="line">rcv = <span class="keyword">new</span> LBMReceiver(ctx, topic, <span class="keyword">new</span> LBMReceiverCallback(onReceive), null);</div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="netcodeexamplesforlbtsmx"></a>
.NET Coding for LBT-SMX&nbsp;&nbsp;<small><a href="#netcodeexamplesforlbtsmx">&lt;-</a></small></h2>
<p>For most of UM functionality, the Java and .NET APIs are used almost identically. However, given SMX's latency requirements, we took advantage of some .NET capabilities that don't exist in Java, resulting in a different set of functions. In particular, instead of wrapping the shared memory area in a ByteBuffer, the .NET SMX API uses a simple IntPtr to provide a pointer directly into the shared memory area.</p>
<p>Here are the SMX-specific APIs in .NET: </p><ul>
<li>
<a href="../DotNetAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMSource.html#aca4f01b286e57aa59a0d5f97f64c8fa3">LBMSource.buffAcquire()</a> - obtains a pointer into the source's shared buffer for a new message of the specified length. </li>
<li>
<a href="../DotNetAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMSource.html#a0a09f48d1e0087425dbca93432998304">LBMSource.buffsComplete()</a> - informs UM that one or more acquired messages are complete and ready to be delivered to receivers. </li>
<li>
<a href="../DotNetAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMSource.html#acf5a0d7ecdc818a071cd38fb0e3d0aed">LBMSource.buffsCompleteAndAcquire()</a> - a convenience function that is the same as calling buffsComplete() followed immediately by acquireMessageBufferPosition(). </li>
<li>
<a href="../DotNetAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMSource.html#a3afd1b714f0922e27db7f9cf8ed244fc">LBMSource.buffsCancel()</a> - cancels all message buffers acquired but not yet completed. </li>
<li>
<a href="../DotNetAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMMessage.html#a174e6f4f8ec8c8ab7e6c316263d645c3">LBMMessage.dataPointerSafe()</a> - Returns an IntPtr into the shared memory at the start of the message. </li>
</ul>
<p>Notice that while the normal source send can accept either a byte array or a ByteBuffer, the .NET SMX-specific APIs only work with an IntPtr. This is because the application builds the message directly in the shared memory.</p>
<p>The .NET example programs <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/dotnet_example.tag:../dotnet_example/" href="../dotnet_example/index.html#examplelbmlatping_cs">Example lbmlatping.cs</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/dotnet_example.tag:../dotnet_example/" href="../dotnet_example/index.html#examplelbmlatpong_cs">Example lbmlatpong.cs</a> illustrates how a .NET-based SMX source and receiver is written.</p>
<p>For message reception, see the "onReceive" function in <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16/doc/Design/dotnet_example.tag:../dotnet_example/" href="../dotnet_example/index.html#examplelbmpong_cs">Example lbmpong.cs</a>. Note that there doesn't need to be any SMX-specific code. However, to maintain high performance, the user should call <a href="../DotNetAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMMessage.html#a174e6f4f8ec8c8ab7e6c316263d645c3">LBMMessage.dataPointerSafe()</a> - to obtain direct access to the source's shared memory.</p>
<p>To save on some front-end latency, the "lat" ping/pong programs pre-acquire a buffer which is filled in when a messages needs to be sent (the call to source.buffAcquire()). After each send, another buffer is acquired for the next (future) message (the call to source.buffsCompleteAndAcquire()). This moves the overhead of acquiring a message buffer to <em>after</em> the message was sent.</p>
<p><b>Batching</b></p>
<p>SMX does not support the normal UM feature <a class="el" href="architecture.html#implicitbatching">Implicit Batching</a>. However, it does support a method of <a class="el" href="architecture.html#intelligentbatching">Intelligent Batching</a> whereby multiple messages may be added to the source's shared memory before being released to UM for delivery.</p>
<p>Note that unlike network-based transports, batching will give only minor benefits for SMX, mostly in the form of reduced memory contention.</p>
<div class="fragment"><div class="line"><span class="comment">/* bufferAcquired was already set up earlier. */</span></div><div class="line">... <span class="comment">/* Construct first message at &quot;bufferAcquired&quot;. */</span></div><div class="line"></div><div class="line">source.buffAcquire(out bufferAcquired, (uint)buffer.Length, 0);</div><div class="line">... <span class="comment">/* Construct second message at &quot;bufferAcquired&quot;. */</span></div><div class="line"></div><div class="line"><span class="comment">/* Send both messages, and set up &quot;bufferAcquired&quot; for next message. */</span></div><div class="line">source.buffsCompleteAndAcquire(out bufferAcquired, (uint)buffer.Length, 0);</div><div class="line"></div><div class="line"><span class="comment">/* Tell UM that all acquired message buffers are now complete. */</span></div><div class="line">src.buffsComplete();</div></div><!-- fragment --><p><b>Non-blocking</b></p>
<p>In the example code presented, calls to buffAcquire() and buffsCompleteAndAcquire() are passed zero for flags. This means that the call has the potential to block. Blocking happens if the sender outpaces the slowest receiver and the shared buffer fills. Because of <a class="el" href="fundamentalconcepts.html#transportpacing">receiver pacing</a>, the source must not overwrite sent messages that have not been consumed by one or more subscribed receivers.</p>
<p>It is also possible to pass LBM.SRC_NONBLOCK as a flag to buffAcquire(). In that case, buffAcquire() will immediately return -1 if the shared buffer does not have enough space for the request.</p>
<div class="fragment"><div class="line">err = src.buffAcquire(out writeBuff, (uint)msglen, LBM.SRC_NONBLOCK);</div><div class="line"><span class="keywordflow">if</span> (err == -1) {</div><div class="line">  <span class="comment">/* Can&#39;t send the message yet. Handle this error. */</span></div><div class="line">}</div><div class="line"><span class="keywordflow">else</span> {</div><div class="line">  <span class="comment">/* Successful acquisition, set up buffer. */</span></div><div class="line">  ... <span class="comment">/* Construct a message in &quot;writeBuff&quot;. */</span></div><div class="line">  <span class="comment">/* Tell UM that all acquired message buffers are now complete. */</span></div><div class="line">  src.buffsComplete();</div><div class="line">}</div></div><!-- fragment --><p>For performance reasons, buffsComplete() does not throw LBMEWouldBlock exceptions, like the standard send APIs do.</p>
<p><b>Reduce Overhead</b></p>
<p>Normally, UM allows an application to add multiple receiver callbacks for the same topic receiver. This adds a small amount of overhead for a feature that is not used very often. This overhead can be eliminated by setting the "single receiver callback" attribute when creating the receiver object. This is done by calling <a href="../DotNetAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMReceiverAttributes.html#ae29ba2851a3bb0f19866199390ab1ff3">LBMReceiverAttributes.enableSingleReceiverCallback()</a>.</p>
<div class="fragment"><div class="line">LBMReceiverAttributes rattr = <span class="keyword">new</span> LBMReceiverAttributes();</div><div class="line">rattr.enableSingleReceiverCallback(<span class="keyword">true</span>);</div><div class="line">LBMTopic topic = ctx.lookupTopic(<span class="stringliteral">&quot;lbmpong/pong&quot;</span>, rattr);</div><div class="line"></div><div class="line">rcv = <span class="keyword">new</span> LBMReceiver(ctx, topic, <span class="keyword">new</span> LBMReceiverCallback(onReceive), null);</div></div><!-- fragment --><p><br />
 </p>
<h2><a class="anchor" id="lbtsmxresourcemanager"></a>
LBT-SMX Resource Manager&nbsp;&nbsp;<small><a href="#lbtsmxresourcemanager">&lt;-</a></small></h2>
<p>Deleting an SMX source or deleting an SMX receiver reclaims the shared memory area and locks allocated by the SMX source or receiver. However, if an ungraceful exit from a process occurs, global resources remain allocated but unused. To address this possibility, the LBT-SMX Resource Manager maintains a resource allocation database with a record for each global resource (memory or semaphore) allocated or freed. You can use the LBT-SMX Resource Manager to discover and reclaim resources. See the three example outputs below.</p>
<p><b>Displaying Resources</b></p>
<pre class="fragment">$&gt; lbtsmx_resource_manager
Displaying Resources (to reclaim you must type '-reclaim' exactly)

--Memory Resources--
Memory resource: Process ID: 24441 SessionID: ab569cec XportID: 20001

--Semaphore Resources-- Semaphore key: 0x68871d75
Semaphore resource Index 0: reserved

Semaphore resource: Process ID: 24441 Sem Index: 1
Semaphore resource: Process ID: 24436 Sem Index: 2
</pre><p><b>Reclaiming Unused Resources</b></p>
<dl class="section warning"><dt>Warning</dt><dd>This operation should never be done while SMX-enabled applications or daemons are running. If you have lost or unused resources that need to be reclaimed, you should exit all SMX applications prior to running this command.</dd></dl>
<pre class="fragment">$&gt; lbtsmx_resource_manager -reclaim
Reclaiming Resources
Process 24441 not found: reclaiming Memory resource (SessionID: ab569cec XPortID: 20001)
Process 24441 not found: reclaiming Semaphore resource: Key: 0x68871d75 Sem Index: 1
Process 24436 not found: reclaiming Semaphore resource: Key: 0x68871d75 Sem Index: 2
</pre><p><br />
 </p>
<h1><a class="anchor" id="transportbroker"></a>
Transport Broker&nbsp;&nbsp;<small><a href="#transportbroker">&lt;-</a></small></h1>
<p>With the UMQ product, you use the '<b>broker</b>' transport to send messages from a source to a Queuing Broker, or from a Queuing Broker to a receiver.</p>
<p>The broker's <a class="el" href="fundamentalconcepts.html#transportpacing">Transport Pacing</a> is receiver-paced, but only between the source and the broker. There is no end-to-end pacing with queuing.</p>
<p>When sources or receivers connect to a Queuing Broker, you must use the '<b>broker</b>' transport. You cannot use the '<b>broker</b>' transport with UMS or UMP products.</p>
<p><br />
<br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
</body>
</html>
