<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Concepts Guide: Transport Types</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen_manual.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Concepts Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('transporttypes.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Transport Types </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><br />
 </p>
<h1><a class="anchor" id="transporttcp"></a>
Transport TCP</h1>
<p>The TCP UM transport uses normal TCP connections to send messages from sources to receivers. This is the default transport when it's not explicitly set. TCP is a good choice when:</p>
<ul>
<li>
Flow control is desired. For example, when one or more receivers cannot keep up, you wish to slow down the source. This is a "better late than never" philosophy. </li>
<li>
Equal bandwidth sharing with other TCP traffic is desired. I.e. when it is desired that the source slow down when general network traffic becomes heavy. </li>
<li>
There are few receivers listening to each topic. Multiple receivers for a topic requires multiple transmissions of each message, which places a scaling burden on the source machine and the network. </li>
<li>
The application is not sensitive to latency. Use of TCP as a messaging transport can result in unbounded latency. </li>
<li>
The messages must pass through a restrictive firewall which does not pass multicast traffic. </li>
</ul>
<p>UM's TCP transport includes a Session ID. A UM source using the TCP transport generates a unique, 32-bit non-zero random Session ID for each TCP transport (IP:port) it uses. The source also includes the Session ID in its Topic Resolution advertisement (TIR). When a receiver resolves its topic and discovers the transport information, the receiver also obtains the transport's Session ID. The receiver sends a message to the source to confirm the Session ID.</p>
<p>The TCP Session ID enables multiple receivers for a topic to connect to a source across UM Router(s). In the event of a UM Router failure, UM establishes new topic routes which can cause cached Topic Resolution and transport information to be outdated. Receivers use this cached information to find sources. Session IDs add a unique identifier to the cached transport information. If a receiver tries to connect to a source with outdated transport information, the source recognizes an incorrect Session ID and disconnects the receiver. The receiver can then attempt to reconnect with different cached transport information.</p>
<dl class="section note"><dt>Note</dt><dd>To maintain interoperability between version pre-6.0 receivers and version 6.0 and beyond TCP sources, you can turn off TCP Session IDs with the UM configuration option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransporttcpoperation.html#transporttcpusesessionidsource">transport_tcp_use_session_id (source)</a>.</dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="transportlbtru"></a>
Transport LBT-RU</h1>
<p>The LBT-RU UM transport adds reliable delivery to unicast UDP to send messages from sources to receivers. This provides greater flexibility in the control of latency. For example, the application can further limit latency by allowing the use of arrival order delivery. See the Knowledge Base article, <a href="https://kb.informatica.com/faq/5/Pages/80043.aspx">FAQ: How do arrival-order delivery and in-order delivery affect latency?</a>. Also, LBT-RU is less sensitive to overall network load; it uses source rate controls to limit its maximum send rate.</p>
<p>Since it is based on unicast addressing, LBT-RU can pass through most firewalls. However, it has the same scaling issues as TCP when multiple receivers are present for each topic.</p>
<p>UM's LBT-RU transport includes a Session ID. A UM source using the LBT-RU transport generates a unique, 32-bit non-zero random Session ID for each transport it uses. The source also includes the Session ID in its Topic Resolution advertisement (TIR). When a receiver resolves its topic and discovers the transport information, the receiver also obtains the transport's Session ID.</p>
<p>The LBT-RU Session ID enables multiple receivers for a topic to connect to a source across UM Router(s). In the event of a UM Router failure, UM establishes new topic routes which can cause cached Topic Resolution and transport information to be outdated. Receivers use this cached information to find sources. Session IDs add a unique identifier to the cached transport information. If a receiver tries to connect to a source with outdated transport information, the transport drops the received data and times out. The receiver can then attempt to reconnect with different cached transport information.</p>
<dl class="section note"><dt>Note</dt><dd>To maintain interoperability between version pre-3.3 receivers and version 3.3 and beyond LBT-RU sources, you can turn off LBT-RU Session IDs with the UM configuration option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtruoperation.html#transportlbtruusesessionidsource">transport_lbtru_use_session_id (source)</a>.</dd>
<dd>
LBT-RU can benefit from hardware acceleration. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportacceleration.html">Transport Acceleration Options</a> in the <a href="../Config/index.html">UM Configuration Guide</a> for more information.</dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="transportlbtrm"></a>
Transport LBT-RM</h1>
<p>The LBT-RM transport adds reliable multicast to UDP to send messages. This provides the maximum flexibility in the control of latency. In addition, LBT-RM can scale effectively to large numbers of receivers per topic using network hardware to duplicate messages only when necessary at wire speed. One limitation is that multicast is often blocked by firewalls.</p>
<p>LBT-RM is a UDP-based, reliable multicast protocol designed with the use of UM and its target applications specifically in mind. The protocol is very similar to <a href="http://www.ietf.org/rfc/rfc3208.txt">PGM</a>, but with changes to aid low latency messaging applications.</p>
<ul>
<li>
Topic Mapping - Several topics may map onto the same LBT-RM session. Thus a multiplexing mechanism to LBT-RM is used to distinguish topic level concerns from LBT-RM session level concerns (such as retransmissions, etc.). Each message to a topic is given a sequence number in addition to the sequence number used at the LBT-RM session level for packet retransmission. </li>
<li>
Negative Acknowledgments (NAKs) - LBT-RM uses NAKs as PGM does. NAKs are unicast to the sender. For simplicity, LBT-RM uses a similar NAK state management approach as PGM specifies. </li>
<li>
Time Bounded Recovery - LBT-RM allows receivers to specify a maximum time to wait for a lost piece of data to be retransmitted. This allows a recovery time bound to be placed on data that has a definite lifetime of usefulness. If this time limit is exceeded and no retransmission has been seen, then the piece of data is marked as an unrecoverable loss and the application is informed. The data stream may continue and the unrecoverable loss will be ordered as a discrete event in the data stream just as a normal piece of data. </li>
<li>
Flexible Delivery Ordering - LBT-RM receivers have the option to have the data for an individual topic delivered "in order" or "arrival order". Messages delivered "in order" will arrive in sequence number order to the application. Thus loss may delay messages from being delivered until the loss is recovered or unrecoverable loss is determined. With "arrival-order" delivery, messages will arrive at the application as they are received by the LBT-RM session. Duplicates are ignored and lost messages will have the same recovery methods applied, but the ordering may not be preserved. Delivery order is a topic level concern. Thus loss of messages in one topic will not interfere or delay delivery of messages in another topic. </li>
<li>
Session State Advertisements - In PGM, SPM packets are used to advertise session state and to perform PGM router assist in the routers. For LBT-RM, these advertisements are only used when data are not flowing. Once data stops on a session, advertisements are sent with an exponential back-off (to a configurable maximum interval) so that the bandwidth taken up by the session is minimal. </li>
<li>
Sender Rate Control - LBT-RM can control a sender's rate of injection of data into the network by use of a rate limiter. This rate is configurable and will back pressure the sender, not allowing the application to exceed the rate limit it has specified. In addition, LBT-RM senders have control over the rate of retransmissions separately from new data. This allows sending application to guarantee a minimum transmission rate even in the face of massive loss at some or all receivers. </li>
<li>
Low Latency Retransmissions - LBT-RM senders do not mandate the use of NCF packets as PGM does. Because low latency retransmissions is such an important feature, LBT-RM senders by default send retransmissions immediately upon receiving a NAK. After sending a retransmission, the sender ignores additional NAKs for the same data and does not repeatedly send NCFs. The oldest data being requested in NAKs has priority over newer data so that if retransmissions are rate controlled, then LBT-RM sends the most important retransmissions as fast as possible. </li>
</ul>
<p>UM's LBT-RM transport includes a Session ID. A UM source using the LBT-RM transport generates a unique, 32-bit non-zero random Session ID for each transport it uses. The source also includes the Session ID in its Topic Resolution advertisement (TIR). When a receiver resolves its topic and discovers the transport information, the receiver also obtains the transport's Session ID.</p>
<dl class="section note"><dt>Note</dt><dd>LBT-RM can benefit from hardware acceleration. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportacceleration.html">Transport Acceleration Options</a> in the <a href="../Config/index.html">UM Configuration Guide</a> for more information.</dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="transportlbtipc"></a>
Transport LBT-IPC</h1>
<p>The LBT-IPC transport is an Interprocess Communication (IPC) UM transport that allows sources to publish topic messages to a shared memory area managed as a static ring buffer from which receivers can read topic messages. Message exchange takes place at memory access speed which can greatly improve throughput when sources and receivers can reside on the same host. LBT-IPC can be either source-paced or receiver-paced.</p>
<p>The LBT-IPC transport uses a "lock free" design that eliminates calls to the Operating System and allows receivers quicker access to messages. An internal validation method enacted by receivers while reading messages from the Shared Memory Area ensures message data integrity. The validation method compares IPC header information at different times to ensure consistent, and therefore, valid message data. Sources can send individual messages or a batch of messages, each of which possesses an IPC header.</p>
<dl class="section note"><dt>Note</dt><dd>Transport LBT-IPC is not supported on the OpenVMSÂ® platform.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="lbtipcsharedmemoryarea"></a>
LBT-IPC Shared Memory Area</h2>
<p>The following diagram illustrates the Shared Memory Area used for LBT-IPC:</p>
<div class="image">
<img src="IPC_Shared_Memory_Layout.png" alt="IPC_Shared_Memory_Layout.png"/>
</div>
 <p><b>Header</b></p>
<p>The Header contains information about the shared memory area resource.</p>
<ul>
<li>
Shared Lock - shared receiver pool semaphore (mutex on Microsoft Windows) to ensure mutually exclusive access to the receiver pool. </li>
<li>
Version - LBT-IPC version number which is independent of any UM product version number. </li>
<li>
Buffer Length - size of shared memory area. </li>
<li>
Receiver Map Size - Number of entries available in the Receiver Pool which you configure with the source option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtipcoperation.html#transportlbtipcmaximumreceiverspertransportsource">transport_lbtipc_maximum_receivers_per_transport (source)</a>. </li>
<li>
New Client Flag - set by the receiver after setting its Receiver Pool entry and before releasing the Shared Lock. Indicates to the source that a new receiver has joined the transport. </li>
<li>
Receiver Paced - Indicates if you've configured the transport for receiver-pacing. </li>
<li>
Old Message Start - pointer indicating messages that may be reclaimed. </li>
<li>
New Message Start - pointer indicating messages that may be read. </li>
<li>
New Message End - pointer indicating the end of messages that may be read, which may not be the same as the Old Message Start pointer. </li>
</ul>
<p><b>Receiver Pool</b></p>
<p>The receiver pool is a collection of receiver connections maintained in the Shared Memory Area. The source reads this information if you've configured receiver-pacing to determine if a message can be reclaimed or to monitor a receiver. Each receiver is responsible for finding a free entry in the pool and marking it as used.</p>
<ul>
<li>
In Use flag - set by receiver while holding the Shared Lock, which effectively indicates the receiver has joined the transport session. Using the Shared Lock ensures mutually exclusive access to the receiver connection pool. </li>
<li>
Oldest Message Start - set by receiver after reading a message. If you enable receiver-pacing the source reads it to determine if message memory can be reclaimed. </li>
<li>
Monitor Shared Lock - checked by the source to monitor a receiver (semaphore on Linux, event on Microsoft Windows). </li>
<li>
Signal Shared Lock - Set by source to notify receiver that new data has been written. (semaphore on Linux, mutex on Microsoft Windows) If you set <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtipcoperation.html#transportlbtipcreceiverthreadbehaviorcontext">transport_lbtipc_receiver_thread_behavior (context)</a> to busy_wait, the receiver sets this semaphore to zero and the source does not notify. </li>
</ul>
<p><b>Source-to-Receiver Message Buffer</b></p>
<p>This area contains message data. You specify the size of the shared memory area with a source option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtipcoperation.html#transportlbtipctransmissionwindowsizesource">transport_lbtipc_transmission_window_size (source)</a>. The size of the shared memory area cannot exceed your platform's shared memory area maximum size. UM stores the memory size in the shared memory area's header. The Old Message Start and New Message Start point to positions in this buffer.</p>
<p><br />
 </p>
<h2><a class="anchor" id="sourcesandlbtipc"></a>
Sources and LBT-IPC</h2>
<p>When you create a source with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ab8dd76271bf9df7a5f88476d431f523e">lbm_src_create()</a> and you've set the transport option to IPC, UM creates a shared memory area object. UM assigns one of the transport IDs to this area specified with the UM context configuration options, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtipcoperation.html#transportlbtipcidhighcontext">transport_lbtipc_id_high (context)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtipcoperation.html#transportlbtipcidlowcontext">transport_lbtipc_id_low (context)</a>. You can also specify a shared memory location outside of this range with a source configuration option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtipcoperation.html#transportlbtipcidsource">transport_lbtipc_id (source)</a>, to prioritize certain topics, if needed.</p>
<p>UM names the shared memory area object according to the format, LBTIPC_x_d where x is the hexadecimal Session ID and d is the decimal Transport ID. Example names are <b>LBTIPC_42792ac_20000</b> or <b>LBTIPC_66e7c8f6_20001</b>. Receivers access a shared memory area with this object name to receive (read) topic messages.</p>
<p>Using the configuration option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtipcoperation.html#transportlbtipcbehaviorsource">transport_lbtipc_behavior (source)</a>, you can choose source-paced or receiver-paced message transport. See Transport LBT-IPC Operation Options in the <a href="../Config/index.html">UM Configuration Guide</a>.</p>
<p><b>Sending over LBT-IPC</b></p>
<p>To send on a topic (write to the shared memory area) the source writes to the Shared Memory Area starting at the Oldest Message Start position. It then increments each receiver's Signal Lock if the receiver has not set this to zero.</p>
<p><br />
 </p>
<h2><a class="anchor" id="receiversandlbtipc"></a>
Receivers and LBT-IPC</h2>
<p>Receivers operate identically to receivers for all other UM transports. A receiver can actually receive topic messages from a source sending on its topic over TCP, LBT-RU or LBT-RM and from a second source sending on LBT-IPC with out any special configuration. The receiver learns what it needs to join the LBT-IPC session through the topic advertisement.</p>
<p>The configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtipcoperation.html#transportlbtipcreceiverthreadbehaviorcontext">transport_lbtipc_receiver_thread_behavior (context)</a> controls the IPC receiving thread behavior when there are no messages available. The default behavior, '<b>pend</b>', has the receiving thread pend on a semaphore for a new message. When the source adds a message, it posts to each pending receiver's semaphore to wake the receiving thread up. Alternatively, '<b>busy_wait</b>' can be used to prevent the receiving thread going to sleep. In this case, the source does not need to post to the receiver's semaphore. It simply adds the message to shared memory, which the looping receiving thread detects with the lowest possible latency.</p>
<p>Although '<b>busy_wait</b>' has the lowest latency, it has the drawback of consuming 100% of a CPU core during periods of idleness. This limits the number of IPC data flows that can be used on a given machine to the number of available cores. (If more busy looping receivers are deployed than there are cores, then receivers can suffer 10 millisecond time sharing quantum latencies.)</p>
<p>For application that cannot afford '<b>busy_wait</b>', there is another configuration option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtipcoperation.html#transportlbtipcpendbehaviorlingerloopcountcontext">transport_lbtipc_pend_behavior_linger_loop_count (context)</a>, which allows a middle ground between '<b>pend</b>' and '<b>busy_wait</b>'. The receiver is still be configured as '<b>pend</b>', but instead of going to sleep on the semaphore <em>immediately</em> upon emptying the shared memory, it busy loops for the configured number of times. If a new message arrives, it processes the message immediately without a sleep/wakeup. This can be very useful during bursts of high incoming message rates to reduce latency. By making the loop count large enough to cover the incoming message interval during a burst, only the first message of the burst will incur the wakeup latency.</p>
<p><b>Topic Resolution and LBT-IPC</b></p>
<p>Topic resolution operates identically with LBT-IPC as other UM transports albeit with a new advertisement type, LBMIPC. Advertisements for LBT-IPC contain the Transport ID, Session ID and Host ID. Receivers obtain LBT-IPC advertisements in the normal manner (resolver cache, advertisements received on the multicast resolver address:port and responses to queries.) Advertisements for topics from LBT-IPC sources can reach receivers on different machines if they use the same topic resolution configuration, however, those receivers silently ignore those advertisements since they cannot join the IPC transport. See <a class="el" href="transporttypes.html#sendingtobothlocalandremotereceivers">Sending to Both Local and Remote Receivers</a>.</p>
<p><b>Receiver Pacing</b></p>
<p>Although receiver pacing is a source behavior option, some different things must happen on the receiving side to ensure that a source does not reclaim (overwrite) a message until all receivers have read it. When you use the default <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtipcoperation.html#transportlbtipcbehaviorsource">transport_lbtipc_behavior (source)</a> (source-paced), each receiver's Oldest Message Start position in the Shared Memory Area is private to each receiver. The source writes to the Shared Memory Area independently of receivers' reading. For receiver-pacing, however, all receivers share their Oldest Message Start position with the source. The source will not reclaim a message until all receivers have successfully read that message.</p>
<p><b>Receiver Monitoring</b></p>
<p>To ensure that a source does not wait on a receiver that is not running, the source monitors a receiver via the Monitor Shared Lock allocated to each receiving context. (This lock is in addition to the semaphore already allocated for signaling new data.) A new receiver takes and holds the Monitor Shared Lock and releases the resource when it dies. If the source is able to obtain the resource, it knows the receiver has died. The source then clears the receiver's In Use flag in it's Receiver Pool Connection.</p>
<p><br />
 </p>
<h2><a class="anchor" id="similaritieswithotherumtransports"></a>
Similarities with Other UM Transports</h2>
<p>Although no actual network transport occurs, IPC functions in much the same way as if you send packets across the network as with other UM transports.</p>
<ul>
<li>
If you use a range of LBT-IPC transport IDs, UM assigns multiple topics sent by multiple sources to all the transport sessions in a round robin manner just like other UM transports. </li>
<li>
Transport sessions assume the configuration option values of the first source assigned to the transport session. </li>
<li>
Sources are subject to message batching. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="differencesfromotherumtransports"></a>
Differences from Other UM Transports</h2>
<ul>
<li>
Unlike LBT-RM which uses a transmission window to specify a buffer size to retain messages in case they must be retransmitted, LBT-IPC uses the transmission window option to establish the size of the shared memory. </li>
<li>
LBT-IPC does not retransmit messages. Since LBT-IPC transport is essentially a memory write/read operation, messages should not be be lost in transit. However, if the shared memory area fills up, new messages overwrite old messages and the loss is absolute. No retransmission of old messages that have been overwritten occurs. </li>
<li>
Receivers also do not send NAKs when using LBT-IPC. </li>
<li>
LBT-IPC does not support <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#ordereddeliveryreceiver">ordered_delivery (receiver)</a> options. However, if you set <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#ordereddeliveryreceiver">ordered_delivery (receiver)</a> 1 or -1, LBT-IPC reassembles any large messages. </li>
<li>
LBT-IPC does not support Rate Control. </li>
<li>
LBT-IPC creates a separate receiver thread in the receiving context. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="sendingtobothlocalandremotereceivers"></a>
Sending to Both Local and Remote Receivers</h2>
<p>A source application that wants to support both local and remote receivers should create two UM Contexts with different topic resolution configurations, one for IPC sends and one for sends to remote receivers. Separate contexts allows you to use the same topic for both IPC and network sources. If you simply created two source objects (one IPC, one say LBT-RM) in the same UM Context, you would have to use separate topics and suffer possible higher latency because the sending thread would be blocked for the duration of two send calls.</p>
<p>A UM source will never automatically use IPC when the receivers are local and a network transport for remote receivers because the discovery of a remote receiver would hurt the performance of local receivers. An application that wants transparent switching can implement it in a simple wrapper.</p>
<p><br />
 </p>
<h2><a class="anchor" id="lbtipcconfigurationexample"></a>
LBT-IPC Configuration Example</h2>
<p>The following diagram illustrates how sources and receivers interact with the shared memory area used in the LBT-IPC transport:</p>
<div class="image">
<img src="IPC_Objects.png" alt="IPC_Objects.png"/>
</div>
 <p>In the diagram above, 3 sources send (write) to two Shared Memory Areas while four receivers in two different contexts receive (read) from the areas. The assignment of sources to Shared Memory Areas demonstrate UM's round robin method. UM assigns the source sending on Topic A to Transport 20001, the source sending on Topic B to Transport 20002 and the source sending on Topic C back to the top of the transport ID range, 20001.</p>
<p>The diagram also shows the UM configuration options that set up this scenario:</p>
<ul>
<li>
The options <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtipcoperation.html#transportlbtipcidhighcontext">transport_lbtipc_id_high (context)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtipcoperation.html#transportlbtipcidlowcontext">transport_lbtipc_id_low (context)</a> establish the range of Transport IDs between 20001 and 20002. </li>
<li>
The option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#transportsource">transport (source)</a> is used to set the source's transport to LBT-IPC. </li>
<li>
The option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtipcoperation.html#transportlbtipctransmissionwindowsizesource">transport_lbtipc_transmission_window_size (source)</a> sets the size of each Shared Memory Area to 24 MB. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="requiredprivileges"></a>
Required privileges</h2>
<p>LBT-IPC requires no special operating system authorities, except on Microsoft Windows Vista and Microsoft Windows Server 2008, which require Administrator privileges. In addition, on Microsoft Windows XP, applications must be started by the same user, however, the user is not required to have administrator privileges. In order for applications to communicate with a service, the service must use a user account that has Administrator privileges.</p>
<p><br />
 </p>
<h2><a class="anchor" id="hostresourceusageandlimits"></a>
Host Resource Usage and Limits</h2>
<p>LBT-IPC contexts and sources consume host resources as follows:</p>
<ul>
<li>
Per Source - 1 shared memory segment, 1 shared lock (semaphore on Linux, mutex on Microsoft Windows) </li>
<li>
Per Receiving Context - 2 shared locks (semaphores on Linux, one event and one mutex on Microsoft Windows) </li>
</ul>
<p>Across most operating system platforms, these resources have the following limits. </p><ul>
<li>
4096 shared memory segments, though some platforms use different limits </li>
<li>
32,000 shared semaphores (128 shared semaphore sets * 250 semaphores per set) </li>
</ul>
<p>Consult your operating system documentation for specific limits per type of resource. Resources may be displayed and reclaimed using the <a class="el" href="transporttypes.html#lbtipcresourcemanager">LBT-IPC Resource Manager</a>. See also the KB article <a href="https://kb.informatica.com/faq/5/Pages/80201.aspx">Managing LBT-IPC Host Resources</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="lbtipcresourcemanager"></a>
LBT-IPC Resource Manager</h2>
<p>Deleting an IPC source or deleting an IPC receiver reclaims the shared memory area and locks allocated by the IPC source or receiver. However, if a less than graceful exit from a process occurs, global resources remain allocated but unused. To address this possibility, the LBT-IPC Resource Manager maintains a resource allocation database with a record for each global resource (memory or semaphore) allocated or freed. You can use the LBT-IPC Resource Manager to discover and reclaim resources. See the three example outputs below.</p>
<p><b>Displaying Resources</b></p>
<pre class="fragment">$&gt; lbtipc_resource_manager
Displaying Resources (to reclaim you must type '-reclaim' exactly)

--Memory Resources--
Memory resource: Process ID: 24441 SessionID: ab569cec XportID: 20001

--Semaphore Resources-- Semaphore key: 0x68871d75
Semaphore resource Index 0: reserved

Semaphore resource: Process ID: 24441 Sem Index: 1
Semaphore resource: Process ID: 24436 Sem Index: 2
</pre><p><b>Reclaiming Unused Resources</b></p>
<pre class="fragment">$&gt; lbtipc_resource_manager -reclaim
Reclaiming Resources
Process 24441 not found: reclaiming Memory resource (SessionID: ab569cec XPortID: 20001)
Process 24441 not found: reclaiming Semaphore resource: Key: 0x68871d75 Sem Index: 1
Process 24436 not found: reclaiming Semaphore resource: Key: 0x68871d75 Sem Index: 2
</pre><p><br />
 </p>
<h1><a class="anchor" id="transportlbtsmx"></a>
Transport LBT-SMX</h1>
<p>The LBT-SMX (shared memory acceleration) transport is an Interprocess Communication (IPC) transport you can use for the lowest latency message Streaming. LBT-SMX is faster than the LBT-IPC transport. Like LBT-IPC, sources can publish topic messages to a shared memory area from which receivers can read topic messages. Unlike LBT-IPC, the native APIs for the LBT-SMX transport are not thread safe and do not support all UM features such as message batching or fragmentation.</p>
<p>You can use either the native LBT-SMX API calls, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8a56e2f08924d25caea26d205cf730c5">lbm_src_buff_acquire()</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a4f857abe9088918c618cdd248ccf7d83">lbm_src_buffs_complete()</a> to send over LBT-SMX or you can use lbm_src_send_*() API calls. The existing send APIs are thread safe with SMX, but they incur a synchronization overhead and thus are slower than the native LBT-SMX API calls.</p>
<p>LBT-SMX operates on the following Ultra Messaging 64-bit packages:</p>
<ul>
<li>
SunOS-5.10-amd64 </li>
<li>
Linux-glibc-2.5-x86_64 </li>
<li>
Win2k-x86_64 </li>
</ul>
<p>The example applications, <a href="../example/lbmlatping.c">lbmlatping.c</a> and <a href="../example/lbmlatpong.c">lbmlatpong.c</a> show how to use the C LBT-SMX API calls. For Java, see <a href="../java_example/lbmlatpong.java">lbmlatpong.java</a> and <a href="../java_example/lbmlatpong.java">lbmlatpong.java</a>. For .NET, see <a href="../dotnet_example/lbmlatpong.cs">lbmlatpong.cs</a> and <a href="../dotnet_example/lbmlatpong.cs">lbmlatpong.cs</a>.</p>
<p>Other example applications can use the LBT-SMX transport with the use of a UM configuration flat file containing '<b>source transport lbtsmx</b>'. You cannot use LBT-SMX with example applications for features not supported by LBT-SMX, such as <b>lbmreq</b>, <b>lbmresp</b>, <b>lbmrcvq</b> or <b>lbmwrcvq</b>.</p>
<p>The LBT-SMX configuration options are similar to the LBT-IPC transport options. See Transport LBT-SMX Operation Options in the <a href="../Config/index.html">UM Configuration Guide</a> for a full explanation of these options.</p>
<p>You can use Automatic Monitoring, UM API retrieve/reset calls, and LBMMON APIs to access LBT-SMX source and receiver transport statistics. To increase performance, the LBT-SMX transport does not collect statistics by default. Set the UM configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtsmxoperation.html#transportlbtsmxmessagestatisticsenabledcontext">transport_lbtsmx_message_statistics_enabled (context)</a> to 1 to enable the collection of transport statistics.</p>
<p><br />
 </p>
<h2><a class="anchor" id="sourcesandlbtsmx"></a>
Sources and LBT-SMX</h2>
<p>When you create a source with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ab8dd76271bf9df7a5f88476d431f523e">lbm_src_create()</a> and you've set the source's transport configuration option to LBT-SMX, UM creates a shared memory area object. UM assigns one of the transport IDs to this area from a range of transport IDs specified with the UM context configuration options, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtsmxoperation.html#transportlbtsmxidhighcontext">transport_lbtsmx_id_high (context)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtsmxoperation.html#transportlbtsmxidlowcontext">transport_lbtsmx_id_low (context)</a>. You can also specify a shared memory location inside or outside of this range with a source configuration option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtsmxoperation.html#transportlbtsmxidsource">transport_lbtsmx_id (source)</a>, to group certain topics in the same shared memory area, if needed. See Transport LBT-SMX Operation Options in the UM Configuration Guide.</p>
<dl class="section note"><dt>Note</dt><dd>For every context created by your application, UM creates an additional shared memory area for control information. The name for these control information memory areas ends with the suffix, _0, which is the Transport ID.</dd></dl>
<p>UM names the shared memory area object according to the format, <b>LBTSMX_x_d</b> where <b>x</b> is the hexadecimal Session ID and <b>d</b> is the decimal Transport ID. Example names are <b>LBTSMX_42792ac_20000</b> or <b>LBTSMX_66e7c8f6_20001</b>. Receivers access a shared memory area with this object name to receive (read) topic messages.</p>
<p>Sending on a topic with the native LBT-SMX APIs requires the two API calls <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8a56e2f08924d25caea26d205cf730c5">lbm_src_buff_acquire()</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a4f857abe9088918c618cdd248ccf7d83">lbm_src_buffs_complete()</a>. A third convenience API, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a661393cae3ab4f8c90d26ce0a27e8d33">lbm_src_buffs_complete_and_acquire()</a>, combines a call to <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a4f857abe9088918c618cdd248ccf7d83">lbm_src_buffs_complete()</a> followed by a call to <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8a56e2f08924d25caea26d205cf730c5">lbm_src_buff_acquire()</a> into one function call to eliminate the overhead of an additional function call.</p>
<p>The native LBT-SMX APIs fail with an appropriate error message if a sending application uses them for a source configured to use a transport other than LBT-SMX.</p>
<dl class="section note"><dt>Note</dt><dd>The native LBT-SMX APIs are not thread safe at the source object or LBT-SMX transport session levels for performance reasons. Applications that use the native API LBT-SMX calls for either the same source or a group of sources that map to the same LBT-SMX transport session must serialize the calls either directly in the application or through their own mutex.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="sendingoverlbtsmxwithnativeapis"></a>
Sending over LBT-SMX with Native APIs</h2>
<p>Sending with LBT-SMX's native API is a two-step process.</p>
<ol>
<li>
<p class="startli">The sending application first calls <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8a56e2f08924d25caea26d205cf730c5">lbm_src_buff_acquire()</a>, which returns a pointer into which the sending application writes the message data.</p>
<p>The pointer points directly into the shared memory region. UM guarantees that the shared memory area has at least the value specified with the len parameter of contiguous bytes available for writing when <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8a56e2f08924d25caea26d205cf730c5">lbm_src_buff_acquire()</a> returns. If your application set the LBM_SRC_NONBLOCK flag with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8a56e2f08924d25caea26d205cf730c5">lbm_src_buff_acquire()</a>, UM returns an LBM_EWOULDBLOCK error condition if the shared memory region does not have enough contiguous space available.</p>
<p>Because LBT-SMX does not support fragmentation, your application must limit message lengths to a maximum equal to the value of the source's configured <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtsmxoperation.html#transportlbtsmxdatagrammaxsizesource">transport_lbtsmx_datagram_max_size (source)</a> option minus 16 bytes for headers.</p>
<p>After the user acquires the pointer into shared memory and writes the message data, the application may call <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8a56e2f08924d25caea26d205cf730c5">lbm_src_buff_acquire()</a> repeatedly to send a batch of messages to the shared memory area. If your application writes multiple messages in this manner, sufficient space must exist in the shared memory area. <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8a56e2f08924d25caea26d205cf730c5">lbm_src_buff_acquire()</a> returns an error if the available shared memory space is less than the size of the next message.</p>
<p class="endli"></p>
</li>
<li>
The sending application calls one of the two following APIs. <ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a4f857abe9088918c618cdd248ccf7d83">lbm_src_buffs_complete()</a>, which publishes the message or messages to all listening receivers. </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a661393cae3ab4f8c90d26ce0a27e8d33">lbm_src_buffs_complete_and_acquire()</a>, which publishes the message or messages to all listening receivers and returns another pointer. </li>
</ul>
</li>
</ol>
<p><br />
 </p>
<h2><a class="anchor" id="sendingoverlbtsmxwithexistingapis"></a>
Sending over LBT-SMX with Existing APIs</h2>
<p>LBT-SMX supports lbm_src_send_* API calls. These API calls are fully thread-safe. The LBT-SMX feature restrictions still apply, however, when using lbm_src_send_* API calls. The lbm_src_send_ex_info_t argument to the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a091b5806bf18d10ebd0d9117e0c70229">lbm_src_send_ex()</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a4d883eaaa22baf81abf21d495f471c8b">lbm_src_sendv_ex()</a> APIs must be NULL when using an LBT-SMX source, because LBT-SMX does not support any of the features that the lbm_src_send_ex_info_t parameter can enable. See <a class="el" href="transporttypes.html#differencesbetweenlbtsmxandotherumtransports">Differences Between LBT-SMX and Other UM Transports</a>.</p>
<p>Since LBT-SMX does not support an implicit batcher or corresponding implicit batch timer, UM flushes all messages for all sends on LBT-SMX transports done with lbm_src_send_* APIs, which is similar to setting the LBM_MSG_FLUSH flag. LBT-SMX also supports the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#afec0ee6822fe721f21c67536660506ea">lbm_src_flush()</a> API call, which behaves like a thread-safe version of <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a4f857abe9088918c618cdd248ccf7d83">lbm_src_buffs_complete()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Users should not use both the native LBT-SMX APIs and the lbm_src_send_* API calls in the same application. Users should choose one or the other type of API for consistency and to avoid thread safety problems.</dd></dl>
<p>The <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a1ba60407fa2bde0997aab6d5a5d2da1a">lbm_src_topic_alloc()</a> API call generates log warnings if the given attributes specify an LBT-SMX transport and enable any of the features that LBT-SMX does not support. The <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a1ba60407fa2bde0997aab6d5a5d2da1a">lbm_src_topic_alloc()</a> call succeeds, but UM does not enable the unsupported features indicated in the log warnings. Other API functions that operate on lbm_src_t objects, such as <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ab8dd76271bf9df7a5f88476d431f523e">lbm_src_create()</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a29d45db8f76835b4ae78f4568c25712f">lbm_src_delete()</a>, or <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a33d3ee1d815f4a51b68653d8a063f87f">lbm_src_topic_dump()</a>, operate with LBT-SMX sources normally.</p>
<p>Because LBT-SMX does not support fragmentation, your application must limit message lengths to a maximum equal to the value of the source's configured <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtsmxoperation.html#transportlbtsmxdatagrammaxsizesource">transport_lbtsmx_datagram_max_size (source)</a> option minus 16 bytes for headers. Any send API calls with a length parameter greater than this configured value fail.</p>
<p><br />
 </p>
<h2><a class="anchor" id="receiversandlbtsmx"></a>
Receivers and LBT-SMX</h2>
<p>Receivers operate identically over LBT-SMX to receivers as all other UM transports. The msg-&gt;data pointer of a delivered lbm_msg_t object points directly into the shared memory region.</p>
<p>The <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a2b7788ff58f9e78bc89ea890dad0cccf">lbm_msg_retain()</a> API function operates differently for LBT-SMX. <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a2b7788ff58f9e78bc89ea890dad0cccf">lbm_msg_retain()</a> creates a full copy of the message in order to access the data outside the receiver callback.</p>
<dl class="section attention"><dt>Attention</dt><dd>You application should not pass the msg-&gt;data pointer to other threads or outside the receiver callback until your application has called <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a2b7788ff58f9e78bc89ea890dad0cccf">lbm_msg_retain()</a> on the message.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Any API calls documented as not safe to call from a context thread callback are also not safe to call from an LBT-SMX receiver thread.</dd></dl>
<p><b>Topic Resolution and LBT-SMX</b></p>
<p>Topic resolution operates identically with LBT-SMX as other UM transports albeit with the advertisement type, LBMSMX. Advertisements for LBT-SMX contain the Transport ID, Session ID, and Host ID. Receivers get LBT-SMX advertisements in the normal manner, either from the resolver cache, advertisements received on the multicast resolver address:port, or responses to queries.</p>
<p><br />
 </p>
<h2><a class="anchor" id="similaritiesbetweenlbtsmxandotherumtransports"></a>
Similarities Between LBT-SMX and Other UM Transports</h2>
<p>Although no actual network transport occurs, SMX functions in much the same way as if you send packets across the network as with other UM transports.</p>
<ul>
<li>
If you use a range of LBT-SMX transport IDs, UM assigns multiple topics sent by multiple sources to all the transport sessions in a round robin manner just like other UM transports. </li>
<li>
Transport sessions assume the configuration option values of the first source assigned to the transport session. </li>
<li>
Source applications and receiver applications based on any of the three available APIs can interoperate with each other. For example, sources created by a C sending application can send to receivers created by a Java receiving application. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="differencesbetweenlbtsmxandotherumtransports"></a>
Differences Between LBT-SMX and Other UM Transports</h2>
<ul>
<li>
Unlike LBT-RM which uses a transmission window to specify a buffer size to retain messages for retransmission, LBT-SMX uses the transmission window option to establish the size of the shared memory. LBT-SMX uses transmission window sizes that are powers of 2. You can set <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtsmxoperation.html#transportlbtsmxtransmissionwindowsizesource">transport_lbtsmx_transmission_window_size (source)</a> to any value, but UM rounds the option value up to the nearest power of 2. </li>
<li>
The largest transmission window size for Java applications is 1 GB. </li>
<li>
LBT-SMX does not retransmit messages. Since LBT-SMX transport is a memory write-read operation, messages should not be lost in transit. No retransmission of old messages that have been overwritten occurs. </li>
<li>
Receivers do not send NAKs when using LBT-SMX. </li>
</ul>
<p><b>You cannot use the following UM features with LBT-SMX:</b></p>
<ul>
<li>
Arrival Order Delivery </li>
<li>
Late Join </li>
<li>
Off Transport Recovery </li>
<li>
Request and Response </li>
<li>
Multi-transport Threads </li>
<li>
Source-side Filtering </li>
<li>
Hot Failover </li>
<li>
Message Properties </li>
<li>
Application Headers </li>
<li>
Implicit and Explicit Message Batching </li>
<li>
Fragmentation and Reassembly </li>
<li>
Immediate Messaging </li>
<li>
Receiver thread behaviors other than "busy_wait" </li>
<li>
Persistent sources </li>
<li>
Queued sources, both brokered and ULB </li>
</ul>
<p>You also cannot use LBT-SMX to send egress traffic from a UM daemon, such as the Persistent Store, UM Router, UM Cache, or UMDS.</p>
<p><br />
 </p>
<h2><a class="anchor" id="lbtsmxconfigurationexample"></a>
LBT-SMX Configuration Example</h2>
<p>The following diagram illustrates how sources and receivers interact with the shared memory area used in the LBT-SMX transport.</p>
<div class="image">
<img src="SMX_Objects.png" alt="SMX_Objects.png"/>
</div>
 <p>In the diagram above, three sources send (write) to two Shared Memory Areas while four receivers in two different contexts receive (read) from the areas. The assignment of sources to Shared Memory Areas demonstrate UM's round robin method. UM assigns the source sending on Topic A to Transport 30001, the source sending on Topic B to Transport 30002 and the source sending on Topic C back to the top of the transport ID range, 30001.</p>
<p>The diagram also shows the UM configuration options that set up this scenario.</p>
<ul>
<li>
The options <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtsmxoperation.html#transportlbtsmxidhighcontext">transport_lbtsmx_id_high (context)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtsmxoperation.html#transportlbtsmxidlowcontext">transport_lbtsmx_id_low (context)</a> establish the range of Transport IDs between 30001 and 30002. </li>
<li>
The option "source transport lbtsmx" sets the source's transport to LBT-SMX. </li>
<li>
<p class="startli">The option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtsmxoperation.html#transportlbtsmxtransmissionwindowsizesource">transport_lbtsmx_transmission_window_size (source)</a> sets the size of each Shared Memory Area to 33554432 bytes or 32 MB. This option's value must be a power of 2. If you configured the transmission window size to 25165824 bytes (24 MB) for example, UM logs a warning message and then rounds the value of this option up to the next power of 2 or 33554432 bytes or 32 MB.</p>
<p class="endli"><br />
 </p>
</li>
</ul>
<h2><a class="anchor" id="javacodeexamplesforlbtsmx"></a>
Java Code Examples for LBT-SMX</h2>
<p>The Java code examples for LBT-SMX send and receive one million messages. Start the receiver example application before you start the source example application.</p>
<p><b>Java Source Example</b></p>
<pre class="fragment">import java.nio.ByteBuffer; import com.latencybusters.lbm.*;

public class SimpleSrc
{
  private LBMContext ctx;
  private LBMSource src;

  public static void main(String[] args)
  {
    try
    {
      SimpleSrc test = new SimpleSrc();
      test.sendMessages();
      System.out.println("Send Complete");
    } catch (LBMException ex)
    {
      System.err.println(ex.getMessage());
      ex.printStackTrace();
    }
  }  /* main */

  public SimpleSrc() throws LBMException
  {
    ctx = new LBMContext();
    LBMSourceAttributes sattr = new LBMSourceAttributes();
    sattr.setValue("transport", "lbtsmx");
    LBMTopic top = ctx.allocTopic("SimpleSmx", sattr);
    src = ctx.createSource(top);
  }

  public void sendMessages() throws LBMException
  {
    /* Keep a reference to the source buffer, which does not change */
    final ByteBuffer srcBuffer = src.getMessagesBuffer();
    /* Sends will block waiting for receivers */
    final int flags = LBM.SRC_BLOCK;
    final int msgLength = 8;
    int pos;

    /* Delay a second to let topic resolution complete. */
    try { Thread.sleep(1000); } catch (Exception ex) { }

    for (long i = 0; i &lt; 1000000; i++)
    {
      /* Acquire a position in the buffer */
      pos = src.acquireMessageBufferPosition(msgLength, flags);
      /* Place data at acquired position */
      srcBuffer.putLong(pos, i);
      /* Inform receivers data has been written */
      src.messageBuffersComplete();
    }

    /* Linger for a short while to allow retransmissions, etc. */
    try { Thread.sleep(1000); } catch (Exception ex) { }

    src.close();
    ctx.close();
  }  /* sendMessages */
}  /* SimpleSrc */
</pre><p>The source sends one million messages using the native LBT-SMX Java APIs. The sendMessages() method obtains a reference to the source's message buffer, which does not change for the life of the source. The method acquireMessageBufferPosition(int, int) contains the requested message length of 8 bytes. When this call returns, it gives an integer position into the previously obtained messages buffer, which is the position of the message data. UM guarantees that you can safely write the value of the counter i into the buffer at this position.</p>
<p><b>Java Receiver Example</b></p>
<pre class="fragment">import java.nio.ByteBuffer;
import com.latencybusters.lbm.*;

/* Extend LBMReceiver to avoid onReceive synchronization */
public class SimpleSmxRcv extends LBMReceiver
{
  protected SimpleSmxRcv(LBMContext lbmctx, LBMTopic lbmtopic) throws LBMException
  {
    super(lbmctx, lbmtopic);
  }

  long lastReceivedValue = -1;
  /* Override LBMReceiver onReceive method */
  protected int onReceive(LBMMessage lbmmsg)
  {
    if (lbmmsg.type() == LBM.MSG_DATA)
    {
      /* New API gets byte buffer with position and limit set */
      ByteBuffer msgsBuffer = lbmmsg.getMessagesBuffer();
      /* Get the message data directly from the buffer */
      lastReceivedValue = msgsBuffer.getLong();
    }
    return 0;
  }  /* on Receive */

  public static void main(String[] args)
  {
    LBMContext ctx = null;
    SimpleSmxRcv rcv = null;

    try
    {
      ctx = new LBMContext();
      LBMTopic top = ctx.lookupTopic("SimpleSmx");
      rcv = new SimpleSmxRcv(ctx, top);
    } catch (LBMException ex)
    {
      System.out.println(ex.getMessage());
      ex.printStackTrace();
      System.exit(1);
    }

    while (rcv.lastReceivedValue &lt; 999999) {
      try { Thread.sleep(250); } catch (Exception ex) {}
    }
    try
    {
      rcv.close();
      ctx.close();
      System.out.println("Last Received Value: " + rcv.lastReceivedValue);
    } catch (LBMException ex)
    {
      System.out.println(ex.getMessage());
      ex.printStackTrace();
    }
  }  /* main */
}
</pre><p>The receiver reads messages from an LBT-SMX Source using the new API on LBMMessage. The example extends the LBMReceiver class so that you can overwrite the onReceive() method, which bypasses synchronization of multiple receiver callbacks. As a result, the addReceiver() and removeReceiver() methods do not work with this class, but we don't want them anyway. In the overridden onReceive() callback, we call getMessagesBuffer(), which returns a ByteBuffer view of the underlying transport. This allows the application to do zero copy reads directly from the memory that stores the message data. The returned ByteBuffer position and limit is set to the beginning and end of the message data. The message data does not start at position 0. The application reads a long out of the buffer, which is the same long that was placed by the source example.</p>
<p><b>Batching Example</b></p>
<pre class="fragment">public void sendMessages() throws LBMException
{
  ...
  for (long i = 0; i &lt; 1000000; i += 2)
  {
    /* Acquire a position in the buffer */
    pos = src.acquireMessageBufferPosition(msgLength, flags);
    /* Place data at acquired position */
    srcBuffer.putLong(pos, i);
    pos = src.acquireMessageBufferPosition(msgLength, flags); srcBuffer.putLong(pos, i+1);
    /* Inform receivers two messages have been written */
    src.messageBuffersComplete();
  }
  ...
}
</pre><p>You can implement a batching algorithm at the source by doing multiple acquires before calling complete. When receivers notice that there are new message available, they deliver all new messages in a single loop.</p>
<p><b>Blocking and Non-blocking Sends Example</b></p>
<pre class="fragment">public void sendMessages() throws LBMException
{
  ...
  /* Acquire will return -1 if need to wait for receivers */
  final int flags = LBM.SRC_NONBLOCK;
  ...
  for (long i = 0; i &lt; 1000000; i++)
  {
    /* Acquire a position in the buffer */
    pos = src.acquireMessageBufferPosition(msgLength, flags);
    while (pos == -1)
    {
      /* Implement a backoff algorithm here */
      try { Thread.sleep(1); } catch (Exception ex) { }

      pos = src.acquireMessageBufferPosition(msgLength, flags);
      /* Place data at acquired position */
      srcBuffer.putLong(pos, i);
      /* Inform receivers data has been written */
      src.messageBuffersComplete();
    }
    ...
  }
}
</pre><p>By default, acquireMessageBufferPosition() waits for receivers to catch up before it writes the requested number of bytes to the buffer. The resulting spin wait block happens only if you did not set the flags argument to LBM.SRC_NONBLOCK. If the flags argument sets the LBM.SRC_NONBLOCK value, then the function returns -1 if the call would have blocked. For performance reasons, acquireMessageBufferPosition() does not throw new LBMEWouldBlock exceptions like standard send APIs.</p>
<p><b>Complete and Acquire Function</b></p>
<pre class="fragment">public void sendMessages() throws LBMException
{
  ...
  for (long i = 0; i &lt; 1000000; i++)
  {
    /* Mark previous acquires complete and reserve space */
    pos = src.messageBuffersCompleteAndAcquirePosition(msgLength, flags);
    /* Place data at acquired position */
    srcBuffer.putLong(pos, i);
  }
  /* final buffers complete after loop */
  src.messageBuffersComplete();
  ...
}
</pre><p>The function, messageBuffersCompleteAndAcquirePosition(), is a convenience function for the source and calls messageBuffersComplete() followed immediately by acquireMessageBufferPosition(), which reduces the number of method calls per message.</p>
<p><br />
 </p>
<h2><a class="anchor" id="netcodeexamplesforlbtsmx"></a>
.NET Code Examples for LBT-SMX</h2>
<p>The .NET code examples for LBT-SMX send and receive one million messages. Start the receiver example application before you start the source example application.</p>
<p><b>.NET Source Example</b></p>
<pre class="fragment">using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.Runtime.InteropServices;
using com.latencybusters.lbm;

namespace UltraMessagingApplication.SimpleSrc
{
  class SimpleSrc
  {
    LBMContext ctx;
    LBMSource src;

    static void Main(string[] args)
    {
      SimpleSrc test = new SimpleSrc(); test.sendMessages(); Console.WriteLine("Send Complete");
    }

    public SimpleSrc()
    {
      ctx = new LBMContext();
      LBMSourceAttributes sattr = new LBMSourceAttributes();
      sattr.setValue("transport", "lbtsmx");
      LBMTopic top = ctx.allocTopic("SimpleSmx", sattr);
      src = ctx.createSource(top);
    }

    private void sendMessages()
    {
      IntPtr writePtr;
      // Sends will block waiting for receivers
      int flags = LBM.SRC_BLOCK;
      uint msgLength = 8; Thread.Sleep(1000);
      for (long i = 0; i &lt; 1000000; i++) {
        // Acquire a position in the buffer src.
        buffAcquire(out writePtr, msgLength, flags);
        // Place data at acquired position Marshal.
        WriteInt64(writePtr, i);
        // Inform receivers data has been written.
        src.buffsComplete();
      }

      Thread.Sleep(1000);
      src.close();
      ctx.close();
    }
  }
}
</pre><p>You can access the shared memory region directly with the IntPtr structs. The src.buffAcquire() API modifies writePtr to point to the next available location in shared memory. When buffAcquire() returns, you can safely write to the writePtr location up to the length specified in buffAcquire(). The Marshal.WriteInt64() writes 8 bytes of data to the shared memory region. The call to buffsComplete() signals new data to connected receivers.</p>
<p><b>.NET Receiver Example</b></p>
<pre class="fragment">using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.Runtime.InteropServices;
using com.latencybusters.lbm;

namespace UltraMessagingApplication.SimpleRcv
{
  class SimpleRcv
  {
    private LBMContext ctx;
    private LBMReceiver rcv;
    private long lastReceivedValue = -1;

    static void Main(string[] args)
    {
      SimpleRcv simpleRcv = new SimpleRcv();
      while (simpleRcv.lastReceivedValue &lt; 999999)
      {
        Thread.Sleep(250);
      }
      simpleRcv.rcv.close();
      simpleRcv.ctx.close();
      Console.WriteLine("Last Received Value: {0}", simpleRcv.lastReceivedValue);
    }

    public SimpleRcv()
    {
      ctx = new LBMContext();
      LBMTopic top = new LBMTopic(ctx, "SimpleSmx");
      rcv = new LBMReceiver(ctx, top, new LBMReceiverCallback(onReceive), null);
    }

    public int onReceive(Object obj, LBMMessage msg)
    {
      if (msg.type() == LBM.MSG_DATA)
      {
        // Read data out of shared memory
        lastReceivedValue = Marshal.ReadInt64(msg.dataPointerSafe());
      }
      // dispose the message so the LBMMessage object can be re-used msg.
      dispose();
      return 0;
    }
  }
}
</pre><p>The application calls the simpleRcv::onReceive callback after the source places new data in the shared memory region. The msg.dataPointerSafe() API returns an IntPtr to the data, which does not create any new objects. The Marshal.ReadInt64 API then reads data directly from the shared memory.</p>
<p><b>Batching</b></p>
<pre class="fragment">private void sendMessages()
{
  ...
  for (int i = 0; i &lt; 1000000; i += 2) {
    // Acquire a position in the buffer src.
    buffAcquire(out writePtr, msgLength, flags);
    // Place data at acquired position Marshal.
    WriteInt32(writePtr, i);
    // Acquire a position in the buffer src.
    buffAcquire(out writePtr, msgLength, flags);
    // Place data at acquired position Marshal.
    WriteInt32(writePtr, i);
    // Inform receivers two messages has been written src.
    buffsComplete();
  }

  ...
}
</pre><p>You can implement a batching algorithm at the source by doing multiple acquires before calling complete. When receivers notice that new message are available, they deliver all new messages in a single loop.</p>
<p><b>Blocking and Non-blocking Sends</b></p>
<pre class="fragment">private void sendMessages()
{
  ...
  // buffAcquire will return -1 if need to wait for receivers int flags = LBM.SRC_NONBLOCK;
  ...
  for (long i = 0; i &lt; 1000000; i++)
  {
    // Acquire a position in the buffer
    int rc = src.buffAcquire(out writePtr, msgLength, flags);
    while (rc == -1)
    {
      // Implement a backoff algorithm here Thread.Sleep(0);
      rc = src.buffAcquire(out writePtr, msgLength, flags);
    }
    // Place data at acquired position Marshal.
    WriteInt64(writePtr, i);
    // Inform receivers that a message has been written src.
    buffsComplete();
    ...
  }
}
</pre><p>By default, buffAcquire() waits for receivers to catch up before it writes the requested number of bytes to the buffer. The resulting spin wait block happens only if you did not set the flags argument to <b>LBM.SRC_NONBLOCK</b>. If the flags argument sets the <b>LBM.SRC_NONBLOCK</b> value, then the function returns -1 if the call would have blocked. For performance reasons, buffAcquire() does not throw new <b>LBMEWouldBlock</b> exceptions like standard send APIs.</p>
<p><b>Complete and Acquire Function</b></p>
<pre class="fragment">private void sendMessages()
{
  ...
  for (long i = 0; i &lt; 1000000; i++) {
    // Acquire a position in the buffer src.
    buffsCompleteAndAcquire(out writePtr, msgLength, flags);
    // Place data at acquired position Marshal.
    WriteInt64(writePtr, i);
  }

  // final buffsComplete after loop src.buffsComplete();

  ...
}
</pre><p>The function, buffsCompleteAndAcquire(), is a convenience function for the source and calls buffsComplete() followed immediately by buffAcquire(), which reduces the number of method calls per message.</p>
<p><b>Reduce Synchronization Overhead</b></p>
<pre class="fragment">public SimpleRcv()
  {
  ctx = new LBMContext();
  LBMReceiverAttributes rattr = new LBMReceiverAttributes();
  // Set the enableSingleReceiverCallback attribute to 'true' rattr.
  enableSingleReceiverCallback(true);
  LBMTopic top = new LBMTopic(ctx, "SimpleSmx", rattr);
  // With enableSingleReceiverCallback, a callback must be specified in the ver constructor.

  rcv = new LBMReceiver(ctx, top, new LBMReceiverCallback(onReceive), null);
  // rcv.addReceiver and rcv.removeReceiver will result in log warnings.
}
</pre><p>Delivery latency to an LBMReceiver callback can be reduced with a single callback. Call LBMReceiverAttributes::enableSingleReceiverCallback on the attributes object used to create the LBMReceiver. The addReceiver() and removeReceiver() APIs become defunct, and your application calls the application receiver callback without any locks taken. The enableSingelReceiverCallback() API eliminates callback related synchronization overhead.</p>
<dl class="section note"><dt>Note</dt><dd>In Java, inheriting from LBMReceiver and overriding the onReceive can achieve the same thing.</dd></dl>
<p><b>Increase Performance with unsafe Code Constructs</b></p>
<pre class="fragment">for (long i = 0; i &lt; 1000000; i++) {
  // Acquire a position in the buffer src.buffAcquire(out writePtr, msgLength, flags);
  // Place data at acquired position
  unsafe
  {
    *((long*)(writePtr)) = i;
  }
  // Inform receivers data has been written src.buffsComplete();
}

public int onReceive(Object obj, LBMMessage msg)
{
  if (msg.type() == LBM.MSG_DATA)
  {
    unsafe
    {
      lastReceivedValue = *((long*)msg.dataPointer());
    }
  }
  // dispose the message so the object can be re-used msg.dispose();
  return 0;
}
</pre><p>Using .NET unsafe code constructs can increase performance. By manipulating pointers directly, you can eliminate calls to external APIs, resulting in lower latencies.</p>
<p><br />
 </p>
<h2><a class="anchor" id="lbtsmxresourcemanager"></a>
LBT-SMX Resource Manager</h2>
<p>Deleting an SMX source or deleting an SMX receiver reclaims the shared memory area and locks allocated by the SMX source or receiver. However, if an ungraceful exit from a process occurs, global resources remain allocated but unused. To address this possibility, the LBT-SMX Resource Manager maintains a resource allocation database with a record for each global resource (memory or semaphore) allocated or freed. You can use the LBT-SMX Resource Manager to discover and reclaim resources. See the three example outputs below.</p>
<p><b>Displaying Resources</b></p>
<pre class="fragment">$&gt; lbtsmx_resource_manager
Displaying Resources (to reclaim you must type '-reclaim' exactly)

--Memory Resources--
Memory resource: Process ID: 24441 SessionID: ab569cec XportID: 20001

--Semaphore Resources-- Semaphore key: 0x68871d75
Semaphore resource Index 0: reserved

Semaphore resource: Process ID: 24441 Sem Index: 1
Semaphore resource: Process ID: 24436 Sem Index: 2
</pre><p><b>Reclaiming Unused Resources</b></p>
<dl class="section warning"><dt>Warning</dt><dd>This operation should never be done while SMX-enabled applications or daemons are running. If you have lost or unused resources that need to be reclaimed, you should exit all SMX applications prior to running this command.</dd></dl>
<pre class="fragment">$&gt; lbtsmx_resource_manager -reclaim
Reclaiming Resources
Process 24441 not found: reclaiming Memory resource (SessionID: ab569cec XPortID: 20001)
Process 24441 not found: reclaiming Semaphore resource: Key: 0x68871d75 Sem Index: 1
Process 24436 not found: reclaiming Semaphore resource: Key: 0x68871d75 Sem Index: 2
</pre><p><br />
 </p>
<h1><a class="anchor" id="transportlbtrdma"></a>
Transport LBT-RDMA</h1>
<p>The existing RDMA transport is deprecated and will be removed in a future release.</p>
<p>The LBT-RDMA transport is Remote Direct Memory Access (RDMA) UM transport that allows sources to publish topic messages to a shared memory area from which receivers can read topic messages. LBT-RDMA runs across InfiniBand and 10 Gigabit Ethernet hardware.</p>
<dl class="section note"><dt>Note</dt><dd>Use of the LBT-RDMA transport requires the purchase and installation of the Ultra Messaging RDMA Transport Module. See your Ultra Messaging representative for licensing specifics. Restriction: Transport LBT-RDMA is supported on only the X86 Linux 64-bit platform.</dd></dl>
<p>When you create a source with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ab8dd76271bf9df7a5f88476d431f523e">lbm_src_create()</a> and you've set the transport option to RDMA, UM creates a shared memory area object on the sending machine's Host Channel Adapter (HCA) card. UM assigns one of the RDMA transport ports to this area specified with the UM context configuration options, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpdeprecated.html#transportlbtrdmaporthighcontext">transport_lbtrdma_port_high (context)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpdeprecated.html#transportlbtrdmaportlowcontext">transport_lbtrdma_port_low (context)</a>. You can also specify a shared memory location outside of this range with a source configuration option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpdeprecated.html#transportlbtrdmaportsource">transport_lbtrdma_port (source)</a>, to prioritize certain topics, if needed.</p>
<p>When you create a receiver with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aa7491c50fefbc2b70f8035fce7ac1477">lbm_rcv_create()</a> for a topic being sent over LBT-RDMA, UM creates a shared memory area on the receiving machine's HCA card. The network hardware immediately copies any new data from the sending HCA to the receiving HCA. UM receivers monitor the receiving shared memory area for new topic messages. You configure receiver monitoring with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpdeprecated.html#transportlbtrdmareceiverthreadbehaviorcontext">transport_lbtrdma_receiver_thread_behavior (context)</a>.</p>
<p>The following diagram illustrates how sources and receivers interact with the shared memory area used in the LBT-RDMA transport.</p>
<div class="image">
<img src="RDMA_Objects.png" alt="RDMA_Objects.png"/>
</div>
 <p><br />
 </p>
<h2><a class="anchor" id="similaritieswithotherumstransports"></a>
Similarities with Other UM Transports</h2>
<p>UM functions in much the same way as if you send packets across a traditional Ethernet network as with other UM transports.</p>
<ul>
<li>
If you use a range of ports, UM assigns multiple topics that have been sent by multiple sources in a round robin manner to all the transport sessions configured my the port range. </li>
<li>
Transport sessions assume the configuration option values of the first source assigned to the transport session. </li>
<li>
Sources are subject to message batching. </li>
<li>
<p class="startli">Topic resolution operates identically with LBT-RDMA as other UM transports.</p>
<p class="endli"><br />
 </p>
</li>
</ul>
<h2><a class="anchor" id="differencesfromotherumstransports"></a>
Differences from Other UM Transports</h2>
<ul>
<li>
Unlike LBT-RM, which uses a transmission window to set a retransmission buffer size, LBT-RDMA uses the transmission window option to set the size of the shared memory. </li>
<li>
LBT-RDMA does not retransmit messages. </li>
<li>
Receivers also do not send NAKs when using LBT-RDMA. </li>
<li>
LBT-RDMA is inherently ordered in its message delivery. If you set <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#ordereddeliveryreceiver">ordered_delivery (receiver)</a> to 0, then UM delivers message fragments individually in sequence number order, without reassembly. </li>
<li>
LBT-RDMA is source-paced but does not support Rate Control. If the source message rate exceeds the receiver's consumption rate, unrecoverable message loss eventually occurs. </li>
<li>
LBT-RDMA creates a separate receiver thread in the receiving context. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="transportbroker"></a>
Transport Broker</h2>
<p>With the UMQ product, you use the '<b>broker</b>' transport to send messages from a source to a Queuing Broker, or from a Queuing Broker to a receiver.</p>
<p>When sources or receivers connect to a Queuing Broker, you must use the '<b>broker</b>' transport. You cannot use the '<b>broker</b>' transport with UMS or UMP products. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
</body>
</html>
