<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Concepts Guide: Fundamental Concepts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen_manual.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Concepts Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('fundamentalconcepts.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Fundamental Concepts </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A UM application can function either as a source or a receiver. A source application sends messages, and a receiver application receives them. (It is also common for an application to function as both source and receiver; we separate the concepts for organizational purposes.)</p>
<p><br />
 </p>
<h1><a class="anchor" id="topicstructureandmanagement"></a>
Topic Structure and Management</h1>
<p>UM offers the Publish/Subscribe model for messaging ("Pub/Sub"), whereby one or more receiver programs express interest in a topic ("subscribe"), and one or more source programs send to that topic ("publish"). So, a topic can be thought of as a data stream that can have multiple producers and multiple consumers. One of the functions of the messaging layer is to make sure that all messages sent to a given topic are distributed to all receivers listening to that topic. UM does this through an automatic process known as topic resolution.</p>
<p>A topic is just an arbitrary string. For example:</p>
<pre class="fragment">Orders
Market/US/DJIA/Sym1
</pre><p>It is not unusual for an application system to have many thousands of topics, perhaps even more than a million, with each one carrying a very specific range of information (e.g. quotes for a single stock symbol).</p>
<p>It is also possible to configure receiving programs to match multiple topics using wildcards. UM uses powerful regular expression pattern matching to allow applications to match topics in a very flexible way. Messages cannot be <em>sent</em> to wildcarded topic names. See <a class="el" href="umobjects.html#umwildcardreceivers">UM Wildcard Receivers</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="topicresolutionoverview"></a>
Topic Resolution Overview</h2>
<p>Topic Resolution ("TR") is the process by which subscribers discover publishers for their topics of interest. Once discovered, a subscriber will join those publishers' data streams.</p>
<p>The process operates by newly started publishers sending a series of <em>Advertisements</em> in the form of Topic Information Records (TIRs). These advertisements are carried on a pre-configured Topic Resolution channel (usually a multicast group, although there is a <a class="el" href="architecture.html#unicasttopicresolution">unicast alternative</a>, described later.) All applications are expected to connect to the same TR channel.</p>
<p>As publishers send these TIRs (advertisements) out the TR channel, subscribers will receive them and determine if they are of interest. If so, the subscribers initiate a connection to the publisher's data stream.</p>
<p>In addition, newly started subscribers send a series of <em>Queries</em> in the form of Topic Query Records (TQRs) over the same TR channel. The purpose of TQRs is essentially to trigger publishers of the interested topics to send the corresponding TIRs as soon as possible.</p>
<p>For details, see <a class="el" href="architecture.html#topicresolutiondescription">Topic Resolution Description</a>.</p>
<p><br />
 </p>
<h1><a class="anchor" id="persistence"></a>
Persistence</h1>
<p>The UMP and UMQ products include a component known as the Persistent Store, which provides stable storage (disk or memory) of message streams. UM delivers a persisted message stream to receiving applications with no additional latency in the vast majority of cases. This offers the functionality of durable subscriptions and confirmed message delivery. Ultra Messaging Streaming applications build and run with the Persistence feature without modification. For more information, see the <a href="../UME/UM_Guide_for_Persistence=en.pdf">UM Guide for Persistence</a>.</p>
<p><br />
 </p>
<h1><a class="anchor" id="queuing"></a>
Queuing</h1>
<p>The UMQ product, which contains Streaming and Persistence functionality, also includes message queuing capabilities. See <a href="../UMQ/index.html">UM Guide to Queuing</a> for more information.</p>
<p><br />
 </p>
<h1><a class="anchor" id="umrouter"></a>
UM Router</h1>
<p>The Ultra Messaging Dynamic Routing Option (DRO) consists of a daemon called the "UM Router" (or just the DRO) that bridges disjoint Topic Resolution Domains (TRDs) by effectively forwarding control and user traffic between them. Thus, the UM Router facilitates WAN routing where multicast routing capability is absent, possibly due to technical obstacles or enterprise policies.</p>
<p>The UM Router transfers multicast and/or unicast topic resolution information, thus ensuring that receivers in disjoint topic resolution domains from the source can receive the topic messages to which they subscribe.</p>
<p>See The <a href="../Gateway/index.html">Dynamic Routing Guide</a> for more information.</p>
<p><br />
 </p>
<h1><a class="anchor" id="latejoin"></a>
Late Join</h1>
<p>In many applications, a new receiver may be interested in messages that were sent before the receiver was created. The Ultra Messaging Late Join feature allows a new receiver to obtain previously-sent messages from a source. Without the Late Join feature, the receiver would only deliver messages sent after the receiver successfully subscribes. With Late Join, the source locally stores recently sent messages according to its Late Join configuration options, and a new receiver is able to retrieve these messages.</p>
<p>Source-side configuration options:</p>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#latejoinsource">late_join (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpdeprecated.html#retransmitretentionagethresholdsource">retransmit_retention_age_threshold (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizelimitsource">retransmit_retention_size_limit (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizethresholdsource">retransmit_retention_size_threshold (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grprequestnetwork.html#requesttcpinterfacecontext">request_tcp_interface (context)</a> </li>
</ul>
<p>Receiver-side configuration options:</p>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#uselatejoinreceiver">use_late_join (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestintervalreceiver">retransmit_request_interval (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestmessagetimeoutreceiver">retransmit_request_message_timeout (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestoutstandingmaximumreceiver">retransmit_request_outstanding_maximum (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#latejoininforequestintervalreceiver">late_join_info_request_interval (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#latejoininforequestmaximumreceiver">late_join_info_request_maximum (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitinitialsequencenumberrequestreceiver">retransmit_initial_sequence_number_request (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitmessagecachingproximityreceiver">retransmit_message_caching_proximity (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpresponseoperation.html#responsetcpinterfacecontext">response_tcp_interface (context)</a> </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>With <a class="el" href="umfeatures.html#smartsources">Smart Sources</a>, the following configuration options have limited or no support: <ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizethresholdsource">retransmit_retention_size_threshold (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizelimitsource">retransmit_retention_size_limit (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpdeprecated.html#retransmitretentionagethresholdsource">retransmit_retention_age_threshold (source)</a> </li>
</ul>
</dd>
<dd>
You cannot use Late Join with Queuing functionality (UMQ).</dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="requestresponse"></a>
Request/Response</h1>
<p>Ultra Messaging also offers a Request/Response messaging model. A sending application (the requester) sends a message to a topic. Every receiving application listening to that topic gets a copy of the request. One or more of those receiving applications (responder) can then send one or more responses back to the original requester. Ultra Messaging sends the request message via the normal pub/sub method, whereas Ultra Messaging delivers the response message directly to the requester.</p>
<p>An important aspect of the Ultra Messaging Request/Response model is that it allows the application to keep track of which request corresponds to a given response. Due to the asynchronous nature of Ultra Messaging requests, any number of requests can be outstanding, and as the responses come in, they can be matched to their corresponding requests.</p>
<p>Request/Response can be used in many ways and is often used during the initialization of Ultra Messaging receiver objects. When an application starts a receiver, it can issue a request on the topic the receiver is interested in. Source objects for the topic can respond and begin publishing data. This method prevents the Ultra Messaging source objects from publishing to a topic without subscribers.</p>
<p>Be careful not to be confused with the sending/receiving terminology. Any application can send a request, including one that creates and manages Ultra Messaging receiver objects. And any application can receive and respond to a request, including one that creates and manages Ultra Messaging source objects.</p>
<dl class="section note"><dt>Note</dt><dd>You cannot use Request/Response with Queuing functionality (UMQ).</dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="umtransports"></a>
UM Transports</h1>
<p>A source application uses a UM transport to send messages to a receiver application. A Ultra Messaging transport is built on top of a standard IP protocol. The different Ultra Messaging transport types have different trade offs in terms of latency, scalability, throughput, bandwidth sharing, and flexibility. The sending application chooses the transport type that is most appropriate for the data being sent, at the topic level. A programmer might choose different transport types for different topics within the same application.</p>
<p>An Ultra Messaging sending application can make use of very many topics - possibly over a million. Ultra Messaging maps those topics onto a much smaller number of transport sessions. A transport session can be thought of as a specific instance of a transport type. A given transport session might carry a single topic, or might carry hundreds of thousands of topics. A receiving application might express interest in a small set of those topics, in which case Ultra Messaging joins the transport session and receives messages for all topics carried on that transport session. Ultra Messaging then discards any messages for topics that the application is not interested in. This user-space filtering does consume system resources (primarily CPU and bandwidth), and can be minimized by carefully mapping topics onto transport sessions according to receiving application interest.</p>
<p>When Ultra Messaging sets up a transport session and receives the first data over the live data stream, Ultra Messaging generates a BOS (Beginning Of Session) to all receivers that currently exist. When a receiver joins an active transport, this immediately generates a BOS event. When the last topic on a transport session concludes or when a transport path is broken in the network (also referred to as a TCP breakage), Ultra Messaging tears down the transport session and notifies all receivers with an EOS (End Of Session) event. There is no correlation between the deletion of a source by an application and when an EOS is received by a receiver, except if it is the last source sharing the transport.</p>
<p>Be aware that in a deployment that includes the UM Router, BOS and EOS may only indicate the link between the receiver and the local UM Router portal, not necessarily full end-to-end connectivity.</p>
<dl class="section note"><dt>Note</dt><dd>Non-multicast Ultra Messaging transport types can use source-side filtering to decrease user-space filtering on the receiving side by doing the filtering on the sending side. However, be aware that system resources consumed on the source side affect all receivers, and that the filtering for multiple receivers must be done serially, whereas letting the receivers do the filtering allows that filtering to be done in parallel, only affecting those receivers that need the filtering.</dd></dl>
<p>With the UMQ product, a ULB source makes use of the same transport types as Streaming, but a Brokered Queuing source must use the <b>broker</b> transport.</p>
<p><br />
 </p>
<h2><a class="anchor" id="multitransportthreads"></a>
Multi-Transport Threads</h2>
<dl class="section note"><dt>Note</dt><dd>The "Multi-Transport Threads" feature is deprecated as of UM version 6.9 and may be eliminated from a future UM version. It is replaced in UM version 6.11 by <a class="el" href="umfeatures.html#transportservicesproviderxsp">Transport Services Provider (XSP)</a>.</dd></dl>
<p>Part of UM's design is a single threaded model for message data delivery which reduces latency in the receiving CPU. UM, however, also has the ability to distribute data delivery across multiple CPUs by using a receiving thread pool. Receivers created with the configuration option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpdeprecated.html#usetransportthreadreceiver">use_transport_thread (receiver)</a> set to 1 use a thread from the thread pool instead of the context thread. The option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpdeprecated.html#receivethreadpoolsizecontext">receive_thread_pool_size (context)</a> controls the pool size.</p>
<p>As receivers discover new sources through Topic Resolution, UM assigns the network sockets created for the receivers to receive data to either the context thread (default) or to a thread from the pool if <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpdeprecated.html#usetransportthreadreceiver">use_transport_thread (receiver)</a> is set for the receiver. It is important to understand that thread assignment occurs at the socket level - not the transport level. Transports aggregated on to the same network socket use the same thread.</p>
<p>UM distributes data from different sockets to different threads allowing better process distribution and higher aggregate throughput. Distributing transports across threads also ensures that activity on each transport has no impact on transports assigned to other threads leading to lower latencies in some traffic patterns, e.g. heavy loss conditions.</p>
<p>The following lists restrictions to using multi-transport threads:</p>
<ul>
<li>
Only LBT-RM, LBT-RU, TCP and TCP-LB transport types may be distributed to threads. </li>
<li>
Multi-Transport threads are not supported under sequential mode . </li>
<li>
UM processes sources using the same transport socket, e.g. multicast address and port, on the same thread (regardless of the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpdeprecated.html#usetransportthreadreceiver">use_transport_thread (receiver)</a> setting. To leverage threading of different sources, assign each source to a different transport destination, e.g. multicast address/port. </li>
<li>
Hot failover sources using LBT-RM on the same topic must not be distributed across threads because they must share the same multicast address and port. </li>
<li>
Hot failover sources using other transport types may not be distributed across threads and must use the context thread. </li>
<li>
Each transport thread has its own Unicast Listener (request) port. Ultra Messaging recommends that you expand the range <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grprequestnetwork.html#requesttcpportlowcontext">request_tcp_port_low (context)</a> - <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grprequestnetwork.html#requesttcpporthighcontext">request_tcp_port_high (context)</a> to a larger range when using transport threads. When late join is occurring, UM creates a TCP connection from the transport thread to the source. </li>
<li>
Multi-transport threads are not recommended for use over the UM Router. </li>
<li>
Multi-Transport Threads do not support Persistent Stores or Persistent receivers (UMP/UMQ products). </li>
<li>
Multi-Transport Threads do not support or queuing receivers (UMQ product). </li>
<li>
Multi-Transport Threads are not compatible with UMDS Server or UMCache </li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="eventdelivery"></a>
Event Delivery</h1>
<p>There are many different events that UM may want to deliver to the application. Many events carry data with them (e.g. received messages); some do not (e.g. end-of-stream events). Some examples of UM events:</p>
<ul>
<li>
A received message on a topic that the application has expressed interest in. </li>
<li>
A timer expiring. Applications can schedule timers to expire in a desired number of milliseconds (although the OS may not deliver them with millisecond precision). </li>
<li>
An application-managed file descriptor event. The application can register its own file descriptors with UM to be monitored for state changes (readable, writable, error, etc.). </li>
<li>
New source notification. UM can inform the application when sources are discovered by Topic Resolution. </li>
<li>
Receiver loss. UM can inform the application when a data gap is detected that could not be recovered through the normal retransmission mechanism. </li>
<li>
End of Stream. UM can inform a receiving application when a data stream (transport session) has terminated. </li>
</ul>
<p>UM delivers events to the application by callbacks. The application explicitly gives UM a pointer to one of its functions to be the handler for a particular event, and UM calls that function to deliver the event, passing it the parameters that the application requires to process the event. In particular, the last parameter of each callback type is a client data pointer (clientdp). This pointer can be used at the application's discretion for any purpose. It's value is specified by the application when the callback function is identified to UM (typically when UM objects are created), and that same value is passed back to the application when the callback function is called.</p>
<p>There are two methods that UM can use to call the application callbacks: through context thread callback, or event queue dispatch.</p>
<p>In the context thread callback method (sometimes called direct callback), the UM context thread calls the application function directly. This offers the lowest latency, but imposes significant restrictions on the application function. See <a class="el" href="umobjects.html#eventqueueobject">Event Queue Object</a>.</p>
<p>The event queue dispatch of application callback introduces a dynamic buffer into which the UM context thread writes events. The application then uses a thread of its own to dispatch the buffered events. Thus, the application callback functions are called from the application thread, not directly from the context thread.</p>
<p>With event queue dispatching, the use of the application thread to make the callback allows the application function to make full, unrestricted use of the UM API. It also allows parallel execution of UM processing and application processing, which can significantly improve throughput on multi-processor hardware. The dynamic buffering provides resilience between the rate of event generation and the rate of event consumption (e.g. message arrival rate v.s. message processing rate).</p>
<p>In addition, an UM event queue allows the application to be warned when the queue exceeds a threshold of event count or event latency. This allows the application to take corrective action if it is running too slow, such as throwing away all events older than a threshold, or all events that are below a given priority.</p>
<p><br />
 </p>
<h1><a class="anchor" id="ratecontrols"></a>
Rate Controls</h1>
<p>For UDP-based communications (LBT-RU, LBT-RM, and <a class="el" href="fundamentalconcepts.html#topicresolutionoverview">Topic Resolution</a>), UM network stability is ensured through the use of rate controls. Without rate controls, sources can send UDP data so fast that the network can be flooded. Using rate controls, the source's bandwidth usage is limited. If the source attempts to exceed its bandwidth allocation, it is slowed down.</p>
<p>Setting the rate controls properly requires some planning; see <a href="https://www.informatica.com/downloads/1568_high_perf_messaging_wp/Topics-in-High-Performance-Messaging.htm#GROUP-RATE-CONTROL">Topics in High Performance Messaging, Group Rate Control</a> for details.</p>
<p>Ultra Messaging's rate limiter algorithms are based on dividing time into intervals (configurable), and only allowing a certain number of bits of data to be sent during each interval. That number is divided by the number of intervals per second. For example, a limit of 1,000,000 bps and an interval of 100 ms results in the limiter allowing 100,000 bits to be sent during each interval. Dividing by 8 to get bytes gives 12,500 bytes per interval.</p>
<p>Data are not sent over a network as individual bytes, but rather are grouped into datagrams. Since it is not possible to send only part of a datagram, the rate limiter algorithm needs to decide what to do if an outgoing datagram would exceed the number of bits allowed during the current time interval. The data transport rate limiter algorithm, for LBT-RM and LBT-RU, differs from the Topic Resolution rate limiter algorithm.</p>
<p><br />
 </p>
<h2><a class="anchor" id="transportratecontrol"></a>
Transport Rate Control</h2>
<p>With data transport, if an outgoing datagram would exceed the number of bits allowed during the current time interval, that datagram is queued and the transport type is put into a "blocked" state in the current context. Any subsequent sends within the same time interval will not queue, but instead will either block (for blocking sends), or return <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a75f0f83b8684df30d9816210cc20b4b0">LBM_EWOULDBLOCK</a> (for non-blocking sends). When the time interval expires, the context thread will refresh the number of allowable bits, send the queued datagram, and unblock the transport type.</p>
<p>Note that for very small settings of transport rate limit, the end-of-interval refresh of allowable bits may still not be enough to send a queued full datagram. In that case, the datagram will remain on the queue for additional intervals to pass, until enough bits have accumulated to send the queued datagram. However, it would be very unusual for a transport rate limit to be set that small.</p>
<p>Configuration parameters of interest are: </p><ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmoperation.html#transportlbtrmrateintervalcontext">transport_lbtrm_rate_interval (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmoperation.html#transportlbtrmdataratelimitcontext">transport_lbtrm_data_rate_limit (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmoperation.html#transportlbtrmretransmitratelimitcontext">transport_lbtrm_retransmit_rate_limit (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtruoperation.html#transportlbtrurateintervalcontext">transport_lbtru_rate_interval (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtruoperation.html#transportlbtrudataratelimitcontext">transport_lbtru_data_rate_limit (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtruoperation.html#transportlbtruretransmitratelimitcontext">transport_lbtru_retransmit_rate_limit (context)</a> </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="topicresolutionratecontrol"></a>
Topic Resolution Rate Control</h2>
<p>With Topic Resolution ("TR"), the algorithm acts differently. It is designed to allow at least one datagram per time interval, and is allowed to exceed the rate limit by at most one topic's worth. Thus, the TR rate limiter value should only be considered a "reasonably accurate" approximation.</p>
<p>This approximation can seem very inaccurate at very small rate limits. As an extreme example, suppose that a user configures a rate limiter to 1 bit per second. Since the TR rate limiter allows at least one Advertisement (TIR) to be sent per interval, and a TIR of a 240-character topic creates a datagram about 400 bytes long (exact size depends on user options), ten of those per second is 32,000 bits, which is over 3 million percent of the desired rate. This sounds extreme, but understand that this works out to only 10 packets per second, a trivial load for modern networks. In practice, the minimum <em>effective</em> rate limit works out to be one datagram per interval.</p>
<p>For details of Topic Resolution, see <a class="el" href="architecture.html#topicresolutiondescription">Topic Resolution Description</a>.</p>
<p><br />
 </p>
<h1><a class="anchor" id="operationalstatistics"></a>
Operational Statistics</h1>
<p>UM maintains a variety of transport-level statistics which gives a real-time snapshot of UM's internal handling. For example, it gives counts for transport messages transferred, bytes transferred, retransmissions requested, unrecoverable loss, etc.</p>
<p>The UM monitoring API provides framework to allow the convenient gathering and transmission of UM statistics to a central monitoring point. For more information, see the <a href="../Config/index.html">UM Configuration Guide</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
</body>
</html>
