<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Concepts Guide: UM Features</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen_manual.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Concepts Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('umfeatures.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">UM Features </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Except where otherwise indicated, the features described in this section are available in the UMS, UMP, and UMQ products.</p>
<p><br />
 </p>
<h1><a class="anchor" id="transportservicesproviderxsp"></a>
Transport Services Provider (XSP)&nbsp;&nbsp;<small><a href="#transportservicesproviderxsp">&lt;-</a></small></h1>
<p>As of UM version 6.11, a new receive-side object is available to the user: the <a class="el" href="fundamentalconcepts.html#transportservicesproviderobject">Transport Services Provider Object</a>.</p>
<p>The earlier feature, <a class="el" href="fundamentalconcepts.html#multitransportthreads">Multi-Transport Threads</a>, is deprecated in favor of XSP.</p>
<p>By default, a UM context combines all network data reception into a single <em>context thread</em>. This thread is responsible for reception and processing of application messages, topic resolution, and immediate message traffic (UIM and MIM). The context thread is also used for processing timers. This single-threaded model conserves CPU core resources, and can simplify application design. However, it can also introduce significant latency outliers (jitter) if a time-sensitive user message is waiting behind, say, a topic resolution message, or a timer callback.</p>
<p>Using an XSP object, an application can reassign the processing of a subscribed <a class="el" href="fundamentalconcepts.html#transportsessions">Transport Session</a> to an independent thread. This allows concurrent processing of received messages with topic resolution and timers, and even allows different groups Transport Sessions to be processed concurrently with each other.</p>
<p>By default, when an XSP object is created, UM creates a new thread associated with the XSP. Alternatively, the XSP can be created with operational mode "sequential", which gives the responsibility of thread creation to the application. Either way, the XSP uses its independent thread to read data from the sockets associated with one or more subscribed Transport Sessions. That thread then delivers received messages to the application via a normal receive application callback function.</p>
<p>Creation of an XSP does not by itself cause any receiver Transport Sessions to be assigned to it. Central to the use of XSPs is an application-supplied mapping callback function which tells UM which XSP to associate with subscribed Transport Sessions as they are discovered and joined. This callback allows the application to examine the newly-joined Transport Session, if desired. Then the callback returns, informing UM which XSP, if any, to assign the receiver Transport Session to.</p>
<p><br />
 </p>
<h2><a class="anchor" id="xsphandlestransportsessionsnottopics"></a>
XSP Handles Transport Sessions, Not Topics&nbsp;&nbsp;<small><a href="#xsphandlestransportsessionsnottopics">&lt;-</a></small></h2>
<p>Conceptually, an application designer might want to assign the reception and processing of received data to XSPs on a topic basis. This is not always possible. The XSP thread must process received data on a socket basis, and sockets map to <em>Transport Sessions</em>. As mentioned in <a class="el" href="fundamentalconcepts.html#umtransports">UM Transports</a>, a publishing application maps one or more topic-based sources to a Transport Session.</p>
<p>Consider the following example:</p>
<div class="image">
<img src="xsp_1.png" alt="xsp_1.png"/>
</div>
 <p>Publisher A and B are two separate application instances, both of which create a source for topic "X". A subscriber application might create two XSPs and assign one Transport Session to each. In this case, you have two independent threads delivering messages to the subscriber's receiver callback, which may not be what the developer wanted. If the developer wants topic X to be serialized, a single XSP should be created and mapped to both Transport Sessions:</p>
<div class="image">
<img src="xsp_2.png" alt="xsp_2.png"/>
</div>
 <p>Now let's introduce a second topic. The developer might want to create two XSPs so that each topic will be handled by an independent thread. However, this is not possible, given the way that the topics are mapped to Transport Sessions in the following example:</p>
<div class="image">
<img src="xsp_3.png" alt="xsp_3.png"/>
</div>
 <p>In this case, XSP 1 is delivering both topics X and Y from Publisher A, and XSP 2 is delivering topics X and Y from Publisher B. Once again, the receiver callback for topic X will be called by two independent threads, which is not desired.</p>
<p>The only way to achieve independent processing of topics is to design the publishers to map their topics to Transport Sessions carefully. For example:</p>
<div class="image">
<img src="xsp_4.png" alt="xsp_4.png"/>
</div>
 <p><br />
 </p>
<h2><a class="anchor" id="xspthreadingconsiderations"></a>
XSP Threading Considerations&nbsp;&nbsp;<small><a href="#xspthreadingconsiderations">&lt;-</a></small></h2>
<p>When contexts are used single-threaded, the application programmer can assume serialization of event delivery to the application callbacks. This can greatly simplify the design of applications, at the cost of added latency outliers (jitter).</p>
<p>When XSPs are used to provide multi-threaded receivers, care must be taken in application design to account for potential concurrent calls to application callbacks. This is especially true if multiple subscribed Transport Sessions are assigned different XSPs, as demonstrated in <a class="el" href="umfeatures.html#xsphandlestransportsessionsnottopics">XSP Handles Transport Sessions, Not Topics</a>.</p>
<p>Even in the most simple case, where a single XSP is created and used for all subscribed Transport Sessions, there are still events generated by the main context thread which can be called concurrently with XSP callbacks. Reception of MIM or UIM messages, scheduled timers, and some topic resolution-related callbacks all come from the main context thread, and can all be invoked concurrently with XSP callbacks.</p>
<dl class="section warning"><dt>Warning</dt><dd>Remember that MIM and UIM messages can be sent to a topic. If you have regular sources for a topic assigned to an XSP, and somebody sends MIM or UIM messages to the same topic, your receiver callback function can be called concurrently by both the XSP and the main context. Informatica recommends having a given topic sent to by only one type of sender (UIM, MIM, Source).</dd></dl>
<p><b>Threading Example: Message Timeout</b></p>
<p>Consider as an example a common timer use case: message timeout. Application A expects to receive messages for topic "X" every 5 seconds. If 10 seconds pass without a message, the application assumes that the publisher for "X" has exited, so it cleans up internal state and deletes the UM receiver object. Each time a message is received, the current timer is cancelled and re-created for 10 seconds.</p>
<p>Without XSPs, this can be easily coded since message reception and timer expiration events are serialized. The timer callback can clean up and delete the receiver, confident that no receiver events might get delivered while this is in progress.</p>
<p>However, if the Transport Session carrying topic "X" is assigned to an independent XSP thread, message reception and timer expiration events are no longer serialized. Publisher of "X" might send it's message on-time, but a temporary network outage could delay its delivery, introducing a race condition between message delivery and timer expiration. Consider the case where the timer expiration is a little ahead of the message callback. The timer callback might clean up application state which the message callback will attempt to use. This could lead to unexpected behavior, possibly including segmentation faults.</p>
<p>In this case, proper sequencing of operations is critical. The timer should delete the receiver first. While inside the receiver delete API, the XSP might deliver messages to the application. However, once the receiver delete API returns, it is guaranteed that the XSP is finished making receiver callbacks.</p>
<p>Note that in this example case, if the message receive callback attempts to cancel the timer, the cancel API will return an error. This is because the timer has already expired and the execution of the callback has begun, and is inside the receiver delete API. The message receive callback needs to be able to handle this sequence, presumably by not re-scheduling the timer.</p>
<p><br />
 </p>
<h2><a class="anchor" id="xspusage"></a>
XSP Usage&nbsp;&nbsp;<small><a href="#xspusage">&lt;-</a></small></h2>
<p>This section provides simplified C code fragments that demonstrate some of the XSP-related API calls. For full examples of XSP usage, see <a href="../example/lbmrcvxsp.c">lbmrcvxsp.c</a> (for C) and <a href="../java_example/lbmrcvxsp.java">lbmrcvxsp.java</a> (for Java).</p>
<dl class="section note"><dt>Note</dt><dd>Each XSP thread has its own Unicast Listener (request) port. You may need to expand the range <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpunicastimmediatemessagingnetwork.html#requesttcpportlowcontext">request_tcp_port_low (context)</a> - <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpunicastimmediatemessagingnetwork.html#requesttcpporthighcontext">request_tcp_port_high (context)</a>.</dd></dl>
<p>The common sequence of operations during application initialization is minimally shown below. In the code fragments below, error detection and handling are omitted for clarity.</p>
<ol>
<li>
<p class="startli">Create a context attribute object and set the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#transportmappingfunctioncontext">transport_mapping_function (context)</a> option to point at the application's XSP mapping callback function using the structure <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a90dde1ea00f12038cff7195c76d47a46">lbm_transport_mapping_func_t</a>.</p>
<pre class="fragment">  lbm_context_attr_t *ctx_attr;
  err = lbm_context_attr_create_from_xml(&amp;ctx_attr, "MyCtx");

  lbm_transport_mapping_func_t mapping_func;
  mapping_func.mapping_func = app_xsp_mapper_callback;
  mapping_func.clientd = NULL;             /* Can include app state pointer. */

  err = lbm_context_attr_setopt(ctx_attr, "transport_mapping_function",
          &amp;mapping_func, sizeof(mapping_func));
</pre><p class="endli"></p>
</li>
<li>
<p class="startli">Create the context.</p>
<pre class="fragment">  err = lbm_context_create(&amp;ctx, ctx_attr, NULL, NULL);
  err = lbm_context_attr_delete(ctx_attr);  /* No longer needed. */
</pre><p class="endli"></p>
</li>
<li>
<p class="startli">Create XSPs using <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ae38035c6036a84f07f9ba7cee1747dbf">lbm_xsp_create()</a>. In this example, only a single XSP is created.</p>
<pre class="fragment">  lbm_xsp_t *xsp;  /* app_xsp_mapper_callback() needs this; see below. */
  err = lbm_xsp_create(&amp;xsp, ctx, NULL, NULL);
</pre><p>Note that the application can optionally pass in a context attribute object and an XSP attribute object. The context attribute is because XSP is implemented as a sort of reduced-function sub-context, and so it is possible to modify context options for the XSP. However, this is rarely needed since the default action is for the XSP to inherit all the configuration of the main context.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Create a receiver for topic "X".</p>
<pre class="fragment">  lbm_topic_t *topic;
  err = lbm_rcv_topic_lookup(&amp;topic, ctx, "X", NULL);

  lbm_rcv_t *rcv;
  err = lbm_rcv_create(&amp;rcv, ctx, topic, app_rcv_callback, NULL, NULL);
</pre><p><a class="el" href="fundamentalconcepts.html#eventqueueobject">Event queues</a> may also be used with XSP-assigned Transport Sessions.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">At this point, when the main context discovers a source for topic "X", it will proceed to join the Transport Session. It will call the application's app_xsp_mapper_callback() function, which is minimally this:</p>
<pre class="fragment">lbm_xsp_t *app_xsp_mapper_callback(lbm_context_t *ctx,
        lbm_new_transport_info_t *transp_info, void *clientd)
{
  /* Retrieve the XSP object created in step 3. */
  return xsp;
}
</pre><p>This minimal callback simply returns the XSP that was created during initialization (the "clientd" can be helpful for that). By assigning all receiver Transport Sessions to the same XSP, you have effectively separated message processing from UM housekeeping tasks, like processing of topic resolution and timers. This can greatly reduce latency outliers.</p>
<p class="endli">As described in <a class="el" href="umfeatures.html#xsphandlestransportsessionsnottopics">XSP Handles Transport Sessions, Not Topics</a>, some users want to have multiple XSPs and assign the Transport Sessions to XSPs according to application logic. Note that the passed-in <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ac611697e7263b4b5ea5a3b35eb26dc99">lbm_new_transport_info_t</a> structure contains information about the Transport Session, such as the IP address of the sender. However, this structure does not contain topic information. Applications can use the resolver's source notification callback via the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#resolversourcenotificationfunctioncontext">resolver_source_notification_function (context)</a> attribute option to associate topics with source strings. </p>
</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Most of the time, the application mapping callback will be invoked each time a Transport Session is joined. However, there is one exception to this rule. If a context is already joined to a Transport Session carried on a multicast group and destination port, joining another Transport Session on the same multicast group and destination port does not invoke the mapping callback again. This is because the same socket is used for all Transport Sessions that use the same group:port.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="otherxspoperations"></a>
Other XSP Operations&nbsp;&nbsp;<small><a href="#otherxspoperations">&lt;-</a></small></h2>
<p>As of UM 6.12, XSP supports persistent receivers.</p>
<p>When an XSP object is created, an XSP attribute object can be supplied to set XSP options. The XSP options are: </p><ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#operationalmodexsp">operational_mode (xsp)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#zerotransportsfunctionxsp">zero_transports_function (xsp)</a> </li>
</ul>
<p>To create and manipulate an XSP attribute object, see: </p><ul>
<li>
lbm_xsp_attr_create_from_xml() </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ae52cbac6a22b495a3b48a70bf23fc118">lbm_xsp_attr_setopt()</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a62363973a939a8555eac38846492dbb2">lbm_xsp_attr_getopt()</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#adfc416faf8fbc79cfd16a1485341f469">lbm_xsp_attr_delete()</a> </li>
</ul>
<p>To delete an XSP, all receivers associated with Transport Sessions handled by that XSP must first be deleted. Then the XSP can be deleted using <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ac61812a1c86eb9d240054f9d3ba32ac5">lbm_xsp_delete()</a>.</p>
<p>To register and cancel an application file descriptor with an XSP, see: </p><ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ae289a20cdc857feeda3eaba9f286b946">lbm_xsp_register_fd()</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aa8d3582b9bb8126a34924063ed00b8c4">lbm_xsp_cancel_fd()</a> </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="xsplimitations"></a>
XSP Limitations&nbsp;&nbsp;<small><a href="#xsplimitations">&lt;-</a></small></h2>
<p>There are some restrictions and limitations on the XSP feature.</p>
<ul>
<li>
<p class="startli">The only transport types currently supported are LBT-RM, LBT-RU, and TCP. IPC, SMX, DBL, and BROKER are not supported with XSPs at this time.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">For a persistent receiver assigned to an XSP, the user is not allowed to disable <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeproactivekeepaliveintervalcontext">ume_proactive_keepalive_interval (context)</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The ULB feature is not currently supported.</p>
<p class="endli"></p>
</li>
<li>
The use of XSP is not currently compatible with <a class="el" href="umobjects.html#hotfailoverhf">Hot Failover (HF)</a>. If you desire to use Hot Failover with XSP, contact Support. </li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="usinglatejoin"></a>
Using Late Join&nbsp;&nbsp;<small><a href="#usinglatejoin">&lt;-</a></small></h1>
<p>This section introduces the use of Ultra Messaging Late Join in default and specialized configurations. See <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html">Late Join Options</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>If your application is running within a Ultra Messaging context with configuration option <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpunicastimmediatemessagingnetwork.html#requesttcpbindrequestportcontext">request_tcp_bind_request_port (context)</a> set to zero, then UIM port binding has been turned off, which also disables the Late Join feature.</dd>
<dd>
With the UMQ product, you cannot use Late Join with Queuing (both Brokered and ULB).</dd></dl>
<p>The Late Join feature enables newly created receivers to receive previously transmitted messages. Sources configured for Late Join maintain a retention buffer (not to be confused with a transport retransmission window), which holds transmitted messages for late-joining receivers.</p>
<p>A Late Join operation follows the following sequence:</p>
<ol>
<li>
A new receiver configured for Late Join with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#uselatejoinreceiver">use_late_join (receiver)</a> completes topic resolution. Topic advertisements from the source contain a flag that indicates the source is configured for Late Join with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#latejoinsource">late_join (source)</a>. </li>
<li>
The new receiver sends a Late Join Information Request (LJIR) to request a previously transmitted messages. The receiver configuration option, <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestoutstandingmaximumreceiver">retransmit_request_outstanding_maximum (receiver)</a>, determines the number of messages the receiver requests. </li>
<li>
The source responds with a Late Join Information (LJI) message containing the sequence numbers for the retained messages that are available for retransmission. </li>
<li>
The source unicasts the messages. </li>
<li>
When <a class="el" href="umfeatures.html#configuringlatejoinforlargenumbersofmessages">Configuring Late Join for Large Numbers of Messages</a>, the receiver issues additional requests, and the source retransmits these additional groups of older messages, oldest first. </li>
</ol>
<div class="image">
<img src="LateJoin.png" alt="LateJoin.png"/>
</div>
 <p>The source's retention buffer's is not pre-allocated and occupies an increasing amount of memory as the source sends messages and adds them to the buffer. If a retention buffer grows to a size equal to the value of the source configuration option, <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizethresholdsource">retransmit_retention_size_threshold (source)</a>, the source deletes older messages as it adds new ones. The source configuration option <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpdeprecated.html#retransmitretentionagethresholdsource">retransmit_retention_age_threshold (source)</a>, controls message deletion based on message age.</p>
<p>UM uses control-structure overhead memory on a per-message basis for messages held in the retention buffer, in addition to the retention buffer's memory. Such memory usage can become significantly higher when retained messages are smaller in size, since more of them can then fit in the retention buffer.</p>
<dl class="section note"><dt>Note</dt><dd>If you set the receiver configuration option <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#ordereddeliveryreceiver">ordered_delivery (receiver)</a> to 1, the receiver must deliver messages to your application in sequence number order. The receiver holds out-of-order messages in an ordered list cache until messages arrive to fill the sequence number gaps. If an out-of-order message arrives with a sequence number that creates a message gap greater than the value of <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitmessagecachingproximityreceiver">retransmit_message_caching_proximity (receiver)</a>, the receiver creates a burst loss event and terminates the Late Join recovery operation. You can increase the value of the proximity option and restart the receiver, but a burst loss is a significant event and you should investigate your network and message system components for failures.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="latejoinwithump"></a>
Late Join With Persistence&nbsp;&nbsp;<small><a href="#latejoinwithump">&lt;-</a></small></h2>
<p>With the UMP/UMQ products, late Join can be implemented in conjunction with the Persistent Store, however in this configuration, it functions somewhat differently from Streaming. After a late-Join-enabled receiver has been created, resolved a topic, and become registered with a store, it may then request older messages. The store unicasts the retransmission messages. If the store does not have these messages, it requests them of the source (assuming option retransmission-request-forwarding is enabled), thus initiating Late Join.</p>
<p><br />
 </p>
<h2><a class="anchor" id="latejoinoptionssummary"></a>
Late Join Options Summary&nbsp;&nbsp;<small><a href="#latejoinoptionssummary">&lt;-</a></small></h2>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#latejoinsource">late_join (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpdeprecated.html#retransmitretentionagethresholdsource">retransmit_retention_age_threshold (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizelimitsource">retransmit_retention_size_limit (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizethresholdsource">retransmit_retention_size_threshold (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#uselatejoinreceiver">use_late_join (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitinitialsequencenumberrequestreceiver">retransmit_initial_sequence_number_request (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitmessagecachingproximityreceiver">retransmit_message_caching_proximity (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestmessagetimeoutreceiver">retransmit_request_message_timeout (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestintervalreceiver">retransmit_request_interval (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestmaximumreceiver">retransmit_request_maximum (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestoutstandingmaximumreceiver">retransmit_request_outstanding_maximum (receiver)</a> </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="usingdefaultlatejoinoptions"></a>
Using Default Late Join Options&nbsp;&nbsp;<small><a href="#usingdefaultlatejoinoptions">&lt;-</a></small></h2>
<p>To implement Late Join with default options, set the Late Join configuration options to activate the feature on both a source and receiver in the following manner.</p>
<ol>
<li>
<p class="startli">Create a configuration file with source and receiver Late Join activation options set to 1. For example, file cfg1.cfg containing the two lines:</p>
<pre class="fragment">source late_join 1
receiver use_late_join 1
</pre><p class="endli"></p>
</li>
<li>
<p class="startli">Run an application that starts a Late-Join-enabled source. For example:</p>
<pre class="fragment">lbmsrc -c cfg1.cfg -P 1000 topicName
</pre><p class="endli"></p>
</li>
<li>
<p class="startli">Wait a few seconds, then run an application that starts a Late-Join-enabled receiver. For example:</p>
<pre class="fragment">lbmrcv -c cfg1.cfg -v topicName
</pre> </li>
</ol>
<p>The output for each should closely resemble the following:</p>
<p><b>LBMSRC</b></p>
<pre class="fragment">$ lbmsrc -c cfg1.cfg -P 1000 topicName
LOG Level 5: NOTICE: Source "topicName" has no retention settings (1 message retained max)
Sending 10000000 messages of size 25 bytes to topic [topicName]
Receiver connect [TCP:10.29.3.77:34200]
</pre><p><b>LBMRCV</b></p>
<pre class="fragment">$ lbmrcv -c cfg1.cfg -v topicName
Immediate messaging target: TCP:10.29.3.77:4391
[topicName][TCP:10.29.3.76:4371][2]-RX-, 25 bytes
1.001 secs. 0.0009988 Kmsgs/sec. 0.1998 Kbps
[topicName][TCP:10.29.3.76:4371][3], 25 bytes
1.002 secs. 0.0009982 Kmsgs/sec. 0.1996 Kbps
[topicName][TCP:10.29.3.76:4371][4], 25 bytes
1.003 secs. 0.0009972 Kmsgs/sec. 0.1994 Kbps
[topicName][TCP:10.29.3.76:4371][5], 25 bytes
1.003 secs. 0.0009972 Kmsgs/sec. 0.1994 Kbps
...
</pre><p>Note that the source only retained 1 Late Join message (due to default retention settings) and that this message appears as a retransmit (-RX-). Also note that it is possible to sometimes receive 2 RX messages in this scenario (see <a class="el" href="umfeatures.html#retransmittingonlyrecentmessages">Retransmitting Only Recent Messages</a>.)</p>
<p><br />
 </p>
<h2><a class="anchor" id="specifyingarangeofmessagestoretransmit"></a>
Specifying a Range of Messages to Retransmit&nbsp;&nbsp;<small><a href="#specifyingarangeofmessagestoretransmit">&lt;-</a></small></h2>
<p>To receive more than one or two Late Join messages, increase the source's <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizethresholdsource">retransmit_retention_size_threshold (source)</a> from its default value of 0. Once the buffer exceeds this threshold, the source allows the next new message entering the retention buffer to bump out the oldest one. Note that this threshold's units are bytes (which includes a small overhead per message).</p>
<p>While the retention threshold endeavors to keep the buffer size close to its value, it does not set hard upper limit for retention buffer size. For this, the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizelimitsource">retransmit_retention_size_limit (source)</a> configuration option (also in bytes) sets this boundary.</p>
<p>Follow the steps below to demonstrate how a source can retain about 50MB of messages, but no more than 60MB:</p>
<ol>
<li>
<p class="startli">Create a second configuration file (cfg2.cfg) with the following options:</p>
<pre class="fragment">source late_join 1
source retransmit_retention_size_threshold 50000000
source retransmit_retention_size_limit 60000000
receiver use_late_join 1
</pre> </li>
<li>
Run lbmsrc -c cfg2.cfg -P 1000 topicName. </li>
<li>
Wait a few seconds and run <code>lbmrcv -c cfg2.cfg -v topicName</code>. The output for each should closely resemble the following: </li>
</ol>
<p><b>LBMSRC</b></p>
<pre class="fragment">$ lbmsrc -c cfg2.cfg -P 1000 topicName
Sending 10000000 messages of size 25 bytes to topic [topicName]
Receiver connect [TCP:10.29.3.76:34444]
</pre><p><b>LBMRCV</b></p>
<pre class="fragment">$ lbmrcv -c cfg2.cfg -v topicName
Immediate messaging target: TCP:10.29.3.76:4391
[topicName][TCP:10.29.3.77:4371][0]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][1]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][2]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][3]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][4]-RX-, 25 bytes
1.002 secs. 0.004991 Kmsgs/sec. 0.9981 Kbps
[topicName][TCP:10.29.3.77:4371][5], 25 bytes
1.002 secs. 0.0009984 Kmsgs/sec. 0.1997 Kbps
[topicName][TCP:10.29.3.77:4371][6], 25 bytes
1.002 secs. 0.0009983 Kmsgs/sec. 0.1997 Kbps
[topicName][TCP:10.29.3.77:4371][7], 25 bytes
...
</pre><p>Note that lbmrcv received live messages with sequence numbers 7, 6, and 5, and RX messages going from 4 all the way back to Sequence Number 0.</p>
<p><br />
 </p>
<h2><a class="anchor" id="retransmittingonlyrecentmessages"></a>
Retransmitting Only Recent Messages&nbsp;&nbsp;<small><a href="#retransmittingonlyrecentmessages">&lt;-</a></small></h2>
<p>Thus far we have worked with only source late join settings, but suppose that you want to receive only the last 10 messages. To do this, configure the receiver option <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestmaximumreceiver">retransmit_request_maximum (receiver)</a> to set how many messages to request backwards from the latest message.</p>
<p>Follow the steps below to set this option to 10.</p>
<ol>
<li>
<p class="startli">Add the following line to cfg2.cfg and rename it cfg3.cfg:</p>
<pre class="fragment">receiver retransmitrequestmaximumreceiver 10
</pre><p class="endli"></p>
</li>
<li>
<p class="startli">Run:</p>
<pre class="fragment">lbmsrc -c cfg3.cfg -P 1000 topicName
</pre><p class="endli"></p>
</li>
<li>
Wait a few seconds and run <code>lbmrcv -c cfg3.cfg -v topicName</code>. The output for each should closely resemble the following. </li>
</ol>
<p><b>LBMSRC</b></p>
<pre class="fragment">$ lbmsrc -c cfg3.cfg -P 1000 topicName
Sending 10000000 messages of size 25 bytes to topic [topicName]
Receiver connect [TCP:10.29.3.76:34448]
</pre><p><b>LBMRCV</b></p>
<pre class="fragment">$ lbmrcv -c cfg3.cfg -v topicName
Immediate messaging target: TCP:10.29.3.76:4391
[topicName][TCP:10.29.3.77:4371][13]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][14]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][15]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][16]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][17]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][18]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][19]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][20]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][21]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][22]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][23]-RX-, 25 bytes
1.002 secs. 0.01097 Kmsgs/sec. 2.195 Kbps
[topicName][TCP:10.29.3.77:4371][24], 25 bytes
1.002 secs. 0.0009984 Kmsgs/sec. 0.1997 Kbps
[topicName][TCP:10.29.3.77:4371][25], 25 bytes
1.002 secs. 0.0009984 Kmsgs/sec. 0.1997 Kbps
[topicName][TCP:10.29.3.77:4371][26], 25 bytes
...
</pre><p>Note that 11, not 10, retransmits were actually received. This can happen because network and timing circumstances may have one RX already in transit while the specific RX amount is being processed. (Hence, it is not possible to guarantee one and only one RX message for every possible Late Join recovery.)</p>
<p><br />
 </p>
<h2><a class="anchor" id="configuringlatejoinforlargenumbersofmessages"></a>
Configuring Late Join for Large Numbers of Messages&nbsp;&nbsp;<small><a href="#configuringlatejoinforlargenumbersofmessages">&lt;-</a></small></h2>
<p>Suppose you have a persistent receiver that comes up at midday and must gracefully catch up on the large number of messages it has missed. The following discussion explains the relevant Late Join options and how to use them. (The discussion also applies to streaming-based late join, but since streaming sources must hold all retained messages in memory, there are typically far fewer messages available.)</p>
<p><b>Option:</b> <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestoutstandingmaximumreceiver">retransmit_request_outstanding_maximum (receiver)</a></p>
<p>When a receiver comes up and begins requesting Late Join messages, it does not simply request messages starting at Sequence Number 0 through 1000000. Rather, it requests the messages a little at a time, depending upon how option <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestoutstandingmaximumreceiver">retransmit_request_outstanding_maximum (receiver)</a> is set. For example, when set to the default of 10, the receiver sends requests the first 10 messages (Sequence Number 0 - 9). Upon receiving Sequence Number 0, it then requests the next message (10), and so on, limiting the number of outstanding unfulfilled requests to 10.</p>
<p>Note that higher for values retransmit_request_outstanding_maximum can increase the rate of RXs received, which can reduce the time required for receiver recovery. However, this can lead to heavy loading of the Store, potentially making it unable to sustain the incoming data rate.</p>
<p>Also, be aware that increasing retransmit_request_outstanding_maximum may require a corresponding increase to <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestintervalreceiver">retransmit_request_interval (receiver)</a>. Otherwise you can have a situation where messages time out because it takes a store longer than retransmit_request_interval to process all retransmit_request_outstanding_maximum requests. When this happens, you can see messages needlessly requested and sent many times (generates warnings to the receiver application log file).</p>
<p><b>Option:</b> <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitmessagecachingproximityreceiver">retransmit_message_caching_proximity (receiver)</a></p>
<p>When sequence number delivery order is used, long recoveries of active sources can create receiver memory cache problems due to the processing of both new and retransmitted messages. This option provides a method to control caching and cache size during recovery.</p>
<p>It does this by comparing the option value (default 2147483647) to the difference between the newest (live) received sequence number and the latest received RX sequence number. If the difference is less than the option's value, the receiver caches incoming live new messages. Otherwise, new messages are dropped and not cached (with the assumption that they can be requested later as retransmissions).</p>
<p>For example, as shown in the diagram below, a receiver may be receiving both live streaming messages (latest, #200) and catch-up retransmissions (latest, #100). The difference here is 100. If <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitmessagecachingproximityreceiver">retransmit_message_caching_proximity (receiver)</a> is 75, the receiver caches the live messages and will deliver them when it is all caught up with the retransmissions. However, if this option is 150, streamed messages are dropped and later picked up again as a retransmission.</p>
<div class="image">
<img src="proximity_option.png" alt="proximity_option.png"/>
</div>
 <p>The default value of this option is high enough to still encourage caching most of the time, and should be optimal for most receivers.</p>
<p>If your source streams faster than it retransmits, caching is beneficial, as it ensures new data are received only once, thus reducing recovery time. If the source retransmits faster than it streams, which is the optimal condition, you can lower the value of this option to use less memory during recovery, with little performance impact.</p>
<p><br />
 </p>
<h1><a class="anchor" id="offtransportrecoveryotr"></a>
Off-Transport Recovery (OTR)&nbsp;&nbsp;<small><a href="#offtransportrecoveryotr">&lt;-</a></small></h1>
<p>Off-Transport Recovery (OTR) is a lost-message-recovery feature that provides a level of hedging against the possibility of brief and incidental unrecoverable loss at the transport level or from a <a class="el" href="fundamentalconcepts.html#umrouter">UM Router</a>. This section describes the OTR feature.</p>
<dl class="section note"><dt>Note</dt><dd>With the UMQ product, you cannot use OTR with Queuing (both Brokered and ULB).</dd></dl>
<p>When a transport cannot recover lost messages, OTR engages and looks to the source for message recovery. It does this by accessing the source's retention buffer (used also by the Late Join feature) to re-request messages that no longer exist in a transport's transmission window, or other places such as a Persistent Store or redundant source.</p>
<p>OTR functions in a manner very similar to that of Late Join, but differs mainly in that it activates in message loss situations rather than following the creation of a receiver, and shares only the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#latejoinsource">late_join (source)</a> option setting.</p>
<p>Upon detecting loss, a receiver initiates OTR by sending repeated, spaced, OTR requests to the source, until it recovers lost messages or a timeout period elapses.</p>
<p>OTR operates independently from transport-level recovery mechanisms such as NAKs for LBT-RU or LBT-RM. When you enable OTR for a receiver with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#useotrreceiver">use_otr (receiver)</a>, the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrrequestinitialdelayreceiver">otr_request_initial_delay (receiver)</a> period starts as soon as the <a class="el" href="architecture.html#deliverycontroller">Delivery Controller</a> detects a sequence gap. If the gap is not resolved by the end of the delay interval, OTR recovery initiates. OTR recovery can occur before, during or after transport-level recovery attempts.</p>
<p>When a receiver initiates OTR, the intervals between OTR requests increases twofold after each request, until the maximum interval is reached (assuming the receiver is still waiting to receive the retransmission). You use configuration options <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrrequestminimumintervalreceiver">otr_request_minimum_interval (receiver)</a> and <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrrequestmaximumintervalreceiver">otr_request_maximum_interval (receiver)</a> to set the initial (minimum) and maximum intervals, respectively.</p>
<p>The source retransmits lost messages to the recovered receiver via unicast.</p>
<p><br />
 </p>
<h2><a class="anchor" id="otrwithsequencenumberordereddelivery"></a>
OTR with Sequence Number Ordered Delivery&nbsp;&nbsp;<small><a href="#otrwithsequencenumberordereddelivery">&lt;-</a></small></h2>
<p>When sequence number delivery order is used and a gap of missing messages occurs, a receiver buffers the new incoming messages while it attempts to recover the earlier missing ones. Long recoveries of actively streaming sources can cause excessive receiver cache memory growth due to the processing of both new and retransmitted messages. You can control caching and cache size during recovery with options <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrmessagecachingthresholdreceiver">otr_message_caching_threshold (receiver)</a> and <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitmessagecachingproximityreceiver">retransmit_message_caching_proximity (receiver)</a>.</p>
<p>The option <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrmessagecachingthresholdreceiver">otr_message_caching_threshold (receiver)</a> sets the maximum number of messages a receiver can buffer. When the number of cached messages hits this threshold, new streamed messages are dropped and not cached, with the assumption that they can be requested later as retransmissions.</p>
<p>The <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitmessagecachingproximityreceiver">retransmit_message_caching_proximity (receiver)</a>, which is also used by Late Join (see <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitmessagecachingproximityreceiver">retransmit_message_caching_proximity (receiver)</a>), turns off this caching if there are too many messages to buffer between the last delivered message and the currently streaming messages.</p>
<p>Both of these option thresholds must be satisfied before caching resumes.</p>
<p><br />
 </p>
<h2><a class="anchor" id="otrwithump"></a>
OTR With Persistence&nbsp;&nbsp;<small><a href="#otrwithump">&lt;-</a></small></h2>
<p>With the UMP/UMQ products, you can implement OTR in conjunction with the Persistent Store, however in this configuration, it functions somewhat differently from Streaming. If an OTR-enabled receiver registered with a store detects a sequence gap in the live stream and that gap is not resolved by other means within the next <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrrequestinitialdelayreceiver">otr_request_initial_delay (receiver)</a> period, the receiver requests those messages from the store(s). If the store does not have some of the requested messages, the receiver requests them from the source. Regardless of whether the messages are recovered from a store or from the source, OTR delivers all recovered messages with the LBM_MSG_OTR flag, unlike Late Join, which uses the LBM_MSG_RETRANSMIT flag.</p>
<p><br />
 </p>
<h2><a class="anchor" id="otroptionssummary"></a>
OTR Options Summary&nbsp;&nbsp;<small><a href="#otroptionssummary">&lt;-</a></small></h2>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#latejoinsource">late_join (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpdeprecated.html#retransmitretentionagethresholdsource">retransmit_retention_age_threshold (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizelimitsource">retransmit_retention_size_limit (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizethresholdsource">retransmit_retention_size_threshold (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#useotrreceiver">use_otr (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrrequestmessagetimeoutreceiver">otr_request_message_timeout (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrrequestinitialdelayreceiver">otr_request_initial_delay (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrrequestlogalertcooldownreceiver">otr_request_log_alert_cooldown (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrrequestmaximumintervalreceiver">otr_request_maximum_interval (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrrequestminimumintervalreceiver">otr_request_minimum_interval (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrrequestoutstandingmaximumreceiver">otr_request_outstanding_maximum (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrmessagecachingthresholdreceiver">otr_message_caching_threshold (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitmessagecachingproximityreceiver">retransmit_message_caching_proximity (receiver)</a> </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>With <a class="el" href="advancedoptimizations.html#smartsources">Smart Sources</a>, the following configuration options have limited or no support: <ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizethresholdsource">retransmit_retention_size_threshold (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizelimitsource">retransmit_retention_size_limit (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpdeprecated.html#retransmitretentionagethresholdsource">retransmit_retention_age_threshold (source)</a> </li>
</ul>
</dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="encryptedtcp"></a>
Encrypted TCP&nbsp;&nbsp;<small><a href="#encryptedtcp">&lt;-</a></small></h1>
<p>This section introduces the use of Transport Layer Security (TLS), sometimes known by its older designation Secure Sockets Layer (SSL).</p>
<p>The goal of the Ultra Messaging (UM) TLS feature is to provide encrypted transport of application data. TLS supports authentication (through certificates), data confidentiality (through encryption), and data integrity (ensuring data are not changed, removed, or added-to). UM can be configured to apply TLS security measures to all Streaming and/or Persisted TCP communication, including <a class="el" href="fundamentalconcepts.html#umrouter">UM Router</a> peer links. Non-TCP communication is not encrypted (e.g. topic resolution).</p>
<p>TLS is a family of standard protocols and algorithms for securing TCP communication between a client and a server. It is sometimes referred as "SSL", which technically is the name of an older (less secure) version of the protocol. Over the years, security researchers (and hackers) have discovered flaws in SSL/TLS. However, the vast majority of the widely publicized security vulnerabilities have been flaws in the implementations of TLS, not in the recent TLS protocols or algorithms themselves. As of UM version 6.9, there are no known security weaknesses in TLS version 1.2, the version used by UM.</p>
<p>TLS is generally implemented by several different software packages. UM makes use of OpenSSL, a widely deployed and actively maintained open-source project.</p>
<p><br />
 </p>
<h2><a class="anchor" id="tlsauthentication"></a>
TLS Authentication&nbsp;&nbsp;<small><a href="#tlsauthentication">&lt;-</a></small></h2>
<p>TLS authentication uses X.509 digital certificates. Certificate creation and management is the responsibility of the user. Ultra Messaging's usage of OpenSSL expects PEM encoded certificates. There are a variety of generally available tools for converting certificates between different encodings. Since user infrastructures vary widely, the UM package does not include tools for creation, formatting, or management of certificates.</p>
<p>Although UM is designed as a peer-to-peer messaging system, TLS has the concept of client and server. The client initiates the TCP connection and the server accepts it. In the case of a TCP source, the receiver initiates and is therefore the client, with the source (sender of data) being the server. However, with unicast immediate messages, the sender of data is the client, and the recipient is the server. Due to the fact that unicast immediate messages are used by UM for internal control and coordination, it is typically not possible to constrain a given application to only operate as a pure client or pure server. For this reason, UM requires all applications participating in encryption to have a certificate. Server-only authentication (i.e. anonymous client, as is used by web browsers) is not supported. It is permissible for groups of processes, or even all processes, to share the same certificate.</p>
<p>A detailed discussion of certificate usage is beyond the scope of the Ultra Messaging documentation.</p>
<p><br />
 </p>
<h2><a class="anchor" id="tlsbackwardscompatibility"></a>
TLS Backwards Compatibility&nbsp;&nbsp;<small><a href="#tlsbackwardscompatibility">&lt;-</a></small></h2>
<p>The TLS protocol was designed to allow for a high degree of backwards compatibility. During the connection establishment phase, the client and server perform a negotiation handshake in which they identify the highest common versions of various security options. For example, an old web browser might pre-date the introduction of TLS and only support the older SSL protocol. OpenSSL is often configured to allow clients and servers to "negotiate down" to those older, less-secure protocols or algorithms.</p>
<p>Ultra Messaging has the advantage of not needing to communicate with old versions of SSL or TLS. UM's default configuration directs OpenSSL to require both the client and the server to use protocols and algorithms which were highly regarded, as of UM's release date. If vulnerabilities are discovered in the future, the user can override UM's defaults and chose other protocols or algorithms.</p>
<p><br />
 </p>
<h2><a class="anchor" id="tlsefficiency"></a>
TLS Efficiency&nbsp;&nbsp;<small><a href="#tlsefficiency">&lt;-</a></small></h2>
<p>When a TLS connection is initiated, a handshake takes place prior to application data encryption. Once the handshake is completed, the CPU effort required to encrypt and decrypt application data is minimal. However, the handshake phase involves the use of much less efficient algorithms.</p>
<p>There are two factors under the user's control, which greatly affect the handshake efficiency: the choice of cipher suite and the key length. We have seen an RSA key of 8192 bits take 4 seconds of CPU time on a 1.3GHz SparcV9 processor just to complete the handshake for a single TLS connection.</p>
<p>Users should make their choices with an understanding of the threat profiles they are protecting against. For example, it is estimated that a 1024-bit RSA key can be broken in about a year by brute force using specialized hardware (see <a href="http://www.tau.ac.il/~tromer/papers/cbtwirl.pdf">http://www.tau.ac.il/~tromer/papers/cbtwirl.pdf</a>). This may be beyond the means of the average hacker, but well within the means of a large government. RSA keys of 2048 bits are generally considered secure for the foreseeable future.</p>
<p><br />
 </p>
<h2><a class="anchor" id="tlsconfiguration"></a>
TLS Configuration&nbsp;&nbsp;<small><a href="#tlsconfiguration">&lt;-</a></small></h2>
<p>TLS is enabled on a context basis. When enabled, all Streaming and Persistence related TCP-based communication into or out of the context is encrypted by TLS. A context with TLS enabled will not accept source creation with transports other than TCP.</p>
<p>Subscribers will only successfully receive data if the receiver's context and the source's context share the same encryption settings. A receiver created in an encrypted enabled context will ignore topic resolution source advertisements for non-encrypted sources, and will therefore not subscribe. Similarly, a receiver created in a non-encrypted context will ignore topic resolution source advertisements for encrypted sources. Topic resolution queries are also ignored by mismatched contexts. No warning will be logged when these topic resolution datagrams are ignored, but each time this happens, the context-level statistic tr_dgrams_dropped_type is incremented.</p>
<p>TLS is applied to unicast immediate messages as well, as invoked either directly by the user, or internally by functions like late join, request/response, and Persistence-related communication between sources, receivers, and stores.</p>
<p>Brokered Queuing using AMQP does not use the UM TLS feature. A UM brokered context does not allow TLS to be enabled.</p>
<p><br />
 </p>
<h2><a class="anchor" id="tlsoptionssummary"></a>
TLS Options Summary&nbsp;&nbsp;<small><a href="#tlsoptionssummary">&lt;-</a></small></h2>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpencryptedtcp.html#usetlscontext">use_tls (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpencryptedtcp.html#tlsciphersuitescontext">tls_cipher_suites (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpencryptedtcp.html#tlscertificatecontext">tls_certificate (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpencryptedtcp.html#tlscertificatekeycontext">tls_certificate_key (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpencryptedtcp.html#tlscertificatekeypasswordcontext">tls_certificate_key_password (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpencryptedtcp.html#tlstrustedcertificatescontext">tls_trusted_certificates (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpencryptedtcp.html#tlscompressionnegotiationtimeoutcontext">tls_compression_negotiation_timeout (context)</a> </li>
</ul>
<p>The <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpencryptedtcp.html#tlsciphersuitescontext">tls_cipher_suites (context)</a> configuration option defines the list of one or more (comma separated) cipher suites that are acceptable to this context. If more than one is supplied, they should be in descending order of preference. When a remote context negotiates encrypted TCP, the two sides must find a cipher suite in common, otherwise the connection will be canceled.</p>
<p>OpenSSL uses the cipher suite to define the algorithms and key lengths for encrypting the data stream. The choice of cipher suite is critical for ensuring the security of the connection. To achieve a high degree of backwards compatibility, OpenSSL supports old cipher suites which are no longer considered secure. The user is advised to use UM's default suite.</p>
<p>OpenSSL follows its own naming convention for cipher suites. See <a href="https://www.openssl.org/docs/man1.1.0/man1/ciphers.html">https://www.openssl.org/docs/man1.1.0/man1/ciphers.html</a> for a list of valid suite names (the ones with dashes) and the equivalent IANA names (with underscores). The UM configuration should use the OpenSSL-style names (with dashes).</p>
<p><br />
 </p>
<h2><a class="anchor" id="tlsandpersistence"></a>
TLS and Persistence&nbsp;&nbsp;<small><a href="#tlsandpersistence">&lt;-</a></small></h2>
<p>TLS is designed to encrypt a TCP connection, and works with TCP-based persisted data <a class="el" href="fundamentalconcepts.html#transportsessions">Transport Sessions</a> and control traffic. However, TLS is not intended to encrypt data at rest. When a Persistent Store is used with the UM TLS feature, the user messages are written to disk in plaintext form, not encrypted.</p>
<p><br />
 </p>
<h2><a class="anchor" id="tlsandqueuing"></a>
TLS and Queuing&nbsp;&nbsp;<small><a href="#tlsandqueuing">&lt;-</a></small></h2>
<p>The UM TLS feature does not apply to the AMQP connection to the brokered queue. UM does not currently support security on the AMQP connection.</p>
<p>However, the ULB form of queuing does not use a broker. For ULB sources that are configured for TCP, the UM TLS feature will encrypt the application data.</p>
<p><br />
 </p>
<h2><a class="anchor" id="tlsandthedynamicroutingoptiondro"></a>
TLS and the Dynamic Routing Option (DRO)&nbsp;&nbsp;<small><a href="#tlsandthedynamicroutingoptiondro">&lt;-</a></small></h2>
<p>When a <a class="el" href="fundamentalconcepts.html#umrouter">UM Router</a> is used to route messages across <a class="el" href="fundamentalconcepts.html#topicresolutiondomain">Topic Resolution Domains</a> (TRDs), be aware that the TLS session is terminated at the UM Router's proxy receiver/source. Because each endpoint portal on a UM Router is implemented with its own context, care must be taken to ensure end-to-end security. It is possible to have a TLS source publishing in one TRD, received by a UM Router (via an endpoint portal also configured for TLS), and re-published to a different TRD via an endpoint portal configured with a non-encrypted context. This would allow a non-encrypted receiver to access messages that the source intended to be encrypted. As a message is forwarded through a UM Router network, it does not propagate the security settings of the originator, so each portal needs to be appropriately encrypted. The user is strongly encouraged to configure ALL portals on an interconnected network of UM Routers with the same encryption settings.</p>
<p>The encryption feature is extended to UM Router peer links, however peer links are not context-based and are not configured the same way. The following XML elements are used by the UM Router to configure a peer link:</p>
<ul>
<li>
'<b>&lt;tls&gt;</b>' </li>
<li>
'<b>&lt;cipher-suites&gt;</b>' </li>
<li>
'<b>&lt;certificate&gt;</b>' </li>
<li>
'<b>&lt;certificate-key&gt;</b>' </li>
<li>
'<b>&lt;certificate-key-password&gt;</b>' </li>
<li>
'<b>&lt;trusted-certificates&gt;</b>' </li>
</ul>
<p>As with sources and receivers, the portals on both sides of a peer link must be configured for compatible encryption settings.</p>
<p>Notice that there is no element corresponding to the context option <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpencryptedtcp.html#tlscompressionnegotiationtimeoutcontext">tls_compression_negotiation_timeout (context)</a>. The UM Router peer link's negotiation timeout is hard-coded to 5 seconds.</p>
<p>See the UM Router configuration DTD for details.</p>
<p><br />
 </p>
<h2><a class="anchor" id="tlsandcompression"></a>
TLS and Compression&nbsp;&nbsp;<small><a href="#tlsandcompression">&lt;-</a></small></h2>
<p>Many users have advanced network equipment (switches/routers), which transparently compress packets as they traverse the network. This compression is especially valued to conserve bandwidth over long-haul WAN links. However, when packets are encrypted, the network compressors are typically not able to reduce the size of the data. If the user desires UM messages to be compressed and encrypted, the data needs to be compressed before it is encrypted.</p>
<p>The UM compression feature (see <a class="el" href="umfeatures.html#compressedtcp">Compressed TCP</a>) accomplishes this. When both TLS and compression are enabled, the compression is applied to user data first, then encryption.</p>
<p>Be aware that there can be information leakage when compression is applied and an attacker is able to inject data of known content over a compressed and encrypted session. For example, this leakage is exploited by the <a href="https://en.wikipedia.org/wiki/CRIME">CRIME</a> attack, albeit primarily for web browsers. Users must weigh the benefits of compression against the potential risk of information leakage.</p>
<p><b>Version Interoperability</b></p>
<p>It is not recommended to mix pre-6.9 contexts with encrypted contexts on topics of shared interest. If a process with a pre-6.9 version of UM creates a receiver, and another process with UM 6.9 or beyond creates a TLS source, the pre-6.9 receiver will attempt to join the TLS source. After a timeout, the handshake will fail and the source will disconnect. The pre-6.9 receiver will retry the connection, leading to flapping.</p>
<p>Note that in the reverse situation, a 6.9 TLS receiver will simply ignore a pre-6.9 source. I.e. no attempt will be made to join, and no flapping will occur.</p>
<p><br />
 </p>
<h1><a class="anchor" id="compressedtcp"></a>
Compressed TCP&nbsp;&nbsp;<small><a href="#compressedtcp">&lt;-</a></small></h1>
<p>This section introduces the use of Compression with TCP connections.</p>
<p>The goal of the Ultra Messaging (UM) compression feature is to decrease the size of transmitted application data. UM can be configured to apply compression to all Streaming and/or Persisted TCP communication.</p>
<p>Non-TCP communication is not compressed (e.g. topic resolution).</p>
<p>Compression is generally implemented by any of several different software packages. UM makes use of LZ4, a widely deployed open-source project.</p>
<p>While the UM compression feature is usable for TCP-based sources and receivers, it is possibly most useful when applied to <a class="el" href="fundamentalconcepts.html#umrouter">UM Router</a> peer links.</p>
<p><br />
 </p>
<h2><a class="anchor" id="compressionconfiguration"></a>
Compression Configuration&nbsp;&nbsp;<small><a href="#compressionconfiguration">&lt;-</a></small></h2>
<p>Compression is enabled on a context basis. When enabled, all Streaming and Persistence related TCP-based communication into or out of the context is compressed by LZ4. A context with compression enabled will not accept source creation with transports other than TCP.</p>
<p>Subscribers will only successfully receive data if the receiver's context and the source's context share the same compression settings. A receiver created in a compression-enabled context will ignore topic resolution source advertisements for non-compressed sources, and will therefore not subscribe. Similarly, a receiver created in an non-compressed context will ignore topic resolution source advertisements for compressed sources. Topic resolution queries are also ignored by mismatched contexts. No warning will be logged when these topic resolution datagrams are ignored, but each time this happens, the context-level statistic tr_dgrams_dropped_type is incremented.</p>
<p>Compression is applied to unicast immediate messages as well, as invoked either directly by the user, or internally by functions like late join, request/response, and Persistence-related communication between sources, receivers, and stores.</p>
<p>Brokered Queuing using AMQP does not use the UM compression feature. A UM brokered context does not allow compression to be enabled.</p>
<p>The compression-related configuration options used by the Ultra Messaging library are:</p>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpcompressedtcp.html#compressioncontext">compression (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpencryptedtcp.html#tlscompressionnegotiationtimeoutcontext">tls_compression_negotiation_timeout (context)</a> </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="compressionandpersistence"></a>
Compression and Persistence&nbsp;&nbsp;<small><a href="#compressionandpersistence">&lt;-</a></small></h2>
<p>Compression is designed to compress a data Transport Session. It is not intended to compress data at rest. When a Persistent Store is used with the UM compression feature, the user messages are written to disk in uncompressed form.</p>
<p><br />
 </p>
<h2><a class="anchor" id="compressionandqueuing"></a>
Compression and Queuing&nbsp;&nbsp;<small><a href="#compressionandqueuing">&lt;-</a></small></h2>
<p>The UM compression feature does not apply to the AMQP connection to the brokered queue. UM does not currently support compression on the AMQP connection.</p>
<p>However, the ULB form of queuing does not use a broker. For ULB sources that are configured for TCP, the UM compression feature will compress the application data.</p>
<p><br />
 </p>
<h2><a class="anchor" id="compressionandthedynamicroutingoptiondro"></a>
Compression and the Dynamic Routing Option (DRO)&nbsp;&nbsp;<small><a href="#compressionandthedynamicroutingoptiondro">&lt;-</a></small></h2>
<p>When a UM Router is used to route messages across <a class="el" href="fundamentalconcepts.html#topicresolutiondomain">Topic Resolution Domains</a> (TRDs), be aware that the compression session is terminated at the UM Router's proxy receiver/source. Because each endpoint portal on a UM Router is implemented with its own context, care must be taken to ensure end-to-end compression (if desired). As a message is forwarded through a UM Router network, it does not propagate the compression setting of the originator, so each portal needs to be appropriately compressed.</p>
<p>Possibly the most-useful application of the UM compression feature is not TCP sources, but rather UM Router peer links. The compression feature is extended to UM Router peer links, however peer links are not context-based and are not configured the same way. The following XML elements are used by the UM Router to configure a peer link:</p>
<ul>
<li>
'<b>&lt;compression&gt;</b>' </li>
</ul>
<p>As with sources and receivers, the portals on both sides of a peer link must be configured for the same compression setting.</p>
<p>Notice that there is no element corresponding to the context option <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpencryptedtcp.html#tlscompressionnegotiationtimeoutcontext">tls_compression_negotiation_timeout (context)</a>. The UM Router peer link's negotiation timeout is hard-coded to 5 seconds.</p>
<p>See the UM Router configuration DTD for details.</p>
<p><br />
 </p>
<h2><a class="anchor" id="compressionandencryption"></a>
Compression and Encryption&nbsp;&nbsp;<small><a href="#compressionandencryption">&lt;-</a></small></h2>
<p>See <a class="el" href="umfeatures.html#tlsandcompression">TLS and Compression</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="versioninteroperability"></a>
Version Interoperability&nbsp;&nbsp;<small><a href="#versioninteroperability">&lt;-</a></small></h2>
<p>It is not recommended to mix pre-6.9 contexts with compressed contexts on topics of shared interest. As mentioned above, if a compressed and an uncompressed context connect via TCP, the connection will fail and retry, resulting in flapping.</p>
<p><br />
 </p>
<h1><a class="anchor" id="highresolutiontimestamps"></a>
High-resolution Timestamps&nbsp;&nbsp;<small><a href="#highresolutiontimestamps">&lt;-</a></small></h1>
<p>This section introduces the use of high-resolution timestamps with LBT-RM.</p>
<p>The Ultra Messaging (UM) high-resolution message timestamp feature leverages the hardware timestamping function of certain Solarflare network interface cards (NICs) to measure sub-microsecond times that packets are transmitted and received. Solarflare's NICs and Onload kernel-bypass driver implement PTP to synchronize timestamps across the network, allowing very accurate one-way latency measurements. The UM timestamp feature requires Solarflare OpenOnload version 201509 or later.</p>
<p>For subscribers, each message's receive timestamp is delivered in the message's header structure (for C programs, <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aaa7a945411e63884f12918417e8d117c">lbm_msg_t</a> field <b>hr_timestamp</b>, of type <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a60ce419ca9bccc4d2b61b9acb70fe30e">lbm_timespec_t</a>). Each timestamp is a structure of 32 bits worth of seconds and 32 bits worth of nanoseconds. When both values are zero, the timestamp is not available.</p>
<p>For publishers, each message's transmit timestamp is delivered via the source event callback (for C programs, event type LBM_SRC_EVENT_TIMESTAMP). The same timestamp structure as above is delivered with the event, as well as the message's sequence number. Sending applications can be informed of the outgoing sequence number range of each message by using the extended form of the send function and supplying the LBM_SRC_SEND_EX_FLAG_SEQUENCE_NUMBER_INFO flag. This causes the LBM_SRC_EVENT_SEQUENCE_NUMBER_INFO event to be delivered to the source event handler.</p>
<p><br />
 </p>
<h2><a class="anchor" id="timestamprestrictions"></a>
Timestamp Restrictions&nbsp;&nbsp;<small><a href="#timestamprestrictions">&lt;-</a></small></h2>
<p>Due to the specialized nature of this feature, there are several restrictions in its use.</p>
<ul>
<li>
<b>Operating system</b>: Linux only. No timestamps will be delivered on other operating systems. Also, since the feature makes use of the rcvmmsg() function, no timestamps will be delivered on Linux kernels prior to 2.6.33 and glibc libraries prior to 2.12 (which was released in 2010). </li>
<li>
<b>Languages</b>: C and Java only. </li>
<li>
<b>Transport</b>: Source-based LBT-RM (multicast) Transport Sessions only. No timestamps will be delivered for MIM or other transport types. </li>
<li>
<b>Queuing</b>: Timestamps are not supported for broker-based queuing. If a ULB source is configured for LBT-RM, send-side timestamps are not supported and will not be delivered if one or more receivers are registered. However, on the receive side, ULB messages are time stamped. </li>
<li>
<b>Loss</b>: If packet loss triggers LBT-RM's NAK/retransmit sequence, the send side will have multiple timestamps delivered, one for each multicast transmission. On the receive side, the timestamp of the first successfully received multicast datagram will be delivered. </li>
<li>
<b>Recovery</b>: For missed messages which are recovered via Late Join, Off-Transport Recovery (OTR), or the Persistent Store, no timestamp will be delivered, either on the send side or the receive side. </li>
<li>
<b>Implicit batching</b>: If implicit batching is being used, only the first message in a batch will have a send-side timestamp delivered. When implicit batching is used, the sender must be prepared for some messages to not have timestamps delivered. On the receive side, all messages in a batch will have the same timestamp. </li>
<li>
<b>UM Fragmentation, send-side</b>: If user messages are too large to be contained in a single datagram, UM will fragment the message into multiple datagrams. On the send side, each datagram will trigger delivery of a timestamp. <ul>
<li>
UM Fragmentation, receive-side with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#ordereddeliveryreceiver">ordered_delivery (receiver)</a> set to 0 (arrival): Arrival-order delivery will result in each fragment being delivered separately, as it is received. Each fragment's message header will contain a timestamp. Arrival order delivery provides an accurate timestamp of when the complete message is received (although, as mentioned above, any fragment recovered via OTR or the Persistent Store will not have a timestamp). </li>
<li>
UM Fragmentation, receive-side with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#ordereddeliveryreceiver">ordered_delivery (receiver)</a> set to 1 or -1, (reassembly): Delivery with reassembly results in a single timestamp included in the message header. That timestamp corresponds to the arrival of the last fragment of the message (although, as mentioned above, any fragment recovered via OTR or the Persistent Store will not have a timestamp). Note that this is not necessarily the last fragment received; if an intermediate datagram is lost and subsequently re-transmitted after a delay, that intermediate datagram will be the last one received, but its timestamp will not be used for the message. For example, if a three-fragment message is received in the order of F0, F2, F1, the timestamp for the message will correspond to F2, the last fragment of the message. If fragmented messages are being sent, and an accurate time of message completion is needed, arrival order delivery must be used. </li>
</ul>
</li>
<li>
<b>UM Fragmentation plus implicit batching</b>: If user messages vary widely in size, some requiring fragmentation, and implicit batching is used be aware that a full fragment does not completely fill a datagram. For example, if a small message (less than 300 bytes) is sent followed by a large message requiring fragmentation, the first fragment of the large message will fit in the same datagram as the small message. In that case, on the send side, a timestamp will not be delivered for that first fragment. However, a timestamp will be delivered for the second fragment. On the receive side, the same restrictions apply as described with UM fragmentation. </li>
<li>
<b>Local loopback</b>: If an LBT-RM source and receiver share the same physical machine, the receive side will not have timestamps delivered. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="timestampconfigurationsummary"></a>
Timestamp Configuration Summary&nbsp;&nbsp;<small><a href="#timestampconfigurationsummary">&lt;-</a></small></h2>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmoperation.html#transportlbtrmsourcetimestampcontext">transport_lbtrm_source_timestamp (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmoperation.html#transportlbtrmreceivertimestampcontext">transport_lbtrm_receiver_timestamp (context)</a> </li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="unicastimmediatemessaging"></a>
Unicast Immediate Messaging&nbsp;&nbsp;<small><a href="#unicastimmediatemessaging">&lt;-</a></small></h1>
<p>Unicast Immediate Messaging (UIM) deviates from the normal publish/subscribe paradigm by allowing the sending application to send messages to a specific destination application context. Various features within UM make use of UIMs transparently to the application. For example, a persistent receiver sends consumption acknowledgements to the Store using UIM messages.</p>
<p>The application can make direct use of UIM in two ways: </p><ul>
<li>
Calling a UIM send API function. See <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a497d77b133cea1547c3346fcba99872a">lbm_unicast_immediate_message()</a> and <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ae011c7a66e1db1f012d7f9633dbd321d">lbm_unicast_immediate_request()</a>. </li>
<li>
Sending a response to a message using the <a class="el" href="fundamentalconcepts.html#requestresponse">Request/Response</a> feature. See <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a0bbc01b600ccc2ae874474e35955eb85">lbm_send_response()</a>. </li>
</ul>
<p>A UIM message can be associated with a topic string, but that topic is not used to determine where the message is sent to. Instead, the topic string is included in the message header, and the application must specify the destination of the desired context in the UIM send call.</p>
<p>UIM messages are sent using the TCP protocol; no other protocol is supported for UIM. The TCP connection is created dynamically as-needed, when a message is sent. That is, when an application sends its first UIM message to a particular destination context, the sender's context holds the message and initiates the TCP connection. When the connection is accepted by the destination context, the sender sends the message. When the message is fully sent, the sender will keep the TCP connection open for a period of time in case more UIMs are sent to the same destination context. See <a class="el" href="umfeatures.html#uimconnectionmanagement">UIM Connection Management</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="uimaddressing"></a>
UIM Addressing&nbsp;&nbsp;<small><a href="#uimaddressing">&lt;-</a></small></h2>
<p>There are three ways to specify the destination address of a UIM: </p><ul>
<li>
Implicit &ndash; this method is used when a response is sent using the <a class="el" href="fundamentalconcepts.html#requestresponse">Request/Response</a> feature. See <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a0bbc01b600ccc2ae874474e35955eb85">lbm_send_response()</a> for details. </li>
<li>
Explicit &ndash; this method uses a string of the form: "TCP:ip:port" (no UM router) or "TCP:domain:ip:port" (for a routed UM network). See <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a497d77b133cea1547c3346fcba99872a">lbm_unicast_immediate_message()</a> for details. </li>
<li>
Source &ndash; this method uses a source string to send messages to the context which hosts a given source. See <a class="el" href="umobjects.html#sendingtosources">Sending to Sources</a> for details. </li>
</ul>
<p>In the Explicit addressing method, the "ip" and "port" refer to the binding of the destination context's UIM port. By default, when a context is created, UM will select values from a range of possibilities for ip and port. However, this makes it difficult for a sender to construct an explicit address since the ip and port are not deterministic.</p>
<p>One solution is to explicitly set the ip and port for the context's UIM port using the configuration options: <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpunicastimmediatemessagingnetwork.html#requesttcpportcontext">request_tcp_port (context)</a> and <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpunicastimmediatemessagingnetwork.html#requesttcpinterfacecontext">request_tcp_interface (context)</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="receivingauim"></a>
Receiving a UIM&nbsp;&nbsp;<small><a href="#receivingauim">&lt;-</a></small></h2>
<p>There are two kinds of UIM messages: </p><ul>
<li>
UIMs with a topic. </li>
<li>
UIMs with no topic (topicless). </li>
</ul>
<p>To receive UIM messages with a topic, an application simply creates a normal receiver for that topic. Alternatively, it can create a wildcard receiver for a matching topic pattern. Finally, the application can also register a callback specifically for UIM messages that contain a topic but for which no matching receiver exists, using <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpmulticastimmediatemessagingoperation.html#immediatemessagetopicreceiverfunctioncontext">immediate_message_topic_receiver_function (context)</a>. Alternatively, <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#abdefbb3bd3ff3a3b2ec6e20ca2f5dc19">lbm_context_rcv_immediate_topic_msgs()</a> can be used.</p>
<p>To receive UIM messages with no topic (topicless), the application must register a callback for topicless messages, using <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpmulticastimmediatemessagingoperation.html#immediatemessagereceiverfunctioncontext">immediate_message_receiver_function (context)</a>). Alternatively, <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a374f135dddf7794130509f97b1e96cf8">lbm_context_rcv_immediate_msgs()</a> can be used.</p>
<p>Note that only the specified destination context will deliver the message. If other applications have a receiver for that same topic, they will not receive a copy of that UIM message.</p>
<p><b>UIM Port</b></p>
<p>To receive UIMs, a context must bind to and listen on the "UIM Port", also known as the "Request Port". See <a class="el" href="umfeatures.html#uimaddressing">UIM Addressing</a> for details.</p>
<p><br />
 </p>
<h2><a class="anchor" id="sendingauim"></a>
Sending a UIM&nbsp;&nbsp;<small><a href="#sendingauim">&lt;-</a></small></h2>
<p>The following APIs are used to send application UIM messages: </p><ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a497d77b133cea1547c3346fcba99872a">lbm_unicast_immediate_message()</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ae011c7a66e1db1f012d7f9633dbd321d">lbm_unicast_immediate_request()</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a0bbc01b600ccc2ae874474e35955eb85">lbm_send_response()</a> &ndash; see <a class="el" href="fundamentalconcepts.html#requestresponse">Request/Response</a> for more information. </li>
<li>
</li>
</ul>
<p>For the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a497d77b133cea1547c3346fcba99872a">lbm_unicast_immediate_message()</a> and <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ae011c7a66e1db1f012d7f9633dbd321d">lbm_unicast_immediate_request()</a> APIs, the user has a choice between sending messages with a topic or without a topic (topicless). With the C API, passing a NULL pointer for the topic string sends a topicless message.</p>
<p><br />
 </p>
<h2><a class="anchor" id="uimconnectionmanagement"></a>
UIM Connection Management&nbsp;&nbsp;<small><a href="#uimconnectionmanagement">&lt;-</a></small></h2>
<p>The act of sending a UIM message will check to see if the context already has a TCP connection open to the destination context. If so, the existing connection is used to send the UIM. Otherwise, UM will initiate a new TCP connection to the destination context.</p>
<p>Once the message is sent, an activity deletion timer is started for the connection; see <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpunicastimmediatemessagingoperation.html#responsetcpdeletiontimeoutcontext">response_tcp_deletion_timeout (context)</a>. If another UIM message is sent to the same destination, the activity deletion timer is canceled and restarted. Thus, if messages are sent periodically with a shorter period than the activity deletion timer, the TCP connection will remain established.</p>
<p>However, if no messages are sent for more time than the activity deletion timer, the timer will expire and the TCP connection will be deleted and resources cleaned up.</p>
<p>An exception to this workflow exists for the <a class="el" href="fundamentalconcepts.html#requestresponse">Request/Response</a> feature. When a request message is received by a context, the context automatically initiates a connection to the requester, even though the application has not yet sent its response UIM. The activity deletion timer is not started at this time. When the application's receiver callback is invoked with the request message, the message contains a reference to a response object. This response object is used for sending response UIMs back to the requester. However, the act of sending these responses also does not start the activity deletion timer for the TCP connection. The activity deletion timer is only started when the response object is deleted (usually implicitly when the message itself is deleted, usually as a result of returning from the receiver callback).</p>
<p>Note that the application that receives a request has the option of retaining the message, which delays deletion of the message until the application explicitly decides to delete it. In this case, the TCP connection is held open for as long as the application retains the response object. When the application has finished sending any and all of its responses to the request and does not need the request object any more, it deletes the request object. This starts the activity deletion timer running.</p>
<p>Finally, note that there is a queue in front of the UIM connection which holds messages when the connection is slow. It is possible that messages are still held in the queue for transmission after the response object is deleted, and if the response message is very large and/or the destination application is slow processing responses, it is possible for data to still be queued when the activity deletion timer expires. In that case, UM does <em>not</em> delete the TCP connection, and instead restarts the activity deletion timer for the connection.</p>
<p><br />
 </p>
<h1><a class="anchor" id="multicastimmediatemessaging"></a>
Multicast Immediate Messaging&nbsp;&nbsp;<small><a href="#multicastimmediatemessaging">&lt;-</a></small></h1>
<p>Multicast Immediate Messaging (MIM) is not recommended for general use. It is inefficient and can affect the operation of all applications on a UM network. This is partly because every message sent via the MIM protocol is distributed to <em>every</em> other application on the network, regardless of that application's interest in such messages.</p>
<p>MIM uses the same reliable multicast protocol as normal LBT-RM sources. MIM messages can be sent to a topic, in which case each receiving context will filter that message, discarding it if no receiver exists for that topic. MIM avoids using Topic Resolution by including the full topic string in the message, and sending it to a multicast group that all application contexts are configured to use.</p>
<p>A receiving context will receive the message and check to see if the application created a receiver for the topic. If so, then the message is delivered. However, if no receiver exists for that topic, the context checks to see if <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpmulticastimmediatemessagingoperation.html#immediatemessagetopicreceiverfunctioncontext">immediate_message_topic_receiver_function (context)</a> is configured. If so, then the message is delivered. But if neither exists, then the receiving context discards the message.</p>
<p>It is also possible to send a "topicless" message via MIM. The recipient context must have configured a topicless receiver using <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpmulticastimmediatemessagingoperation.html#immediatemessagereceiverfunctioncontext">immediate_message_receiver_function (context)</a>; otherwise the message is discarded.</p>
<p>A valid use case for MIM might be an application that starts running, sends a request message, gets back a response, and then exits. With this kind of short-lived application, it can be a burden to create a source and wait for it to resolve. With MIM, topic resolution is skipped, so no delay is needed prior to sending.</p>
<p>MIM is typically not used for normal Streaming data because messages are somewhat less efficiently handled than source-based messages. Inefficiencies derive from larger message sizes due to the inclusion of the topic name, and on the receiving side, the MIM Delivery Controller hashing of topic names to find receivers, which consumes some extra CPU. If you have a high-message-rate stream, you should use a source-based method and not MIM. If head-loss is a concern and delay before sending is not feasible, then consider using late join (although this replaces head-loss with some head latency).</p>
<p>Note: Multicast Immediate Messaging can benefit from hardware acceleration. See <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grptransportacceleration.html">Transport Acceleration Options</a> for more information</p>
<dl class="section note"><dt>Note</dt><dd>MIM is not compatible with Queuing, including ULB.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="temporarytransportsession"></a>
Temporary Transport Session&nbsp;&nbsp;<small><a href="#temporarytransportsession">&lt;-</a></small></h2>
<p>MIM uses the same reliable multicast algorithms as LBT-RM. When a sending application sends a message with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a24e5bff3a70e571bb12024af67b47cbb">lbm_multicast_immediate_message()</a>, MIM creates a temporary Transport Session. Note that no topic-level source object is created.</p>
<p>MIM automatically deletes the temporary Transport Session after a period of inactivity defined by <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpmulticastimmediatemessagingoperation.html#mimsrcdeletiontimeoutcontext">mim_src_deletion_timeout (context)</a> which defaults to 30 seconds. A subsequent send creates a new Transport Session. Due to the possibility of head-loss in the switch, it is recommended that sending applications use a long deletion timeout if they continue to use MIM after significant periods of inactivity.</p>
<p>MIM forces all topics across all sending applications to be concentrated onto a single multicast address to which ALL applications listen, even if they aren't interested in any of the topics. Thus, all topic filtering must happen in UM.</p>
<p>MIM can also be used to send an UM request message with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a54f3933e4dd154a9c7bb72598d0d9ef1">lbm_multicast_immediate_request()</a>. For example, an application can use MIM to request initialization information right when it starts up. MIM sends the response directly to the initializing application, avoiding the topic resolution delay inherent in the normal source-based <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ad4d06f66b8404684e191ca178e0cc09b">lbm_send_request()</a> function.</p>
<p><br />
 </p>
<h2><a class="anchor" id="mimnotifications"></a>
MIM Notifications&nbsp;&nbsp;<small><a href="#mimnotifications">&lt;-</a></small></h2>
<p>MIM notifications differ in the following ways from normal UM source-based sending.</p>
<ul>
<li>
When a sending application's MIM Transport Session times out and is deleted, the receiving applications do not receive an EOS notification. </li>
<li>
Applications with a source notification callback (<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#resolversourcenotificationfunctioncontext">resolver_source_notification_function (context)</a>) are not informed of a MIM sender. This is because source notification is based on Topic Resolution, and MIM does not use it. </li>
<li>
MIM sending supports the non-blocking flag. However, it does not provide an <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aa905cb268bbee255c71b74694370fe61">LBM_SRC_EVENT_WAKEUP</a> notification when the MIM session becomes writable again. </li>
<li>
MIM sends unrecoverable loss notifications to a context callback, not to a receiver callback. See <a class="el" href="umfeatures.html#mimlosshandling">MIM Loss Handling</a>. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="receivingimmediatemessages"></a>
Receiving Immediate Messages&nbsp;&nbsp;<small><a href="#receivingimmediatemessages">&lt;-</a></small></h2>
<p>To receive MIM messages with a topic, an application simply creates a normal receiver for that topic. Alternatively, it can create a wildcard receiver for a matching topic pattern. Finally, the application can also register a callback specifically for UIM messages that contain a topic but for which no matching receiver exists, using <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpmulticastimmediatemessagingoperation.html#immediatemessagetopicreceiverfunctioncontext">immediate_message_topic_receiver_function (context)</a>. Alternatively, <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#abdefbb3bd3ff3a3b2ec6e20ca2f5dc19">lbm_context_rcv_immediate_topic_msgs()</a> can be used.</p>
<p>To receive MIM messages with no topic (topicless), the application must register a callback for topicless messages, using <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpmulticastimmediatemessagingoperation.html#immediatemessagereceiverfunctioncontext">immediate_message_receiver_function (context)</a>). Alternatively, <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a374f135dddf7794130509f97b1e96cf8">lbm_context_rcv_immediate_msgs()</a> can be used.</p>
<p>If needed, an application can send topicless messages using MIM. A MIM sender passes in a NULL string instead of a topic name. The message goes out on the MIM multicast address and is received by all other receivers. A receiving application can use <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a374f135dddf7794130509f97b1e96cf8">lbm_context_rcv_immediate_msgs()</a> to set the callback procedure and delivery method for non-topic immediate messages.</p>
<p><br />
 </p>
<h2><a class="anchor" id="mimandwildcardreceivers"></a>
MIM and Wildcard Receivers&nbsp;&nbsp;<small><a href="#mimandwildcardreceivers">&lt;-</a></small></h2>
<p>When an application receives an immediate message, it's topic is hashed to see if there is at least one regular (non-wildcard) receiver object listening to the topic. If so, then MIM delivers the message data to the list of receivers.</p>
<p>However, if there are no regular receivers for that topic in the receive hash, MIM runs the message topic through all existing wildcard patterns and delivers matches to the appropriate wildcard receiver objects without creating sub-receivers. The next MIM message received for the same topic will again be run through all existing wildcard patterns. This can consume significant CPU resources since it is done on a per-message basis.</p>
<p><br />
 </p>
<h2><a class="anchor" id="mimlosshandling"></a>
MIM Loss Handling&nbsp;&nbsp;<small><a href="#mimlosshandling">&lt;-</a></small></h2>
<p>The receiving application can set up a context callback to be notified of MIM unrecoverable loss (<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a7129f39b95974676e0ca74d88f58c498">lbm_mim_unrecloss_function_cb()</a>). It is not possible to do this notification on a topic basis because the receiving UM has no way of knowing which topics were affected by the loss.</p>
<p><br />
 </p>
<h2><a class="anchor" id="mimconfiguration"></a>
MIM Configuration&nbsp;&nbsp;<small><a href="#mimconfiguration">&lt;-</a></small></h2>
<p>As of UM 3.1, MIM supports ordered delivery. As of UM 3.3.2, the MIM configuration option, <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpmulticastimmediatemessagingoperation.html#mimordereddeliverycontext">mim_ordered_delivery (context)</a> defaults to ordered delivery.</p>
<p>See the <a href="../Config/index.html">UM Configuration Guide</a> for the descriptions of the MIM configuration options:</p>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpmulticastimmediatemessagingnetwork.html">Multicast Immediate Messaging Network Options</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpmulticastimmediatemessagingreliability.html">Multicast Immediate Messaging Reliability Options</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/Design/config.tag:../Config/" href="../Config/grpmulticastimmediatemessagingoperation.html">Multicast Immediate Messaging Operation Options</a> </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="mimexampleapplications"></a>
MIM Example Applications&nbsp;&nbsp;<small><a href="#mimexampleapplications">&lt;-</a></small></h2>
<p>UM includes two example applications that illustrate MIM.</p>
<ul>
<li>
<p class="startli"><a href="../example/lbmimsg.c">lbmimsg.c</a> - application that sends immediate messages as fast as it can to a given topic (single source). See also the Java example, <a href="../java_example/lbmimsg.java">lbmimsg.java</a> and the .NET example, <a href="../dotnet_example/lbmimsg.cs">lbmimsg.cs</a>.</p>
<p class="endli"></p>
</li>
<li>
<a href="../example/lbmireq.c">lbmireq.c</a> - application that sends immediate requests to a given topic (single source) and waits for responses. </li>
</ul>
<p><b>lbmimsg.c</b></p>
<p>We can demonstrate the default operation of Immediate Messaging with lbmimsg and lbmrcv.</p>
<ol>
<li>
Run <b>lbmrcv -v topicName</b> </li>
<li>
Run <b>lbmimsg topicName</b> </li>
</ol>
<p>The lbmrcv output should resemble the following:</p>
<pre class="fragment">Immediate messaging target: TCP:10.29.1.78:14391
1     secs.  0     Kmsgs/sec.  0     Kbps
1     secs.  0     Kmsgs/sec.  0     Kbps
1     secs.  0     Kmsgs/sec.  0     Kbps
[topicName][LBTRM:10.29.1.78:14390:644c8862:224.10.10.21:14401][0], 25 bytes
[topicName][LBTRM:10.29.1.78:14390:644c8862:224.10.10.21:14401][1], 25 bytes
[topicName][LBTRM:10.29.1.78:14390:644c8862:224.10.10.21:14401][2], 25 bytes
[topicName][LBTRM:10.29.1.78:14390:644c8862:224.10.10.21:14401][3], 25 bytes
[topicName][LBTRM:10.29.1.78:14390:644c8862:224.10.10.21:14401][4], 25 bytes
[topicName][LBTRM:10.29.1.78:14390:644c8862:224.10.10.21:14401][5], 25 bytes
[topicName][LBTRM:10.29.1.78:14390:644c8862:224.10.10.21:14401][6], 25 bytes
</pre><p>Each line in the lbmrcv output is a message received, showing the topic name, transport type, receiver IP:Port, multicast address and message number.</p>
<p><b>lbmireq.c</b></p>
<p>Sending an UM request by MIM can be demonstrated with lbmireq and lbmrcv, which shows a single request being sent by lbmireq and received by lbmrcv. (lbmrcv sends no response.)</p>
<ol>
<li>
Run <b>lbmrcv -v topicName</b> </li>
<li>
Run <b>lbmireq topicName</b> </li>
</ol>
<p>The lbmrcv output should resemble the following:</p>
<pre class="fragment">$ lbmrcv -v topicName
Immediate messaging target: TCP:10.29.1.78:14391
1     secs.  0     Kmsgs/sec.  0     Kbps
1     secs.  0     Kmsgs/sec.  0     Kbps
1     secs.  0     Kmsgs/sec.  0     Kbps
[topicName][LBTRM:10.29.1.78:14390:92100885:224.10.10.21:14401][0],   Request
1     secs.  0     Kmsgs/sec.  0     Kbps
1     secs.  0     Kmsgs/sec.  0     Kbps
1     secs.  0     Kmsgs/sec.  0     Kbps
1     secs.  0     Kmsgs/sec.  0     Kbps
1     secs.  0     Kmsgs/sec.  0     Kbps
1     secs.  0     Kmsgs/sec.  0     Kbps
</pre><p>The lbmireq output should resemble the following:</p>
<pre class="fragment">$ lbmireq topicName
Using TCP port 4392 for responses
Sending 1 requests of size 25 bytes to target &lt;&gt; topic &lt;topicName&gt;
Sending request 0
Sent request 0. Pausing 5 seconds.
Done waiting for responses. 0 responses (0 bytes) received. Deleting request
Quitting...
Lingering for 5 seconds...
</pre> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
</body>
</html>
