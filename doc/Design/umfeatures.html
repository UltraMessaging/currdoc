<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Concepts Guide: UM Features</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen_manual.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Concepts Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('umfeatures.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">UM Features </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Except where otherwise indicated, the features described in this section are available in the UMS, UMP, and UMQ products.</p>
<p><br />
 </p>
<h1><a class="anchor" id="transportservicesproviderxsp"></a>
Transport Services Provider (XSP)</h1>
<p>As of UM version 6.11, a new receive-side object is available to the user: the <a class="el" href="umobjects.html#transportservicesproviderobject">Transport Services Provider Object</a>.</p>
<p>The earlier feature, <a class="el" href="fundamentalconcepts.html#multitransportthreads">Multi-Transport Threads</a>, is deprecated in favor of XSP.</p>
<p>By default, a UM context combines all network data reception into a single <em>context thread</em>. This thread is responsible for reception and processing of application messages, topic resolution, and immediate message traffic (UIM and MIM). The context thread is also used for processing timers. This single-threaded model conserves CPU core resources, and can simplify application design. However, it can also introduce significant latency outliers (jitter) if a time-sensitive user message is waiting behind, say, a topic resolution message, or a timer callback.</p>
<p>Using an XSP object, an application can reassign the processing of a subscribed transport session to an independent thread. This allows concurrent processing of received messages with topic resolution and timers, and even allows different groups transport sessions to be processed concurrently with each other.</p>
<p>By default, when an XSP object is created, UM creates a new thread associated with the XSP. Alternatively, the XSP can be created with operational mode "sequential", which gives the responsibility of thread creation to the application. Either way, the XSP uses its independent thread to read data from the sockets associated with one or more subscribed transport sessions. That thread then delivers received messages to the application via a normal receive application callback function.</p>
<p>Creation of an XSP does not by itself cause any receiver transport sessions to be assigned to it. Central to the use of XSPs is an application-supplied mapping callback function which tells UM which XSP to associate with subscribed transport sessions as they are discovered and joined. This callback allows the application to examine the newly-joined transport session, if desired. Then the callback returns, informing UM which XSP, if any, to assign the receiver transport session to.</p>
<p><br />
 </p>
<h2><a class="anchor" id="xsphandlestransportsessionsnottopics"></a>
XSP Handles Transport Sessions, Not Topics</h2>
<p>Conceptually, an application designer might want to assign the reception and processing of received data to XSPs on a topic basis. This is not always possible. The XSP thread must process received data on a socket basis, and sockets map to <em>transport sessions</em>. As mentioned in <a class="el" href="fundamentalconcepts.html#umtransports">UM Transports</a>, a publishing application maps one or more topic-based sources to a transport session.</p>
<p>Consider the following example:</p>
<div class="image">
<img src="xsp_1.png" alt="xsp_1.png"/>
</div>
 <p>Publisher A and B are two separate application instances, both of which create a source for topic "X". A subscriber application might create two XSPs and assign one transport session to each. In this case, you have two independent threads delivering messages to the subscriber's receiver callback, which may not be what the developer wanted. If the developer wants topic X to be serialized, a single XSP should be created and mapped to both transport sessions:</p>
<div class="image">
<img src="xsp_2.png" alt="xsp_2.png"/>
</div>
 <p>Now let's introduce a second topic. The developer might want to create two XSPs so that each topic will be handled by an independent thread. However, this is not possible, given the way that the topics are mapped to transport sessions in the following example:</p>
<div class="image">
<img src="xsp_3.png" alt="xsp_3.png"/>
</div>
 <p>In this case, XSP 1 is delivering both topics X and Y from Publisher A, and XSP 2 is delivering topics X and Y from Publisher B. Once again, the receiver callback for topic X will be called by two independent threads, which is not desired.</p>
<p>The only way to achieve independent processing of topics is to design the publishers to map their topics to transport sessions carefully. For example:</p>
<div class="image">
<img src="xsp_4.png" alt="xsp_4.png"/>
</div>
 <p><br />
 </p>
<h2><a class="anchor" id="xspthreadingconsiderations"></a>
XSP Threading Considerations</h2>
<p>When contexts are used single-threaded, the application programmer can assume serialization of event delivery to the application callbacks. This can greatly simplify the design of applications, at the cost of added latency outliers (jitter).</p>
<p>When XSPs are used to provide multi-threaded receivers, care must be taken in application design to account for potential concurrent calls to application callbacks. This is especially true if multiple subscribed transport sessions are assigned different XSPs, as demonstrated in <a class="el" href="umfeatures.html#xsphandlestransportsessionsnottopics">XSP Handles Transport Sessions, Not Topics</a>.</p>
<p>Even in the most simple case, where a single XSP is created and used for all subscribed transport sessions, there are still events generated by the main context thread which can be called concurrently with XSP callbacks. Reception of MIM or UIM messages, scheduled timers, and some topic resolution-related callbacks all come from the main context thread, and can all be invoked concurrently with XSP callbacks.</p>
<p><b>Threading Example: Message Timeout</b></p>
<p>Consider as an example a common timer use case: message timeout. Application A expects to receive messages for topic "X" every 5 seconds. If 10 seconds pass without a message, the application assumes that the publisher for "X" has exited, so it cleans up internal state and deletes the UM receiver object. Each time a message is received, the current timer is cancelled and re-created for 10 seconds.</p>
<p>Without XSPs, this can be easily coded since message reception and timer expiration events are serialized. The timer callback can clean up and delete the receiver, confident that no receiver events might get delivered while this is in progress.</p>
<p>However, if the transport session carrying topic "X" is assigned to an independent XSP thread, message reception and timer expiration events are no longer serialized. Publisher of "X" might send it's message on-time, but a temporary network outage could delay its delivery, introducing a race condition between message delivery and timer expiration. Consider the case where the timer expiration is a little ahead of the message callback. The timer callback might clean up application state which the message callback will attempt to use. This could lead to unexpected behavior, possibly including segmentation faults.</p>
<p>In this case, proper sequencing of operations is critical. The timer should delete the receiver first. While inside the receiver delete API, the XSP might deliver messages to the application. However, once the receiver delete API returns, it is guaranteed that the XSP is finished making receiver callbacks.</p>
<p>Note that in this example case, if the message receive callback attempts to cancel the timer, the cancel API will return an error. This is because the timer has already expired and the execution of the callback has begun, and is inside the receiver delete API. The message receive callback needs to be able to handle this sequence, presumably by not re-scheduling the timer.</p>
<p><br />
 </p>
<h2><a class="anchor" id="xspusage"></a>
XSP Usage</h2>
<p>This section provides simplified C code fragments that demonstrate some of the XSP-related API calls. For full examples of XSP usage, see <a href="../example/lbmrcvxsp.c">lbmrcvxsp.c</a> (for C) and <a href="../java_example/lbmrcvxsp.java">lbmrcvxsp.java</a> (for Java).</p>
<dl class="section note"><dt>Note</dt><dd>Each XSP thread has its own Unicast Listener (request) port. You may need to expand the range <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grprequestnetwork.html#requesttcpportlowcontext">request_tcp_port_low (context)</a> - <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grprequestnetwork.html#requesttcpporthighcontext">request_tcp_port_high (context)</a>.</dd></dl>
<p>The common sequence of operations during application initialization is minimally shown below. In the code fragments below, error detection and handling are omitted for clarity.</p>
<ol>
<li>
<p class="startli">Create a context attribute object and set the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#transportmappingfunctioncontext">transport_mapping_function (context)</a> option to point at the application's XSP mapping callback function using the structure <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a90dde1ea00f12038cff7195c76d47a46">lbm_transport_mapping_func_t</a>.</p>
<pre class="fragment">  lbm_context_attr_t *ctx_attr;
  err = lbm_context_attr_create(&amp;ctx_attr);

  lbm_transport_mapping_func_t mapping_func;
  mapping_func.mapping_func = app_xsp_mapper_callback;
  mapping_func.clientd = NULL;             /* Can include app state pointer. */

  err = lbm_context_attr_setopt(ctx_attr, "transport_mapping_function",
          &amp;mapping_func, sizeof(mapping_func));
</pre><p class="endli"></p>
</li>
<li>
<p class="startli">Create the context.</p>
<pre class="fragment">  err = lbm_context_create(&amp;ctx, ctx_attr, NULL, NULL);
  err = lbm_context_attr_delete(ctx_attr);  /* No longer needed. */
</pre><p class="endli"></p>
</li>
<li>
<p class="startli">Create XSPs using <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ae38035c6036a84f07f9ba7cee1747dbf">lbm_xsp_create()</a>. In this example, only a single XSP is created.</p>
<pre class="fragment">  lbm_xsp_t *xsp;  /* app_xsp_mapper_callback() needs this; see below. */
  err = lbm_xsp_create(&amp;xsp, ctx, NULL, NULL);
</pre><p>Note that the application can optionally pass in a context attribute object and an XSP attribute object. The context attribute is because XSP is implemented as a sort of reduced-function sub-context, and so it is possible to modify context options for the XSP. However, this is rarely needed since the default action is for the XSP to inherit all the configuration of the main context.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Create a receiver for topic "X".</p>
<pre class="fragment">  lbm_topic_t *topic;
  err = lbm_rcv_topic_lookup(&amp;topic, ctx, "X", NULL);

  lbm_rcv_t *rcv;
  err = lbm_rcv_create(&amp;rcv, ctx, topic, app_rcv_callback, NULL, NULL);
</pre><p>Event queues may also be used with XSP-assigned transport sessions.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">At this point, when the main context discovers a source for topic "X", it will proceed to join the transport session. It will call the application's app_xsp_mapper_callback() function, which is minimally this:</p>
<pre class="fragment">lbm_xsp_t *app_xsp_mapper_callback(lbm_context_t *ctx,
        lbm_new_transport_info_t *transp_info, void *clientd)
{
  /* Retrieve the XSP object created in step 3. */
  return xsp;
}
</pre><p>This minimal callback simply returns the XSP that was created during initialization (the "clientd" can be helpful for that). By assigning all receiver transport sessions to the same XSP, you have effectively separated message processing from UM housekeeping tasks, like processing of topic resolution and timers. This can greatly reduce latency outliers.</p>
<p class="endli">As described in <a class="el" href="umfeatures.html#xsphandlestransportsessionsnottopics">XSP Handles Transport Sessions, Not Topics</a>, some users want to have multiple XSPs and assign the transport sessions to XSPs according to application logic. Note that the passed-in <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ac611697e7263b4b5ea5a3b35eb26dc99">lbm_new_transport_info_t</a> structure contains information about the transport session, such as the IP address of the sender. However, this structure does not contain topic information. Applications can use the resolver's source notification callback via the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#resolversourcenotificationfunctioncontext">resolver_source_notification_function (context)</a> attribute option to associate topics with source strings. </p>
</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Most of the time, the application mapping callback will be invoked each time a transport session is joined. However, there is one exception to this rule. If a context is already joined to a transport session carried on a multicast group and destination port, joining another transport session on the same multicast group and destination port does not invoke the mapping callback again. This is because the same socket is used for all transport sessions that use the same group:port.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="otherxspoperations"></a>
Other XSP Operations</h2>
<p>When an XSP object is created, an XSP attribute object can be supplied to set XSP options. The XSP options are: </p><ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#operationalmodexsp">operational_mode (xsp)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#zerotransportsfunctionxsp">zero_transports_function (xsp)</a> </li>
</ul>
<p>To create and manipulate an XSP attribute object, see: </p><ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a9ab709766b50d510266901f961341a00">lbm_xsp_attr_create()</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ae52cbac6a22b495a3b48a70bf23fc118">lbm_xsp_attr_setopt()</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a62363973a939a8555eac38846492dbb2">lbm_xsp_attr_getopt()</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#adfc416faf8fbc79cfd16a1485341f469">lbm_xsp_attr_delete()</a> </li>
</ul>
<p>To delete an XSP, all receivers associated with transport sessions handled by that XSP must first be deleted. Then the XSP can be deleted using <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ac61812a1c86eb9d240054f9d3ba32ac5">lbm_xsp_delete()</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="xsplimitations"></a>
XSP Limitations</h2>
<p>There are some restrictions and limitations on the XSP feature.</p>
<ul>
<li>
<p class="startli">The only transport types currently supported are LBT-RM, LBT-RU, and TCP. IPC, SMX, DBL, and BROKER are not supported with XSPs at this time.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Persistent receivers are not currently supported. Support for persistence will be added in a future version.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The ULB feature is not currently supported.</p>
<p class="endli"></p>
</li>
<li>
The use of XSP is not currently compatible with <a class="el" href="umfeatures.html#hotfailoverhf">Hot Failover (HF)</a>. If you desire to use Hot Failover with XSP, contact Support. </li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="usinglatejoin"></a>
Using Late Join</h1>
<p>This section introduces the use of Ultra Messaging Late Join in default and specialized configurations. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html">Late Join Options</a> in the <a href="../../Config/index.html">UM Configuration Guide</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>If your application is running within a Ultra Messaging context with configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grprequestnetwork.html#requesttcpbindrequestportcontext">request_tcp_bind_request_port (context)</a> set to zero, then request port binding has been turned off, which also disables the Late Join feature.</dd>
<dd>
With the UMQ product, you cannot use Late Join with Queuing.</dd></dl>
<p>The Late Join feature enables newly created receivers to receive previously transmitted messages. Sources configured for Late Join maintain a retention buffer (not to be confused with a transport retransmission window), which holds transmitted messages for late-joining receivers.</p>
<p>A Late Join operation follows the following sequence:</p>
<ol>
<li>
A new receiver configured for Late Join with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#uselatejoinreceiver">use_late_join (receiver)</a> completes topic resolution. Topic advertisements from the source contain a flag that indicates the source is configured for Late Join with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#latejoinsource">late_join (source)</a>. </li>
<li>
The new receiver sends a Late Join Information Request (LJIR) to request a previously transmitted messages. The receiver configuration option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestoutstandingmaximumreceiver">retransmit_request_outstanding_maximum (receiver)</a>, determines the number of messages the receiver requests. </li>
<li>
The source responds with a Late Join Information (LJI) message containing the sequence numbers for the retained messages that are available for retransmission. </li>
<li>
The source unicasts the messages. </li>
<li>
When <a class="el" href="umfeatures.html#configuringlatejoinforlargenumbersofmessages">Configuring Late Join for Large Numbers of Messages</a>, the receiver issues additional requests, and the source retransmits these additional groups of older messages, oldest first. </li>
</ol>
<div class="image">
<img src="LateJoin.png" alt="LateJoin.png"/>
</div>
 <p>The source's retention buffer's is not pre-allocated and occupies an increasing amount of memory as the source sends messages and adds them to the buffer. If a retention buffer grows to a size equal to the value of the source configuration option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizethresholdsource">retransmit_retention_size_threshold (source)</a>, the source deletes older messages as it adds new ones. The source configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpdeprecated.html#retransmitretentionagethresholdsource">retransmit_retention_age_threshold (source)</a>, controls message deletion based on message age.</p>
<p>UM uses control-structure overhead memory on a per-message basis for messages held in the retention buffer, in addition to the retention buffer's memory. Such memory usage can become significantly higher when retained messages are smaller in size, since more of them can then fit in the retention buffer.</p>
<dl class="section note"><dt>Note</dt><dd>If you set the receiver configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#ordereddeliveryreceiver">ordered_delivery (receiver)</a> to 1, the receiver must deliver messages to your application in sequence number order. The receiver holds out-of-order messages in an ordered list cache until messages arrive to fill the sequence number gaps. If an out-of-order message arrives with a sequence number that creates a message gap greater than the value of <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitmessagecachingproximityreceiver">retransmit_message_caching_proximity (receiver)</a>, the receiver creates a burst loss event and terminates the Late Join recovery operation. You can increase the value of the proximity option and restart the receiver, but a burst loss is a significant event and you should investigate your network and message system components for failures.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="latejoinwithump"></a>
Late Join With Persistence</h2>
<p>With the UMP/UMQ products, late Join can be implemented in conjunction with the Persistent Store, however in this configuration, it functions somewhat differently from Streaming. After a late-Join-enabled receiver has been created, resolved a topic, and become registered with a store, it may then request older messages. The store unicasts the retransmission messages. If the store does not have these messages, it requests them of the source (assuming option retransmission-request-forwarding is enabled), thus initiating Late Join.</p>
<p><br />
 </p>
<h2><a class="anchor" id="latejoinoptionssummary"></a>
Late Join Options Summary</h2>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#latejoinsource">late_join (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpdeprecated.html#retransmitretentionagethresholdsource">retransmit_retention_age_threshold (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizelimitsource">retransmit_retention_size_limit (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizethresholdsource">retransmit_retention_size_threshold (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#uselatejoinreceiver">use_late_join (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitinitialsequencenumberrequestreceiver">retransmit_initial_sequence_number_request (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitmessagecachingproximityreceiver">retransmit_message_caching_proximity (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestmessagetimeoutreceiver">retransmit_request_message_timeout (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestintervalreceiver">retransmit_request_interval (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestmaximumreceiver">retransmit_request_maximum (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestoutstandingmaximumreceiver">retransmit_request_outstanding_maximum (receiver)</a> </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="usingdefaultlatejoinoptions"></a>
Using Default Late Join Options</h2>
<p>To implement Late Join with default options, set the Late Join configuration options to activate the feature on both a source and receiver in the following manner.</p>
<ol>
<li>
<p class="startli">Create a configuration file with source and receiver Late Join activation options set to 1. For example, file cfg1.cfg containing the two lines:</p>
<pre class="fragment">source late_join 1
receiver use_late_join 1
</pre><p class="endli"></p>
</li>
<li>
<p class="startli">Run an application that starts a Late-Join-enabled source. For example:</p>
<pre class="fragment">lbmsrc -c cfg1.cfg -P 1000 topicName
</pre><p class="endli"></p>
</li>
<li>
<p class="startli">Wait a few seconds, then run an application that starts a Late-Join-enabled receiver. For example:</p>
<pre class="fragment">lbmrcv -c cfg1.cfg -v topicName
</pre> </li>
</ol>
<p>The output for each should closely resemble the following:</p>
<p><b>LBMSRC</b></p>
<pre class="fragment">$ lbmsrc -c cfg1.cfg -P 1000 topicName
LOG Level 5: NOTICE: Source "topicName" has no retention settings (1 message retained max)
Sending 10000000 messages of size 25 bytes to topic [topicName]
Receiver connect [TCP:10.29.3.77:34200]
</pre><p><b>LBMRCV</b></p>
<pre class="fragment">$ lbmrcv -c cfg1.cfg -v topicName
Immediate messaging target: TCP:10.29.3.77:4391
[topicName][TCP:10.29.3.76:4371][2]-RX-, 25 bytes
1.001 secs. 0.0009988 Kmsgs/sec. 0.1998 Kbps
[topicName][TCP:10.29.3.76:4371][3], 25 bytes
1.002 secs. 0.0009982 Kmsgs/sec. 0.1996 Kbps
[topicName][TCP:10.29.3.76:4371][4], 25 bytes
1.003 secs. 0.0009972 Kmsgs/sec. 0.1994 Kbps
[topicName][TCP:10.29.3.76:4371][5], 25 bytes
1.003 secs. 0.0009972 Kmsgs/sec. 0.1994 Kbps
...
</pre><p>Note that the source only retained 1 Late Join message (due to default retention settings) and that this message appears as a retransmit (-RX-). Also note that it is possible to sometimes receive 2 RX messages in this scenario (see <a class="el" href="umfeatures.html#retransmittingonlyrecentmessages">Retransmitting Only Recent Messages</a>.)</p>
<p><br />
 </p>
<h2><a class="anchor" id="specifyingarangeofmessagestoretransmit"></a>
Specifying a Range of Messages to Retransmit</h2>
<p>To receive more than one or two Late Join messages, increase the source's <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizethresholdsource">retransmit_retention_size_threshold (source)</a> from its default value of 0. Once the buffer exceeds this threshold, the source allows the next new message entering the retention buffer to bump out the oldest one. Note that this threshold's units are bytes (which includes a small overhead per message).</p>
<p>While the retention threshold endeavors to keep the buffer size close to its value, it does not set hard upper limit for retention buffer size. For this, the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizelimitsource">retransmit_retention_size_limit (source)</a> configuration option (also in bytes) sets this boundary.</p>
<p>Follow the steps below to demonstrate how a source can retain about 50MB of messages, but no more than 60MB:</p>
<ol>
<li>
<p class="startli">Create a second configuration file (cfg2.cfg) with the following options:</p>
<pre class="fragment">source late_join 1
source retransmit_retention_size_threshold 50000000
source retransmit_retention_size_limit 60000000
receiver use_late_join 1
</pre> </li>
<li>
Run lbmsrc -c cfg2.cfg -P 1000 topicName. </li>
<li>
Wait a few seconds and run <code>lbmrcv -c cfg2.cfg -v topicName</code>. The output for each should closely resemble the following: </li>
</ol>
<p><b>LBMSRC</b></p>
<pre class="fragment">$ lbmsrc -c cfg2.cfg -P 1000 topicName
Sending 10000000 messages of size 25 bytes to topic [topicName]
Receiver connect [TCP:10.29.3.76:34444]
</pre><p><b>LBMRCV</b></p>
<pre class="fragment">$ lbmrcv -c cfg2.cfg -v topicName
Immediate messaging target: TCP:10.29.3.76:4391
[topicName][TCP:10.29.3.77:4371][0]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][1]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][2]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][3]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][4]-RX-, 25 bytes
1.002 secs. 0.004991 Kmsgs/sec. 0.9981 Kbps
[topicName][TCP:10.29.3.77:4371][5], 25 bytes
1.002 secs. 0.0009984 Kmsgs/sec. 0.1997 Kbps
[topicName][TCP:10.29.3.77:4371][6], 25 bytes
1.002 secs. 0.0009983 Kmsgs/sec. 0.1997 Kbps
[topicName][TCP:10.29.3.77:4371][7], 25 bytes
...
</pre><p>Note that lbmrcv received live messages with sequence numbers 7, 6, and 5, and RX messages going from 4 all the way back to Sequence Number 0.</p>
<p><br />
 </p>
<h2><a class="anchor" id="retransmittingonlyrecentmessages"></a>
Retransmitting Only Recent Messages</h2>
<p>Thus far we have worked with only source late join settings, but suppose that you want to receive only the last 10 messages. To do this, configure the receiver option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestmaximumreceiver">retransmit_request_maximum (receiver)</a> to set how many messages to request backwards from the latest message.</p>
<p>Follow the steps below to set this option to 10.</p>
<ol>
<li>
<p class="startli">Add the following line to cfg2.cfg and rename it cfg3.cfg:</p>
<pre class="fragment">receiver retransmitrequestmaximumreceiver 10
</pre><p class="endli"></p>
</li>
<li>
<p class="startli">Run:</p>
<pre class="fragment">lbmsrc -c cfg3.cfg -P 1000 topicName
</pre><p class="endli"></p>
</li>
<li>
Wait a few seconds and run <code>lbmrcv -c cfg3.cfg -v topicName</code>. The output for each should closely resemble the following. </li>
</ol>
<p><b>LBMSRC</b></p>
<pre class="fragment">$ lbmsrc -c cfg3.cfg -P 1000 topicName
Sending 10000000 messages of size 25 bytes to topic [topicName]
Receiver connect [TCP:10.29.3.76:34448]
</pre><p><b>LBMRCV</b></p>
<pre class="fragment">$ lbmrcv -c cfg3.cfg -v topicName
Immediate messaging target: TCP:10.29.3.76:4391
[topicName][TCP:10.29.3.77:4371][13]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][14]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][15]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][16]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][17]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][18]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][19]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][20]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][21]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][22]-RX-, 25 bytes
[topicName][TCP:10.29.3.77:4371][23]-RX-, 25 bytes
1.002 secs. 0.01097 Kmsgs/sec. 2.195 Kbps
[topicName][TCP:10.29.3.77:4371][24], 25 bytes
1.002 secs. 0.0009984 Kmsgs/sec. 0.1997 Kbps
[topicName][TCP:10.29.3.77:4371][25], 25 bytes
1.002 secs. 0.0009984 Kmsgs/sec. 0.1997 Kbps
[topicName][TCP:10.29.3.77:4371][26], 25 bytes
...
</pre><p>Note that 11, not 10, retransmits were actually received. This can happen because network and timing circumstances may have one RX already in transit while the specific RX amount is being processed. (Hence, it is not possible to guarantee one and only one RX message for every possible Late Join recovery.)</p>
<p><br />
 </p>
<h2><a class="anchor" id="configuringlatejoinforlargenumbersofmessages"></a>
Configuring Late Join for Large Numbers of Messages</h2>
<p>Suppose you have a receiver that comes up at midday and must gracefully catch up on the large number of messages it has missed. The following discussion explains the relevant Late Join options and how to use them.</p>
<p><b>Option:</b> <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestoutstandingmaximumreceiver">retransmit_request_outstanding_maximum (receiver)</a></p>
<p>When a receiver comes up and begins requesting Late Join messages, it does not simply request messages starting at Sequence Number 0 through 1000000. Rather, it requests the messages a little at a time, depending upon how option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestoutstandingmaximumreceiver">retransmit_request_outstanding_maximum (receiver)</a> is set. For example, when set to the default of 200, the receiver sends requests the first 200 messages (Sequence Number 0 - 199). Upon receiving Sequence Number 0, it then requests the next message (200), and so on, limiting the number of outstanding unfulfilled requests to 200.</p>
<p>Note that in some environments, the default of 200 messages may be too high and overwhelm receivers with RXs, which can cause loss in a live LBT-RM stream. However, in other situations higher values can increase the rate of RXs received.</p>
<p><b>Option:</b> <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitmessagecachingproximityreceiver">retransmit_message_caching_proximity (receiver)</a></p>
<p>When sequence number delivery order is used, long recoveries of active sources can create receiver memory cache problems due to the processing of both new and retransmitted messages. This option provides a method to control caching and cache size during recovery.</p>
<p>It does this by comparing the option value (default 2147483647) to the difference between the newest (live) received sequence number and the latest received RX sequence number. If the difference is less than the option's value, the receiver caches incoming live new messages. Otherwise, new messages are dropped and not cached (with the assumption that they can be requested later as retransmissions).</p>
<p>For example, as shown in the diagram below, a receiver may be receiving both live streaming messages (latest, #200) and catch-up retransmissions (latest, #100). The difference here is 100. If <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitmessagecachingproximityreceiver">retransmit_message_caching_proximity (receiver)</a> is 75, the receiver caches the live messages and will deliver them when it is all caught up with the retransmissions. However, if this option is 150, streamed messages are dropped and later picked up again as a retransmission.</p>
<div class="image">
<img src="proximity_option.png" alt="proximity_option.png"/>
</div>
 <p>The default value of this option is high enough to still encourage caching most of the time, and should be optimal for most receivers.</p>
<p>If your source streams faster than it retransmits, caching is beneficial, as it ensures new data are received only once, thus reducing recovery time. If the source retransmits faster than it streams, which is the optimal condition, you can lower the value of this option to use less memory during recovery, with little performance impact.</p>
<p><br />
 </p>
<h1><a class="anchor" id="offtransportrecoveryotr"></a>
Off-Transport Recovery (OTR)</h1>
<p>Off-Transport Recovery (OTR) is a lost-message-recovery feature that provides a level of hedging against the possibility of brief and incidental unrecoverable loss at the transport level or from a UM Router. This section describes the OTR feature.</p>
<dl class="section note"><dt>Note</dt><dd>With the UMQ product, you cannot use OTR with Brokered Queuing.</dd></dl>
<p>When a transport cannot recover lost messages, OTR engages and looks to the source for message recovery. It does this by accessing the source's retention buffer (used also by the Late Join feature) to re-request messages that no longer exist in a transport's transmission window, or other places such as a Persistent Store or redundant source.</p>
<p>OTR functions in a manner very similar to that of Late Join, but differs mainly in that it activates in message loss situations rather than following the creation of a receiver, and shares only the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#latejoinsource">late_join (source)</a> option setting.</p>
<p>Upon detecting loss, a receiver initiates OTR by sending repeated, spaced, OTR requests to the source, until it recovers lost messages or a timeout period elapses.</p>
<p>OTR operates independently from transport-level recovery mechanisms such as NAKs for LBT-RU or LBT-RM. When you enable OTR for a receiver with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#useotrreceiver">use_otr (receiver)</a>, the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrrequestinitialdelayreceiver">otr_request_initial_delay (receiver)</a> period starts as soon as the delivery controller detects a sequence gap. If the gap is not resolved by the end of the delay interval, OTR recovery initiates. OTR recovery can occur before, during or after transport-level recovery attempts.</p>
<p>When a receiver initiates OTR, the intervals between OTR requests increases twofold after each request, until the maximum interval is reached (assuming the receiver is still waiting to receive the retransmission). You use configuration options <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrrequestminimumintervalreceiver">otr_request_minimum_interval (receiver)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrrequestmaximumintervalreceiver">otr_request_maximum_interval (receiver)</a> to set the initial (minimum) and maximum intervals, respectively.</p>
<p>The source retransmits lost messages to the recovered receiver via unicast.</p>
<p><br />
 </p>
<h2><a class="anchor" id="otrwithsequencenumberordereddelivery"></a>
OTR with Sequence Number Ordered Delivery</h2>
<p>When sequence number delivery order is used and a gap of missing messages occurs, a receiver buffers the new incoming messages while it attempts to recover the earlier missing ones. Long recoveries of actively streaming sources can cause excessive receiver cache memory growth due to the processing of both new and retransmitted messages. You can control caching and cache size during recovery with options <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrmessagecachingthresholdreceiver">otr_message_caching_threshold (receiver)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitmessagecachingproximityreceiver">retransmit_message_caching_proximity (receiver)</a>.</p>
<p>The option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrmessagecachingthresholdreceiver">otr_message_caching_threshold (receiver)</a> sets the maximum number of messages a receiver can buffer. When the number of cached messages hits this threshold, new streamed messages are dropped and not cached, with the assumption that they can be requested later as retransmissions.</p>
<p>The <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitmessagecachingproximityreceiver">retransmit_message_caching_proximity (receiver)</a>, which is also used by Late Join (see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitmessagecachingproximityreceiver">retransmit_message_caching_proximity (receiver)</a>), turns off this caching if there are too many messages to buffer between the last delivered message and the currently streaming messages.</p>
<p>Both of these option thresholds must be satisfied before caching resumes.</p>
<p><br />
 </p>
<h2><a class="anchor" id="otrwithump"></a>
OTR With Persistence</h2>
<p>With the UMP/UMQ products, you can implement OTR in conjunction with the Persistent Store, however in this configuration, it functions somewhat differently from Streaming. If an OTR-enabled receiver registered with a store detects a sequence gap in the live stream and that gap is not resolved by other means within the next <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrrequestinitialdelayreceiver">otr_request_initial_delay (receiver)</a> period, the receiver requests those messages from the store(s). If the store does not have some of the requested messages, the receiver requests them from the source. Regardless of whether the messages are recovered from a store or from the source, OTR delivers all recovered messages with the LBM_MSG_OTR flag, unlike Late Join, which uses the LBM_MSG_RETRANSMIT flag.</p>
<p><br />
 </p>
<h2><a class="anchor" id="otroptionssummary"></a>
OTR Options Summary</h2>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#latejoinsource">late_join (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpdeprecated.html#retransmitretentionagethresholdsource">retransmit_retention_age_threshold (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizelimitsource">retransmit_retention_size_limit (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizethresholdsource">retransmit_retention_size_threshold (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#useotrreceiver">use_otr (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrrequestmessagetimeoutreceiver">otr_request_message_timeout (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrrequestinitialdelayreceiver">otr_request_initial_delay (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrrequestlogalertcooldownreceiver">otr_request_log_alert_cooldown (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrrequestmaximumintervalreceiver">otr_request_maximum_interval (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrrequestminimumintervalreceiver">otr_request_minimum_interval (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrrequestoutstandingmaximumreceiver">otr_request_outstanding_maximum (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#otrmessagecachingthresholdreceiver">otr_message_caching_threshold (receiver)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitmessagecachingproximityreceiver">retransmit_message_caching_proximity (receiver)</a> </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>With <a class="el" href="umfeatures.html#smartsources">Smart Sources</a>, the following configuration options have limited or no support: <ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizethresholdsource">retransmit_retention_size_threshold (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizelimitsource">retransmit_retention_size_limit (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpdeprecated.html#retransmitretentionagethresholdsource">retransmit_retention_age_threshold (source)</a> </li>
</ul>
</dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="smartsources"></a>
Smart Sources</h1>
<p>The normal <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a91f4b9cb04fe1323ec56833211cc5cb7">lbm_src_send()</a> function (and its Java and .NET equivalents) are very flexible and support the full range of UM's rich feature set. To provide this level of capability, it is necessary to make use of dynamic (malloc/free) memory, and critical section locking (mutex) in the send path. While modern memory managers and thread locks are very efficient, they do introduce some degree of variability of execution time, leading to latency outliers potentially in the millisecond range.</p>
<p>For applications which require even higher speed and very consistent timing, and are able to run within certain constraints, UM has an alternate send feature called Smart Source. This is a highly-optimized send path with no dynamic memory operations or locking; all allocations are done at source creation time, and lockless algorithms are used throughout. To achieve these improvements, this software version's Smart Source imposes a number of restrictions (see <a class="el" href="umfeatures.html#smartsourcerestrictions">Smart Sources Restrictions</a>).</p>
<dl class="section note"><dt>Note</dt><dd>the Smart Source feature is <em>not</em> the same thing as the <a class="el" href="umfeatures.html#zerocopysendapi">Zero-Copy Send API</a> feature; see <a class="el" href="umfeatures.html#comparisonofzerocopyandsmartsources">Comparison of Zero Copy and Smart Sources</a>.</dd></dl>
<p>To use Smart Sources, a user application typically performs the following steps:</p>
<ol>
<li>
Create a context with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8058947690bd0995bc2c59d4a61b462f">lbm_context_create()</a>, as normal. </li>
<li>
Create the topic object and the Smart Source with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a1ba60407fa2bde0997aab6d5a5d2da1a">lbm_src_topic_alloc()</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a9a8d169a8c2a90b8442d4eb3e3711c9c">lbm_ssrc_create()</a>, respectively. Use <a class="el" href="umfeatures.html#smartsourceconfiguration">Smart Sources Configuration</a> to pre-allocate the desired number of buffers. </li>
<li>
Get the desired number of messages buffers with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a98c5450e9fb93f30bd80fa33a2380dfc">lbm_ssrc_buff_get()</a> and initialize them if desired. The application typically constructs outgoing messages directly in these buffers for transmission. </li>
<li>
Send messages with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a2f50f56536778332e9f5712b06546425">lbm_ssrc_send_ex()</a>. The buffers gotten in the previous step must be used. </li>
<li>
While most applications manage the message buffers internally, it is also possible to give the buffers back to UM with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ab57120414bf92bd2f44de7aea97e3f1b">lbm_ssrc_buff_put()</a>, and then getting them again for subsequent sends. Getting and putting messages buffers can simplify application design at the expense of extra overhead. </li>
<li>
To clean up, delete the Smart Source with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a9cd9dfee7a9c268059084a3c327f65f9">lbm_ssrc_delete()</a>. It is not necessary to "put" the message buffers back to UM; they will be freed automatically when the Smart Source is deleted. </li>
</ol>
<p>For details, see the example applications <a href="../example/lbmssrc.c">lbmssrc.c</a> or <a href="../java_example/lbmssrc.java">lbmssrc.java</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>To avoid the overhead of locking, the Smart Source API functions are not thread-safe. Applications must be written to avoid concurrent calls. In particular, the application is restricted to sending messages on a given transport session with one thread. If <a class="el" href="umfeatures.html#smartsourcedefensivechecks">Smart Source Defensive Checks</a> are enabled, the first call to send a message on a newly-created transport session captures the ID of the calling thread. Subsequently, only that thread is allowed to call send for Smart Sources on that transport session. For applications which have multiple sending threads, Smart Source topics must be mapped to transport sessions carefully such that all of the topics on a given transport session are managed by the same sending thread.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There are no special requirements on the receive side when using Smart Sources. Normal receiving code is used.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="smartsourcesandmemorymanagement"></a>
Smart Sources and Memory Management</h2>
<p>As of UM 6.11, there are new C APIs that give the application greater control over the allocation of memory when Smart Sources are being created. Since creation of a Smart Source pre-allocates buffers used for application message data as well as internal retransmission buffers, an application can override the stock malloc/free to ensure, for example, that memory is local to the CPU core that will be sending messages.</p>
<p>When the application is ready to create the Smart Source, it should set up the configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpsmartsource.html#memmgtcallbackssource">mem_mgt_callbacks (source)</a>, which uses the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aae7c35eda2692944970e73d93217239b">lbm_mem_mgt_callbacks_t</a> structure to specify application callback functions.</p>
<p><br />
 </p>
<h2><a class="anchor" id="smartsourceconfiguration"></a>
Smart Sources Configuration</h2>
<p>The following configuration options are used to control the creation and operation of Smart Sources:</p>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpsmartsource.html#smartsrcmaxmessagelengthsource">smart_src_max_message_length (source)</a> - should be set to the maximum expected size for messages sent to on the source. </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpsmartsource.html#smartsrcuserbuffercountsource">smart_src_user_buffer_count (source)</a> - number of buffers to be pre-created at Smart Source create time. Deleting a Smart Source also frees these buffers, so applications must not access these buffers after their corresponding Smart Source is deleted. </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpsmartsource.html#smartsrcretentionbuffercountsource">smart_src_retention_buffer_count (source)</a> - enables <a class="el" href="fundamentalconcepts.html#latejoin">Late Join</a> and <a class="el" href="umfeatures.html#offtransportrecoveryotr">Off-Transport Recovery (OTR)</a> functionality. Takes the place of the normal late join / OTR options "retransmit_retention_*". (On the receive side, the normal late join options apply.) </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpsmartsource.html#transportlbtrmsmartsrctransmissionwindowbuffercountsource">transport_lbtrm_smart_src_transmission_window_buffer_count (source)</a> - size of the LBT-RM transmission window. Takes the place of the normal window options "transport_lbtrm_transmission_window_*". </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpsmartsource.html#transportlbtrusmartsrctransmissionwindowbuffercountsource">transport_lbtru_smart_src_transmission_window_buffer_count (source)</a> - size of the LBT-RU transmission window. Takes the place of the normal window options "transport_lbtru_transmission_window_*". </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpsmartsource.html#smartsrcenablespectrumchannelsource">smart_src_enable_spectrum_channel (source)</a> - should be set if <a class="el" href="umfeatures.html#spectrum">Spectrum</a> channels will be used. <br />
 See <a class="el" href="umfeatures.html#smartsourcesandspectrum">Smart Sources and Spectrum</a>. </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpsmartsource.html#smartsrcmessagepropertyintcountsource">smart_src_message_property_int_count (source)</a> - should be set if <a class="el" href="umfeatures.html#messageproperties">Message Properties</a> will be used. <br />
 See <a class="el" href="umfeatures.html#smartsourcesandmessageproperties">Smart Sources and Message Properties</a>. </li>
</ul>
<p>The option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpsmartsource.html#smartsrcmaxmessagelengthsource">smart_src_max_message_length (source)</a> is used to size the window transmission buffers. This means that the first Smart Source created on the session defines the maximum possible size of user messages for all Smart Sources on the transport session. It is not legal to create a subsequent Smart Source on the same transport session that has a larger <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpsmartsource.html#smartsrcmaxmessagelengthsource">smart_src_max_message_length (source)</a>, although smaller values are permissible.</p>
<p><br />
 </p>
<h2><a class="anchor" id="smartsourcedefensivechecks"></a>
Smart Source Defensive Checks</h2>
<p>Ultra Messaging generally includes defensive checks in API functions to verify validity of input parameters. In support of faster operation, deep defensive checks for Smart Sources are optional, and are disabled by default. Users should enable them during application development, and can leave them disabled for production.</p>
<p>To enable deep Smart Source defensive checks, set the environment variable <b>LBM_SMART_SOURCE_CHECK</b> to the numeric sum of desired values. Hexadecimal values may be supplied with the "0x" prefix. Each value enables a class of defensive checking:</p>
<center> <table class="doxtable">
<tr>
<th>Numeric Value</th><th>Deep Check </th></tr>
<tr>
<td><b>1</b></td><td>Send argument checking </td></tr>
<tr>
<td><b>2</b></td><td>Thread checking </td></tr>
<tr>
<td><b>4</b></td><td>User buffer pointer checking </td></tr>
<tr>
<td><b>8</b></td><td>User buffer structure checking </td></tr>
<tr>
<td><b>16, 0x10</b></td><td>user message length checking </td></tr>
<tr>
<td><b>32, 0x20</b></td><td>application header checking, including <a class="el" href="umfeatures.html#spectrum">Spectrum</a> and <a class="el" href="umfeatures.html#messageproperties">Message Properties</a>. </td></tr>
</table>
</center><p>To enable all checking, set the environment variable <b>LBM_SMART_SOURCE_CHECK</b> to "0xffffffff".</p>
<p><br />
 </p>
<h2><a class="anchor" id="smartsourcerestrictions"></a>
Smart Sources Restrictions</h2>
<dl class="section user"><dt><b>Linux</b> <b>and</b> <b>Windows</b> <b>64-bit</b> </dt><dd>Smart Sources is only supported on the 64-bit Linux and 64-bit Windows platforms, C and Java APIs.</dd></dl>
<dl class="section user"><dt><b>LBT-RM</b> <b>And</b> <b>LBT-RU</b> <b>Sources</b> </dt><dd>Smart Sources can only be created with the LBT-RM and LBT-RU transport types. Non-source-based sends are not supported (<a class="el" href="umfeatures.html#multicastimmediatemessaging">MIM</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a497d77b133cea1547c3346fcba99872a">UIM</a>, <a class="el" href="fundamentalconcepts.html#requestresponse">responses</a>).</dd></dl>
<dl class="section user"><dt><b>Persistence</b> </dt><dd>As of UM 6.11, Smart Sources support Persistence, but with some restrictions. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/ume.tag:../UME/" href="../UME/enablingpersistence.html#smartsourcesandpersistence">Smart Sources and Persistence</a> for details.</dd></dl>
<dl class="section user"><dt><b>Spectrum</b> </dt><dd>As of UM 6.11, Smart Sources support <a class="el" href="umfeatures.html#spectrum">Spectrum</a>, but with some API changes. See <a class="el" href="umfeatures.html#smartsourcesandspectrum">Smart Sources and Spectrum</a> for details.</dd></dl>
<dl class="section user"><dt><b>Single-threaded</b> </dt><dd>It is the application's responsibility to serialize calls to Smart Source APIs for a given transport session. Concurrent sends to different transport sessions are permitted.</dd></dl>
<dl class="section user"><dt><b>Single-datagram</b> </dt><dd>Application messages are limited in size to a single datagram. That size is configurable by <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmoperation.html#transportlbtrmdatagrammaxsizecontext">transport_lbtrm_datagram_max_size (context)</a>, which defaults to 8K. (Applications must define the maximum size of messages they intend to send; see the configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpsmartsource.html#smartsrcmaxmessagelengthsource">smart_src_max_message_length (source)</a>. This setting must be less than or equal to the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmoperation.html#transportlbtrmdatagrammaxsizecontext">transport_lbtrm_datagram_max_size (context)</a> minus 44 bytes of overhead.)</dd></dl>
<dl class="section user"><dt><b>No</b> <b>Application</b> <b>Headers</b> </dt><dd>Application messages may not include <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a40a3fe706dc6cf4a6bd23ebe721ce636">application headers</a>.</dd></dl>
<dl class="section user"><dt><b>Limited</b> <b>Message</b> <b>Properties</b> </dt><dd>Message Properties may be included, but their use has restrictions. See <a class="el" href="umfeatures.html#smartsourcemessagepropertiesusage">Smart Source Message Properties Usage</a>.</dd></dl>
<dl class="section user"><dt><b>Queuing</b> </dt><dd>Queuing is not currently supported, although support for ULB is a possibility in the future.</dd></dl>
<dl class="section user"><dt><b>Request</b> </dt><dd>Sending UM <a class="el" href="fundamentalconcepts.html#requestresponse">Requests</a> are not currently supported.</dd></dl>
<dl class="section user"><dt><b>Data</b> <b>Rate</b> <b>Limit</b> </dt><dd>Smart Source data messages are not <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmoperation.html#transportlbtrmdataratelimitcontext">rate limited</a>, although retransmissions are <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmoperation.html#transportlbtrmretransmitratelimitcontext">rate limited</a>. Care must be taken in designing and provisioning systems to prevent overloading network and host equipment, and overrunning receivers.</dd></dl>
<dl class="section user"><dt><b>Hot</b> <b>Failover</b> </dt><dd>The <a class="el" href="umfeatures.html#hotfailoverhf">Hot Failover</a> feature is not supported by Smart Sources.</dd></dl>
<dl class="section user"><dt><b>Batching</b> </dt><dd>Neither <a class="el" href="architecture.html#implicitbatching">Implicit Batching</a> nor <a class="el" href="architecture.html#explicitbatching">Explicit Batching</a> are supported by Smart Sources.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is not permitted to mix Smart Source API calls with standard source API calls for a given transport session.</dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="zerocopysendapi"></a>
Zero-Copy Send API</h1>
<p>This section introduces the use of the zero-copy send API for LBT-RM.</p>
<dl class="section note"><dt>Note</dt><dd>the Zero-Copy Send API feature is <em>not</em> the same thing as the <a class="el" href="umfeatures.html#smartsources">Smart Sources</a> feature; see <a class="el" href="umfeatures.html#comparisonofzerocopyandsmartsources">Comparison of Zero Copy and Smart Sources</a>.</dd></dl>
<p>The zero-copy send API modifies the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a91f4b9cb04fe1323ec56833211cc5cb7">lbm_src_send()</a> function for sending messages such that the UM library does not copy the user's message data before handing the datagram to the socket layer. These changes reduce CPU overhead and provide a minor reduction in latency. The effects are more pronounced for larger user messages, within the restrictions outlined below.</p>
<p>Application code using the zero-copy send API must call <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#adf24bf7c4b07549d6a2f89d56e6c913a">lbm_src_alloc_msg_buff()</a> to request a message buffer into which it will build its outgoing message. That function returns a message buffer pointer and also a separate buffer handle. When the application is ready to send the message, it must call <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a91f4b9cb04fe1323ec56833211cc5cb7">lbm_src_send()</a>, passing the buffer handle as the message (not the message buffer) and specify the LBM_MSG_BUFF_ALLOC send flag.</p>
<p>Once the message is sent, UM will process the buffer asynchronously. Therefore, the application must not make any further reference to either the buffer or the handle.</p>
<p><br />
 </p>
<h2><a class="anchor" id="zerocopysendcompatibility"></a>
Zero-Copy Send Compatibility</h2>
<p>The zero-copy send API is compatible with the following UM features:</p>
<ul>
<li>
C language, Streaming, source-based publishing applications using LBT-RM. </li>
<li>
Messages sent with the zero-copy API can be received by any UM product or daemon. No special restrictions apply to receivers of messages sent with the zero-copy send API. </li>
<li>
Compatible with implicit batching and message flushing. </li>
<li>
Compatible with non-blocking sends and wakeup source event handling. </li>
<li>
Compatible with hardware timestamps (see section <a class="el" href="umfeatures.html#highresolutiontimestamps">High-resolution Timestamps</a> ). </li>
<li>
Compatible with UD Acceleration. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="zerocopyrestrictions"></a>
Zero-Copy Restrictions</h2>
<p>Due to the specialized nature of this feature, there are several restrictions in its use:</p>
<ol>
<li>
<b>Languages</b>: Java and .NET are not supported at this time. </li>
<li>
<b>Transport</b>: Sourced-based LBT-RM (multicast) only. Not supported for immediate messages or non-LBT-RM transport types. Note that an application that uses zero-copy sends for certain sources may also have other sources configured for other transport types. </li>
<li>
<b>Application only</b>: UM daemons (e.g. UM Router, Stored, etc.) cannot be configured to use the zero-copy API. </li>
<li>
<b>Streaming only</b>: Persistence and queuing not supported. Note that an application that uses zero-copy sends for certain sources may also have other sources mapped to Persistence and/or queuing. </li>
<li>
<b><a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a91f4b9cb04fe1323ec56833211cc5cb7">lbm_src_send()</a> only</b>: send APIs not supported: <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#af28189e64ef0ee10d3444e418443aaa9">lbm_src_sendv()</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a091b5806bf18d10ebd0d9117e0c70229">lbm_src_send_ex()</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a4d883eaaa22baf81abf21d495f471c8b">lbm_src_sendv_ex()</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aeff48e558306b4bd869af2d99dcf5f4c">lbm_hf_src_send()</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a713c05423f7bf1767a29727c07aa4447">lbm_hf_src_sendv()</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ac515c1425d9b3f04f1e2cea5d66d3005">lbm_hf_src_send_ex()</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#acb6f42a8811cb998b4b19748b190f39b">lbm_hf_src_sendv_ex()</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ad4d06f66b8404684e191ca178e0cc09b">lbm_send_request()</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aabcfb44e7f5188a47d8d56540e783fa7">lbm_send_request_ex()</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a0bbc01b600ccc2ae874474e35955eb85">lbm_send_response()</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a24e5bff3a70e571bb12024af67b47cbb">lbm_multicast_immediate_message()</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a54f3933e4dd154a9c7bb72598d0d9ef1">lbm_multicast_immediate_request()</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a497d77b133cea1547c3346fcba99872a">lbm_unicast_immediate_message()</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ae011c7a66e1db1f012d7f9633dbd321d">lbm_unicast_immediate_request()</a>. Applications may still use these APIs, but not with the zero-copy send feature. </li>
<li>
<b>Send order</b>: It is recommended that zero-copy buffers be sent in the same order that they are allocated. A future version may require this. </li>
<li>
<b>Late join</b>: not supported. Note that an application that uses zero-copy sends on certain sources may also use late join on other sources. </li>
<li>
<b>Request/response</b>: not supported. </li>
<li>
<b>Metadata</b>: message properties and application headers are not supported. Note that an application that uses zero-copy sends for messages without metadata may also send messages with metadata using other send APIs, even to the same source. </li>
<li>
<b>Hot failover</b>: not supported. Note that an application that uses zero-copy sends for certain sources may use hot failover for other sources. </li>
<li>
<b>Explicit batching</b>: not supported. Note that implicit batching is supported. Also note that an application that uses zero-copy sends for certain sources may use explicit batching for other sources. </li>
<li>
<b>UM Fragmentation</b>: Not supported. Messages sent zero-copy must fit within a single datagram, as defined by the LBT-RM maximum datagram size. No special restrictions apply to IP fragmentation. Note that an application that uses zero-copy sends for single-datagram messages may also send multi-datagram messages using other send APIs, even to the same source. </li>
</ol>
<p><br />
 </p>
<h1><a class="anchor" id="comparisonofzerocopyandsmartsources"></a>
Comparison of Zero Copy and Smart Sources</h1>
<p>There are two UM features that are intended to reduce latency and jitter when sending messages: </p><ul>
<li>
<a class="el" href="umfeatures.html#smartsources">Smart Sources</a> </li>
<li>
<a class="el" href="umfeatures.html#zerocopysendapi">Zero-Copy Send API</a> </li>
</ul>
<p>These two features use different approaches to latency and jitter reduction, and are incompatible with each other. There are trade offs explained below, and customers seeking latency and/or jitter reduction will sometimes need to try both and empirically measure which is better for their use case.</p>
<p>The zero-copy send API removes a copy of the user's data buffer, as compared to a normal send. For small messages of a few hundred bytes, a malloc and a data copy represent a very small amount of time, so unless your messages are large, the absolute latency reduction is minimal.</p>
<p>The Smart Source has the advantage of eliminating all mallocs and frees from the send path. In addition, all thread locking is eliminated. This essentially removes all sources of jitter from the UM send path. However, because of the approach taken, sending to a Smart Source is more restrictive than sending with the zero-copy API.</p>
<p>In general, Informatica recommends Smart Sources to achieve the maximum reduction in jitter. For example, the zero-copy send API supports the use of batching to combine multiple messages into a single network datagram. Batching can be essential to achieve high throughputs. Some application designers may determine that the throughput advantages of zero-copy with batching outweigh the jitter advantages of Smart Sources.</p>
<p>See the sections <a class="el" href="umfeatures.html#zerocopysendapi">Zero-Copy Send API</a> and <a class="el" href="umfeatures.html#smartsources">Smart Sources</a> for details of their restrictions.</p>
<p><br />
 </p>
<h1><a class="anchor" id="encryptedtcp"></a>
Encrypted TCP</h1>
<p>This section introduces the use of Transport Layer Security (TLS), sometimes known by its older designation Secure Sockets Layer (SSL).</p>
<p>The goal of the Ultra Messaging (UM) TLS feature is to provide encrypted transport of application data. TLS supports authentication (through certificates), data confidentiality (through encryption), and data integrity (ensuring data are not changed, removed, or added-to). UM can be configured to apply TLS security measures to all Streaming and/or Persisted TCP communication, including UM Router peer links. Non-TCP communication is not encrypted (e.g. topic resolution).</p>
<p>TLS is a family of standard protocols and algorithms for securing TCP communication between a client and a server. It is sometimes referred as "SSL", which technically is the name of an older (less secure) version of the protocol. Over the years, security researchers (and hackers) have discovered flaws in SSL/TLS. However, the vast majority of the widely publicized security vulnerabilities have been flaws in the implementations of TLS, not in the recent TLS protocols or algorithms themselves. As of the release of UM 6.9, there are no known security weaknesses in TLS version 1.2, the version used by UM.</p>
<p>TLS is generally implemented by several different software packages. UM makes use of OpenSSL, a widely deployed and actively maintained open-source project.</p>
<p><br />
 </p>
<h2><a class="anchor" id="tlsauthentication"></a>
TLS Authentication</h2>
<p>TLS authentication uses X.509 digital certificates. Certificate creation and management is the responsibility of the user. Ultra Messaging's usage of OpenSSL expects PEM encoded certificates. There are a variety of generally available tools for converting certificates between different encodings. Since user infrastructures vary widely, the UM package does not include tools for creation, formatting, or management of certificates.</p>
<p>Although UM is designed as a peer-to-peer messaging system, TLS has the concept of client and server. The client initiates the TCP connection and the server accepts it. In the case of a TCP source, the receiver initiates and is therefore the client, with the source (sender of data) being the server. However, with unicast immediate messages, the sender of data is the client, and the recipient is the server. Due to the fact that unicast immediate messages are used by UM for internal control and coordination, it is typically not possible to constrain a given application to only operate as a pure client or pure server. For this reason, UM requires all applications participating in encryption to have a certificate. Server-only authentication (i.e. anonymous client, as is used by web browsers) is not supported. It is permissible for groups of processes, or even all processes, to share the same certificate.</p>
<p>A detailed discussion of certificate usage is beyond the scope of the Ultra Messaging documentation.</p>
<p><br />
 </p>
<h2><a class="anchor" id="tlsbackwardscompatibility"></a>
TLS Backwards Compatibility</h2>
<p>The TLS protocol was designed to allow for a high degree of backwards compatibility. During the connection establishment phase, the client and server perform a negotiation handshake in which they identify the highest common versions of various security options. For example, an old web browser might pre-date the introduction of TLS and only support the older SSL protocol. OpenSSL is often configured to allow clients and servers to "negotiate down" to those older, less-secure protocols or algorithms.</p>
<p>Ultra Messaging has the advantage of not needing to communicate with old versions of SSL or TLS. UM's default configuration directs OpenSSL to require both the client and the server to use protocols and algorithms which were highly regarded, as of UM's release date. If vulnerabilities are discovered in the future, the user can override UM's defaults and chose other protocols or algorithms.</p>
<p><br />
 </p>
<h2><a class="anchor" id="tlsefficiency"></a>
TLS Efficiency</h2>
<p>When a TLS connection is initiated, a handshake takes place prior to application data encryption. Once the handshake is completed, the CPU effort required to encrypt and decrypt application data is minimal. However, the handshake phase involves the use of much less efficient algorithms.</p>
<p>There are two factors under the user's control, which greatly affect the handshake efficiency: the choice of cipher suite and the key length. We have seen an RSA key of 8192 bits take 4 seconds of CPU time on a 1.3GHz SparcV9 processor just to complete the handshake for a single TLS connection.</p>
<p>Users should make their choices with an understanding of the threat profiles they are protecting against. For example, it is estimated that a 1024-bit RSA key can be broken in about a year by brute force using specialized hardware (see <a href="http://www.tau.ac.il/~tromer/papers/cbtwirl.pdf">http://www.tau.ac.il/~tromer/papers/cbtwirl.pdf</a>). This may be beyond the means of the average hacker, but well within the means of a large government. RSA keys of 2048 bits are generally considered secure for the foreseeable future.</p>
<p><br />
 </p>
<h2><a class="anchor" id="tlsconfiguration"></a>
TLS Configuration</h2>
<p>TLS is enabled on a context basis. When enabled, all Streaming and Persistence related TCP-based communication into or out of the context is encrypted by TLS. A context with TLS enabled will not accept source creation with transports other than TCP.</p>
<p>Subscribers will only successfully receive data if the receiver's context and the source's context share the same encryption settings. A receiver created in an encrypted enabled context will ignore topic resolution source advertisements for non-encrypted sources, and will therefore not subscribe. Similarly, a receiver created in a non-encrypted context will ignore topic resolution source advertisements for encrypted sources. Topic resolution queries are also ignored by mis-matched contexts. No warning will be logged when these topic resolution datagrams are ignored, but each time this happens, the context-level statistic tr_dgrams_dropped_type is incremented.</p>
<p>TLS is applied to unicast immediate messages as well, as invoked either directly by the user, or internally by functions like late join, request/response, and Persistence-related communication between sources, receivers, and stores.</p>
<p>Brokered Queuing using AMQP does not use the UM TLS feature. A UM brokered context does not allow TLS to be enabled.</p>
<p><br />
 </p>
<h2><a class="anchor" id="tlsoptionssummary"></a>
TLS Options Summary</h2>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpencryptedtcp.html#usetlscontext">use_tls (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpencryptedtcp.html#tlsciphersuitescontext">tls_cipher_suites (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpencryptedtcp.html#tlscertificatecontext">tls_certificate (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpencryptedtcp.html#tlscertificatekeycontext">tls_certificate_key (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpencryptedtcp.html#tlscertificatekeypasswordcontext">tls_certificate_key_password (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpencryptedtcp.html#tlstrustedcertificatescontext">tls_trusted_certificates (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpencryptedtcp.html#tlscompressionnegotiationtimeoutcontext">tls_compression_negotiation_timeout (context)</a> </li>
</ul>
<p>The <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpencryptedtcp.html#tlsciphersuitescontext">tls_cipher_suites (context)</a> configuration option defines the list of one or more (comma separated) cipher suites that are acceptable to this context. If more than one is supplied, they should be in descending order of preference. When a remote context negotiates encrypted TCP, the two sides must find a cipher suite in common, otherwise the connection will be canceled.</p>
<p>OpenSSL uses the cipher suite to define the algorithms and key lengths for encrypting the data stream. The choice of cipher suite is critical for ensuring the security of the connection. To achieve a high degree of backwards compatibility, OpenSSL supports old cipher suites which are no longer considered secure. The user is advised to use UM's default suite.</p>
<p>OpenSSL follows its own naming convention for cipher suites. See <a href="https://www.openssl.org/docs/manmaster/apps/ciphers.html#TLS-v1.2-cipher-suites">https://www.openssl.org/docs/manmaster/apps/ciphers.html#TLS-v1.2-cipher-suites</a> for a list of valid suite names (the ones with dashes) and the equivalent IANA names (with underscores). The UM configuration should use the OpenSSL-style names (with dashes).</p>
<p><br />
 </p>
<h2><a class="anchor" id="tlsandpersistence"></a>
TLS and Persistence</h2>
<p>TLS is designed to encrypt a TCP connection, and works with TCP-based persisted data transport sessions and control traffic. However, TLS is not intended to encrypt data at rest. When a Persistent Store is used with the UM TLS feature, the user messages are written to disk in plaintext form, not encrypted.</p>
<p><br />
 </p>
<h2><a class="anchor" id="tlsandqueuing"></a>
TLS and Queuing</h2>
<p>The UM TLS feature does not apply to the AMQP connection to the brokered queue. UM does not currently support security on the AMQP connection.</p>
<p>However, the ULB form of queuing does not use a broker. For ULB sources that are configured for TCP, the UM TLS feature will encrypt the application data.</p>
<p><br />
 </p>
<h2><a class="anchor" id="tlsandthedynamicroutingoptiondro"></a>
TLS and the Dynamic Routing Option (DRO)</h2>
<p>When a UM Router is used to route messages across topic resolution domains (TRDs), be aware that the TLS session is terminated at the UM Router's proxy receiver/source. Because each endpoint portal on a UM Router is implemented with its own context, care must be taken to ensure end-to-end security. It is possible to have a TLS source publishing in one TRD, received by a UM Router (via an endpoint portal also configured for TLS), and re-published to a different TRD via an endpoint portal configured with a non-encrypted context. This would allow a non-encrypted receiver to access messages that the source intended to be encrypted. As a message is forwarded through a UM Router network, it does not propagate the security settings of the originator, so each portal needs to be appropriately encrypted. The user is strongly encouraged to configure ALL portals on an interconnected network of UM Routers with the same encryption settings.</p>
<p>The encryption feature is extended to UM Router peer links, however peer links are not context-based and are not configured the same way. The following XML elements are used by the UM Router to configure a peer link:</p>
<ul>
<li>
'<b>&lt;tls&gt;</b>' </li>
<li>
'<b>&lt;cipher-suites&gt;</b>' </li>
<li>
'<b>&lt;certificate&gt;</b>' </li>
<li>
'<b>&lt;certificate-key&gt;</b>' </li>
<li>
'<b>&lt;certificate-key-password&gt;</b>' </li>
<li>
'<b>&lt;trusted-certificates&gt;</b>' </li>
</ul>
<p>As with sources and receivers, the portals on both sides of a peer link must be configured for compatible encryption settings.</p>
<p>Notice that there is no element corresponding to the context option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpencryptedtcp.html#tlscompressionnegotiationtimeoutcontext">tls_compression_negotiation_timeout (context)</a>. The UM Router peer link's negotiation timeout is hard-coded to 5 seconds.</p>
<p>See the UM Router configuration DTD for details.</p>
<p><br />
 </p>
<h2><a class="anchor" id="tlsandcompression"></a>
TLS and Compression</h2>
<p>Many users have advanced network equipment (switches/routers), which transparently compress packets as they traverse the network. This compression is especially valued to conserve bandwidth over long-haul WAN links. However, when packets are encrypted, the network compressors are typically not able to reduce the size of the data. If the user desires UM messages to be compressed and encrypted, the data needs to be compressed before it is encrypted.</p>
<p>The UM compression feature (see <a class="el" href="umfeatures.html#compressedtcp">Compressed TCP</a>) accomplishes this. When both TLS and compression are enabled, the compression is applied to user data first, then encryption.</p>
<p>Be aware that there can be information leakage when compression is applied and an attacker is able to inject data of known content over a compressed and encrypted session. For example, this leakage is exploited by the <a href="https://en.wikipedia.org/wiki/CRIME">CRIME</a> attack, albeit primarily for web browsers. Users must weigh the benefits of compression against the potential risk of information leakage.</p>
<p><b>Version Interoperability</b></p>
<p>It is not recommended to mix pre-6.9 contexts with encrypted contexts on topics of shared interest. If a process with a pre-6.9 version of UM creates a receiver, and another process with UM 6.9 or beyond creates a TLS source, the pre-6.9 receiver will attempt to join the TLS source. After a timeout, the handshake will fail and the source will disconnect. The pre-6.9 receiver will retry the connection, leading to flapping.</p>
<p>Note that in the reverse situation, a 6.9 TLS receiver will simply ignore a pre-6.9 source. I.e. no attempt will be made to join, and no flapping will occur.</p>
<p><br />
 </p>
<h1><a class="anchor" id="compressedtcp"></a>
Compressed TCP</h1>
<p>This section introduces the use of Compression with TCP connections.</p>
<p>The goal of the Ultra Messaging (UM) compression feature is to decrease the size of transmitted application data. UM can be configured to apply compression to all Streaming and/or Persisted TCP communication.</p>
<p>Non-TCP communication is not compressed (e.g. topic resolution).</p>
<p>Compression is generally implemented by any of several different software packages. UM makes use of LZ4, a widely deployed open-source project.</p>
<p>While the UM compression feature is usable for TCP-based sources and receivers, it is possibly most useful when applied to UM Router peer links.</p>
<p><br />
 </p>
<h2><a class="anchor" id="compressionconfiguration"></a>
Compression Configuration</h2>
<p>Compression is enabled on a context basis. When enabled, all Streaming and Persistence related TCP-based communication into or out of the context is compressed by LZ4. A context with compression enabled will not accept source creation with transports other than TCP.</p>
<p>Subscribers will only successfully receive data if the receiver's context and the source's context share the same compression settings. A receiver created in a compression-enabled context will ignore topic resolution source advertisements for non-compressed sources, and will therefore not subscribe. Similarly, a receiver created in an non-compressed context will ignore topic resolution source advertisements for compressed sources. Topic resolution queries are also ignored by mis-matched contexts. No warning will be logged when these topic resolution datagrams are ignored, but each time this happens, the context-level statistic tr_dgrams_dropped_type is incremented.</p>
<p>Compression is applied to unicast immediate messages as well, as invoked either directly by the user, or internally by functions like late join, request/response, and Persistence-related communication between sources, receivers, and stores.</p>
<p>Brokered Queuing using AMQP does not use the UM compression feature. A UM brokered context does not allow compression to be enabled.</p>
<p>The compression-related configuration options used by the Ultra Messaging library are:</p>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpcompressedtcp.html#compressioncontext">compression (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpencryptedtcp.html#tlscompressionnegotiationtimeoutcontext">tls_compression_negotiation_timeout (context)</a> </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="compressionandpersistence"></a>
Compression and Persistence</h2>
<p>Compression is designed to compress a data transport session. It is not intended to compress data at rest. When a Persistent Store is used with the UM compression feature, the user messages are written to disk in uncompressed form.</p>
<p><br />
 </p>
<h2><a class="anchor" id="compressionandqueuing"></a>
Compression and Queuing</h2>
<p>The UM compression feature does not apply to the AMQP connection to the brokered queue. UM does not currently support compression on the AMQP connection.</p>
<p>However, the ULB form of queuing does not use a broker. For ULB sources that are configured for TCP, the UM compression feature will compress the application data.</p>
<p><br />
 </p>
<h2><a class="anchor" id="compressionandthedynamicroutingoptiondro"></a>
Compression and the Dynamic Routing Option (DRO)</h2>
<p>When a UM Router is used to route messages across topic resolution domains (TRDs), be aware that the compression session is terminated at the UM Router's proxy receiver/source. Because each endpoint portal on a UM Router is implemented with its own context, care must be taken to ensure end-to-end compression (if desired). As a message is forwarded through a UM Router network, it does not propagate the compression setting of the originator, so each portal needs to be appropriately compressed.</p>
<p>Possibly the most-useful application of the UM compression feature is not TCP sources, but rather UM Router peer links. The compression feature is extended to UM Router peer links, however peer links are not context-based and are not configured the same way. The following XML elements are used by the UM Router to configure a peer link:</p>
<ul>
<li>
'<b>&lt;compression&gt;</b>' </li>
</ul>
<p>As with sources and receivers, the portals on both sides of a peer link must be configured for the same compression setting.</p>
<p>Notice that there is no element corresponding to the context option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpencryptedtcp.html#tlscompressionnegotiationtimeoutcontext">tls_compression_negotiation_timeout (context)</a>. The UM Router peer link's negotiation timeout is hard-coded to 5 seconds.</p>
<p>See the UM Router configuration DTD for details.</p>
<p><br />
 </p>
<h2><a class="anchor" id="compressionandencryption"></a>
Compression and Encryption</h2>
<p>See <a class="el" href="umfeatures.html#tlsandcompression">TLS and Compression</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="versioninteroperability"></a>
Version Interoperability</h2>
<p>It is not recommended to mix pre-6.9 contexts with compressed contexts on topics of shared interest. As mentioned above, if a compressed and an uncompressed context connect via TCP, the connection will fail and retry, resulting in flapping.</p>
<p><br />
 </p>
<h1><a class="anchor" id="highresolutiontimestamps"></a>
High-resolution Timestamps</h1>
<p>This section introduces the use of high-resolution timestamps with LBT-RM.</p>
<p>The Ultra Messaging (UM) high-resolution message timestamp feature leverages the hardware timestamping function of certain Solarflare network interface cards (NICs) to measure sub-microsecond times that packets are transmitted and received. Solarflare's NICs and Onload kernel-bypass driver implement PTP to synchronize timestamps across the network, allowing very accurate one-way latency measurements. The UM timestamp feature requires Solarflare OpenOnload version 201509 or later.</p>
<p>For subscribers, each message's receive timestamp is delivered in the message's header structure (for C programs, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aaa7a945411e63884f12918417e8d117c">lbm_msg_t</a> field <b>hr_timestamp</b>, of type <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a60ce419ca9bccc4d2b61b9acb70fe30e">lbm_timespec_t</a>). Each timestamp is a structure of 32 bits worth of seconds and 32 bits worth of nanoseconds. When both values are zero, the timestamp is not available.</p>
<p>For publishers, each message's transmit timestamp is delivered via the source event callback (for C programs, event type LBM_SRC_EVENT_TIMESTAMP). The same timestamp structure as above is delivered with the event, as well as the message's sequence number. Sending applications can be informed of the outgoing sequence number range of each message by using the extended form of the send function and supplying the LBM_SRC_SEND_EX_FLAG_SEQUENCE_NUMBER_INFO flag. This causes the LBM_SRC_EVENT_SEQUENCE_NUMBER_INFO event to be delivered to the source event handler.</p>
<p><br />
 </p>
<h2><a class="anchor" id="timestamprestrictions"></a>
Timestamp Restrictions</h2>
<p>Due to the specialized nature of this feature, there are several restrictions in its use.</p>
<ol>
<li>
<b>Operating system</b>: Linux only. No timestamps will be delivered on other operating systems. Also, since the feature makes use of the rcvmmsg() function, no timestamps will be delivered on Linux kernels prior to 2.6.33 and glibc libraries prior to 2.12 (which was released in 2010). </li>
<li>
<b>Languages</b>: C and Java only. </li>
<li>
<b>Transport</b>: Source-based LBT-RM (multicast) transport sessions only. No timestamps will be delivered for MIM or other transport types. </li>
<li>
<b>Queuing</b>: Timestamps are not supported for broker-based queuing. If a ULB source is configured for LBT-RM, send-side timestamps are not supported and will not be delivered if one or more receivers are registered. However, on the receive side, ULB messages are time stamped. </li>
<li>
<b>Loss</b>: If packet loss triggers LBT-RM's NAK/retransmit sequence, the send side will have multiple timestamps delivered, one for each multicast transmission. On the receive side, the timestamp of the first successfully received multicast datagram will be delivered. </li>
<li>
<b>Recovery</b>: For missed messages which are recovered via Late Join, Off-Transport Recovery (OTR), or the Persistent Store, no timestamp will be delivered, either on the send side or the receive side. </li>
<li>
<b>Implicit batching</b>: If implicit batching is being used, only the first message in a batch will have a send-side timestamp delivered. When implicit batching is used, the sender must be prepared for some messages to not have timestamps delivered. On the receive side, all messages in a batch will have the same timestamp. </li>
<li>
<b>UM Fragmentation, send-side</b>: If user messages are too large to be contained in a single datagram, UM will fragment the message into multiple datagrams. On the send side, each datagram will trigger delivery of a timestamp. <ul>
<li>
UM Fragmentation, receive-side with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#ordereddeliveryreceiver">ordered_delivery (receiver)</a> set to 0 (arrival): Arrival-order delivery will result in each fragment being delivered separately, as it is received. Each fragment's message header will contain a timestamp. Arrival order delivery provides an accurate timestamp of when the complete message is received (although, as mentioned above, any fragment recovered via OTR or the Persistent Store will not have a timestamp). </li>
<li>
UM Fragmentation, receive-side with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#ordereddeliveryreceiver">ordered_delivery (receiver)</a> set to 1 or -1, (reassembly): Delivery with reassembly results in a single timestamp included in the message header. That timestamp corresponds to the arrival of the last fragment of the message (although, as mentioned above, any fragment recovered via OTR or the Persistent Store will not have a timestamp). Note that this is not necessarily the last fragment received; if an intermediate datagram is lost and subsequently re-transmitted after a delay, that intermediate datagram will be the last one received, but its timestamp will not be used for the message. For example, if a three-fragment message is received in the order of F0, F2, F1, the timestamp for the message will correspond to F2, the last fragment of the message. If fragmented messages are being sent, and an accurate time of message completion is needed, arrival order delivery must be used. </li>
</ul>
</li>
<li>
<b>UM Fragmentation plus implicit batching</b>: If user messages vary widely in size, some requiring fragmentation, and implicit batching is used be aware that a full fragment does not completely fill a datagram. For example, if a small message (less than 300 bytes) is sent followed by a large message requiring fragmentation, the first fragment of the large message will fit in the same datagram as the small message. In that case, on the send side, a timestamp will not be delivered for that first fragment. However, a timestamp will be delivered for the second fragment. On the receive side, the same restrictions apply as described with UM fragmentation. </li>
<li>
<b>Local loopback</b>: If an LBT-RM source and receiver share the same physical machine, the receive side will not have timestamps delivered. </li>
</ol>
<p><br />
 </p>
<h2><a class="anchor" id="timestampconfigurationsummary"></a>
Timestamp Configuration Summary</h2>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmoperation.html#transportlbtrmsourcetimestampcontext">transport_lbtrm_source_timestamp (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmoperation.html#transportlbtrmreceivertimestampcontext">transport_lbtrm_receiver_timestamp (context)</a> </li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="receivemultipledatagrams"></a>
Receive Multiple Datagrams</h1>
<p>A UM receiver for UDP-based protocols normally retrieves a single UDP datagram from the socket with each socket read. Setting <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#multiplereceivemaximumdatagramscontext">multiple_receive_maximum_datagrams (context)</a> to a value greater than zero directs UM to retrieve up to that many datagrams with each socket read. When receive socket buffers accumulate multiple messages, this feature improves CPU efficiency, which reduces the probability of loss, and also reduces total latency for those buffered datagrams. Note that UM does not need to wait for that many datagrams to be received before processing them; if fewer datagrams are in the socket's receive buffer, only the available datagrams retrieved.</p>
<p>In addition to increasing efficiency, setting <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#multiplereceivemaximumdatagramscontext">multiple_receive_maximum_datagrams (context)</a> greater than zero can produce changes in the dynamic behavior across multiple sockets. For example, let's say that a receiver is subscribed to two transport sessions, A and B. Let's further say that transport session A is sending message relatively quickly and has built up several datagrams in its socket buffer. Further, B is sending slowly. If <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#multiplereceivemaximumdatagramscontext">multiple_receive_maximum_datagrams (context)</a> is zero, the two sockets will compete equally for UM's attention. I.e. B's socket will still have a chance to be read after each A datagram is read and processed. However, if <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#multiplereceivemaximumdatagramscontext">multiple_receive_maximum_datagrams (context)</a> is 10, then UM can process up to 10 of A's messages before giving B a chance to be read. This is desirable if low message latency is equally important across all transport sessions; the efficiency improvement derived by retrieving multiple datagrams with each read operation results in lower overall latency. However, if it is more important to minimize latency of the slower transport session's messages, then it would be better to set <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#multiplereceivemaximumdatagramscontext">multiple_receive_maximum_datagrams (context)</a> close to or equal to zero.</p>
<p>The <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#multiplereceivemaximumdatagramscontext">multiple_receive_maximum_datagrams (context)</a> configuration option defaults to 0 so as to retain previous behavior, but users are encouraged to set this to a value between 2 and 10. Having too large a value during a period of overload can lead to starvation of low-rate transport sessions by high-rate transport sessions.</p>
<p><br />
 </p>
<h2><a class="anchor" id="receivemultipledatagramscompatibility"></a>
Receive Multiple Datagrams Compatibility</h2>
<p>The Receive Multiple Datagrams feature is compatible with the following UM features:</p>
<ul>
<li>
UDP-based transport protocols LBT-RM and LBT-RU. </li>
<li>
MIM (Multicast Immediate Message). </li>
<li>
UDP-based Topic Resolution protocol, both multicast and unicast. </li>
<li>
All language bindings (C, Java, .NET). </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="receivemultipledatagramsrestrictions"></a>
Receive Multiple Datagrams Restrictions</h2>
<p>The Receive Multiple Datagrams feature is not compatible with the following UM features:</p>
<ul>
<li>
Non-UDP Transport Protocols (TCP, IPC, SMX). </li>
<li>
Other TCP-based features (Unicast Immediate Message, Late Join, Persistent Store Recovery, UM Response messages). </li>
<li>
Non-Linux. The recvmmsg() function was introduced into the Linux kernel in version 2.6.33, and support for it was added to glibc in version 2.12. </li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="messageproperties"></a>
Message Properties</h1>
<p>The message property object <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a9155c3d6d70b67c426089d53b3eacaac">lbm_msg_properties_t</a> allows your application to insert named, typed metadata to topic messages and implement functionality that depends on the message properties. UM allows eight property types: boolean, byte, short, int, long, float, double, and string.</p>
<p>To use message properties, create a message properties object with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#abda1a4224f1c3e94b10b74051be3dd53">lbm_msg_properties_create()</a>. Then set the desired message properties using <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#acec18484fc06996fe3b61e76a593d5fb">lbm_msg_properties_set()</a>. Then send topic messages with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a091b5806bf18d10ebd0d9117e0c70229">lbm_src_send_ex()</a> (or LBMSource.send() in the Java API or .NET API) passing the message properties object through <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a21504de56612c7c6e4be655402b47a37">lbm_src_send_ex_info_t</a> object. Set the LBM_SRC_SEND_EX_FLAG_PROPERTIES flag on the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a21504de56612c7c6e4be655402b47a37">lbm_src_send_ex_info_t</a> object to indicate that it includes properties.</p>
<p>Upon a receipt of a message with properties, your application can access the properties directly through the messages properties field, which is null if no properties are present. Individual property values can be retrieved directly by name, or you can iterate over the collection of properties to determine which properties are present at runtime. For an example on how to iterate received message properties, see <a href="../example/lbmrcv.c">lbmrcv.c</a>.</p>
<p>To mitigate any performance impacts in the C API, reuse properties objects, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a21504de56612c7c6e4be655402b47a37">lbm_src_send_ex_info_t</a> objects and iterators whenever possible. Also limit the number of properties associated with a message. (UM sends the property name and additional indexing information with every message.) In the Java API or .NET API, also make use of the ZOD feature by calling Dispose() on each message before returning from the application callback. This allows property objects to be reused as well.</p>
<dl class="section note"><dt>Note</dt><dd>The Message Properties Object does not support receivers using the arrival order without reassembly setting (option value = 0) of <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#ordereddeliveryreceiver">ordered_delivery (receiver)</a>.</dd></dl>
<p>With the UMQ product, the UM message property object supports the standard JMS message properties specification.</p>
<p><br />
 </p>
<h2><a class="anchor" id="smartsourcesandmessageproperties"></a>
Smart Sources and Message Properties</h2>
<p><a class="el" href="umfeatures.html#smartsources">Smart Sources</a> support a limited form of message properties. Only 32-bit integer property types are allowed with Smart Sources. Also, property names are limited to 7 ASCII characters. Finally, the normal message properties object <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a9155c3d6d70b67c426089d53b3eacaac">lbm_msg_properties_t</a> and its APIs <em>are not used</em> on the sending side. Rather a streamlined method of specifying message properties for sending is used.</p>
<p>As with most of Smart Source's internal design, the message header for message properties must be pre-allocated with the maximum number of desired message properties. This is done at creation time for the Smart Source using the configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpsmartsource.html#smartsrcmessagepropertyintcountsource">smart_src_message_property_int_count (source)</a>.</p>
<p>Sending messages with message properties must be done using the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a2f50f56536778332e9f5712b06546425">lbm_ssrc_send_ex()</a> API, passing it the desired properties. The first call to send with message properties will parse the supplied properties and encode them into the pre-allocated message header.</p>
<p>Subsequent calls to send with message properties will ignore the passed-in properties and simply re-send the previously-parsed header. If it is desired to change the message properties after that initial send, it is necessary to pass an "update property values" flag, which will trigger a re-parse of the passed-in properties.</p>
<p>Once the message property header is parsed, it is also possible to send messages without the properties attached. This does not require the "update property values" flag, and does not involve re-parsing the header. See next section for details.</p>
<dl class="section note"><dt>Note</dt><dd>If using both message properties and <a class="el" href="umfeatures.html#spectrum">Spectrum</a> with a single Smart Source, there is an added restriction: it is not possible to send a message omitting only one of those features. I.e. if both are enabled when the Smart Source is created, it is not possible to send a message with a message property and not a channel, and it is not possible to send a message with a channel and not a property. This is because the message header is defined at Smart Source creation, and the header either must contain both or neither.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="smartsourcemessagepropertiesusage"></a>
Smart Source Message Properties Usage</h2>
<p>For a full example of message property usage with Smart Source, see <a href="../example/lbmssrc.c">lbmssrc.c</a> or <a href="../java_example/lbmssrc.java">lbmssrc.java</a>.</p>
<p>The first message with a message property sent to a Smart Source follows a specific sequence:</p>
<ol>
<li>
<p class="startli">Create the topic object with the configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpsmartsource.html#smartsrcmessagepropertyintcountsource">smart_src_message_property_int_count (source)</a> set to the maximum number of properties desired on a message.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Create the Smart Source with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a9a8d169a8c2a90b8442d4eb3e3711c9c">lbm_ssrc_create()</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Optionally, one or more messages can be sent without message properties.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">When preparing the first message with message properties to be sent, define the properties using a <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a33886eeac2e67170effea009d2dc3a35">lbm_ssrc_send_ex_info_t</a> structure: </p><pre class="fragment">  char *prop_name_array[3]; /* Array of property names. */
  prop_name_array[0] = "abc"; /* 7 ascii characters or less. */
  prop_name_array[1] = "XYZ";
  prop_name_array[2] = "123";

  lbm_int32_t prop_value_array[3]; /* Array of property values. */
  prop_value_array[0] = 29;
  prop_value_array[1] = -300;
  prop_value_array[2] = 0;

  lbm_ssrc_send_ex_info_t ss_send_info;
  memset((char *)&amp;ss_send_info, 0, sizeof(ss_send_info));
  ss_send_info.mprop_int_cnt = 3;
  ss_send_info.mprop_int_keys = prop_name_array;
  ss_send_info.mprop_int_vals = prop_value_array;
</pre><p class="endli"></p>
</li>
<li>
<p class="startli">Send the message using <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a2f50f56536778332e9f5712b06546425">lbm_ssrc_send_ex()</a> and the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#af00465b8e9c560959351ec92f62a190e">LBM_SSRC_SEND_EX_FLAG_PROPERTIES</a> flag: </p><pre class="fragment">  /* If this flag had been cleared previously, must set it. */
  ss_send_info.flags |= LBM_SSRC_SEND_EX_FLAG_PROPERTIES;/*set*/
  /* If this flag had been set previously, must clear it. */
  ss_send_info.flags &amp;= ~ LBM_SSRC_SEND_EX_FLAG_UPDATE_PROPERTY_VALUES;/*clr*/
  err = lbm_ssrc_send_ex(ss, msg_buff, msg_size, 0, &amp;ss_send_info);
</pre><p class="endli">Since this is the first send with message properties, UM will parse the properties and set up the message header. It is not valid to set the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a40748fccf40f69c2029d68c16f923704">LBM_SSRC_SEND_EX_FLAG_UPDATE_PROPERTY_VALUES</a> flag on this first send with message properties. </p>
</li>
</ol>
<p>For subsequent sends, there are three choices: </p><ol>
<li>
<p class="startli">Send the message with the same properties and values. You can re-use the same <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a33886eeac2e67170effea009d2dc3a35">lbm_ssrc_send_ex_info_t</a> object: </p><pre class="fragment">  /* If this flag had been cleared previously, must set it. */
  ss_send_info.flags |= LBM_SSRC_SEND_EX_FLAG_PROPERTIES;/*set*/
  /* If this flag had been set previously, must clear it. */
  ss_send_info.flags &amp;= ~ LBM_SSRC_SEND_EX_FLAG_UPDATE_PROPERTY_VALUES;/*clr*/
  err = lbm_ssrc_send_ex(ss, msg_buff, msg_size, 0, &amp;ss_send_info);
</pre><p> Note that even though the lbm_ssrc_send_ex_info_t object is passed in and the message properties will be sent with the message, this call to <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a2f50f56536778332e9f5712b06546425">lbm_ssrc_send_ex()</a> will <em>not</em> re-parse the application's message properties, so any changes made to the properties or their values in the lbm_ssrc_send_ex_info_t object will be ignored (see next item).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Send a with message properties after having made changes to the properties and/or their values by setting the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a40748fccf40f69c2029d68c16f923704">LBM_SSRC_SEND_EX_FLAG_UPDATE_PROPERTY_VALUES</a> flag: </p><pre class="fragment">  /* If either of these flags had been cleared previously, must set it. */
  ss_send_info.flags |= LBM_SSRC_SEND_EX_FLAG_PROPERTIES;/*set*/
  ss_send_info.flags |= LBM_SSRC_SEND_EX_FLAG_UPDATE_PROPERTY_VALUES;/*set*/
  err = lbm_ssrc_send_ex(ss, msg_buff, msg_size, 0, &amp;ss_send_info);
</pre><p class="endli"></p>
</li>
<li>
<p class="startli">Send a message without any message properties by clearing the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#af00465b8e9c560959351ec92f62a190e">LBM_SSRC_SEND_EX_FLAG_PROPERTIES</a> flag: </p><pre class="fragment">  /* If either of these flags had been set previously, must clear it. */
  ss_send_info.flags &amp;= ~ LBM_SSRC_SEND_EX_FLAG_PROPERTIES;/*clr*/
  ss_send_info.flags &amp;= ~ LBM_SSRC_SEND_EX_FLAG_UPDATE_PROPERTY_VALUES;/*clr*/
  err = lbm_ssrc_send_ex(ss, msg_buff, msg_size, 0, &amp;ss_send_info);
</pre><p class="endli">Alternatively, you can simply not supply a <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a33886eeac2e67170effea009d2dc3a35">lbm_ssrc_send_ex_info_t</a> object by passing NULL for the <code>info</code> parameter. This suppresses all features enabled by that structure. </p>
</li>
</ol>
<p><br />
 </p>
<h1><a class="anchor" id="requestresponsemodel"></a>
Request/Response Model</h1>
<p>Request/response is a very common messaging model whereby a client sends a "request" message to a server and expects a response. The server processes the request and return a response message to the originating client.</p>
<p>The UM request/response feature simplifies implementation of this model in the following ways: </p><ul>
<li>
Handling the request's "return address", eliminating the need for the client to create an artificial guaranteed-unique topic for the response. </li>
<li>
Establishing a linkage between a request and its response(s), allowing multiple requests to be outstanding, and associating each response message with its corresponding request message. </li>
<li>
Supporting multiple responses per request, both by allowing multiple servers to receive the request and each one responding, and by allowing a given server to respond with multiple messages. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="requestmessage"></a>
Request Message</h2>
<p>UM provides three ways to send a request message.</p>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ad4d06f66b8404684e191ca178e0cc09b">lbm_send_request()</a> to send a request to a topic via a source object. Uses the standard source-based transports (TCP, LBT-RM, LBT-RU). </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a54f3933e4dd154a9c7bb72598d0d9ef1">lbm_multicast_immediate_request()</a> to send a request to a topic as a multicast immediate message. See <a class="el" href="umfeatures.html#multicastimmediatemessaging">Multicast Immediate Messaging</a>. </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ae011c7a66e1db1f012d7f9633dbd321d">lbm_unicast_immediate_request()</a> to send a request to a topic as a unicast immediate message. </li>
</ul>
<p>When the client application sends a request message, it references an application callback function for responses and a client data pointer for application state. The send call returns a "request object". As one or more responses are returned, the callback is invoked to deliver the response messages, associated with the request's client data pointer. The requesting application decides when its request is satisfied (perhaps by completeness of a response, or by timeout), and it calls <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a0abaa1c2ba62bba7a5eaf1f7f2abbac0">lbm_request_delete()</a> to delete the request object. Even if the server chooses to send additional responses, they will not be delivered to the requesting application after it has deleted the corresponding request object.</p>
<p><br />
 </p>
<h2><a class="anchor" id="responsemessage"></a>
Response Message</h2>
<p>The server application receives a request via the normal message receive mechanism, but the message is identified as type "request". Contained within that request message's header is a response object, which serves as a return address to the requester. The server application responds to an UM request message by calling <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a0bbc01b600ccc2ae874474e35955eb85">lbm_send_response()</a>. The response message is sent unicast via a dynamic TCP connection managed by UM.</p>
<dl class="section warning"><dt>Warning</dt><dd>The <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a0bbc01b600ccc2ae874474e35955eb85">lbm_send_response()</a> function may not be called from a context thread callback. If the application needs to send the response from the receiver callback, it must associate that receiver callback with an event queue.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since the response object is part of the message header, it is normally deleted at the same time that the message is deleted, which typically happens automatically when the receiver callback returns. However, there are times when the application needs the scope of the response object to extend beyond the execution of the receiver callback. One method of extending the lifetime of the response object is to "retain" the request message, using <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a2b7788ff58f9e78bc89ea890dad0cccf">lbm_msg_retain()</a>. </dd></dl>
<dl class="section user"><dt></dt><dd>However, there are times when the size of the request message makes retention of the entire message undesirable. In those cases, the response object itself can be extracted and retained separately by saving a copy of the response object pointer and setting the message header's response pointer to NULL (to prevent UM from deleting the response object when the message is deleted). </dd></dl>
<dl class="section user"><dt></dt><dd>There are even occasions when an application needs to transfer the responsibility of responding to a request message to a different process entirely. I.e. the server which receives the request is not itself able to respond, and needs to send a message (not necessarily the original request message) to a different server. In that case, the first server which receives the request must serialize the response object to type <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a54cfbb23ab41a8d22968f68df015e246">lbm_serialized_response_t</a> by calling <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a7595677bf01cb9397d1fd174bd095e9f">lbm_serialize_response()</a>. It includes the serialized response object in the message forwarded to the second server. That server de-serializes the response object by calling <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ad74f47a1e021b2422b80c0bf8d03f7a9">lbm_deserialize_response()</a>, allowing it to send a response message to the original requesting client.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="tcpmanagement"></a>
TCP Management</h2>
<p>UM creates and manages the special TCP connections for responses, maintaining a list of active response connections. When an application sends a response, UM scans that list for an active connection to the destination. If it doesn't find a connection for the response, it creates a new connection and adds it to the list. After the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a0bbc01b600ccc2ae874474e35955eb85">lbm_send_response()</a> function returns, UM schedules the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpresponseoperation.html#responsetcpdeletiontimeoutcontext">response_tcp_deletion_timeout (context)</a>, which defaults to 2 seconds. If a second request comes in from the same application before the timer expires, the responding application simply uses the existing connection and restarts the deletion timer.</p>
<p>It is conceivable that a very large response could take more than the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpresponseoperation.html#responsetcpdeletiontimeoutcontext">response_tcp_deletion_timeout (context)</a> default (2 seconds) to send to a slow-running receiver. In this case, UM automatically increases the deletion timer as needed to ensure the last message completes.</p>
<p><br />
 </p>
<h2><a class="anchor" id="requestresponseconfiguration"></a>
Request/Response Configuration</h2>
<p>See the <a href="../Config/index.html">UM Configuration Guide</a> for the descriptions of the Request/Response configuration options.</p>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grprequestnetwork.html">Request Network Options</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grprequestoperation.html">Request Operation Options</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpresponseoperation.html">Response Operation Options</a> </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>If your application is running within an UM context where the configuration option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grprequestnetwork.html#requesttcpbindrequestportcontext">request_tcp_bind_request_port (context)</a> has been set to zero, request port binding has been turned off, which also disables the Request/Response feature.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="requestresponseexampleapplications"></a>
Request/Response Example Applications</h2>
<p>UM includes two example applications that illustrate Request/Response.</p>
<ul>
<li>
<a href="../example/lbmreq.c">lbmreq.c</a> - application that sends requests on a given topic (single source) and waits for responses. See also the Java example, <a href="../java_example/lbmreq.java">lbmreq.java</a> and the .NET example, <a href="../dotnet_example/lbmreq.cs">lbmreq.cs</a>. </li>
<li>
<a href="../example/lbmresp.c">lbmresp.c</a> - application that waits for requests and sends responses back on a given topic (single receiver). See also the Java example, <a href="../java_example/lbmresp.java">lbmresp.java</a> and the .NET example, <a href="../dotnet_example/lbmresp.cs">lbmresp.cs</a>. </li>
</ul>
<p>We can demonstrate a series of 5 requests and responses with the following procedure:</p>
<ul>
<li>
Run <b>lbmresp -v topicname</b> </li>
<li>
Run <b>lbmreq -R 5 -v topicname</b> </li>
</ul>
<p><b>LBMREQ</b></p>
<p>Output for lbmreq should resemble the following:</p>
<pre class="fragment">$ lbmreq -R 5 -q topicname
Event queue in use
Using TCP port 4392 for responses
Delaying requests for 1000 milliseconds
Sending request 0
Starting event pump for 5 seconds.
Receiver connect [TCP:10.29.1.78:4958]
Done waiting for responses. 1 responses (25 bytes) received. Deleting request. Sending request 1
Starting event pump for 5 seconds.
Done waiting for responses. 1 responses (25 bytes) received. Deleting request. Sending request 2
Starting event pump for 5 seconds.
Done waiting for responses. 1 responses (25 bytes) received. Deleting request. Sending request 3
Starting event pump for 5 seconds.
Done waiting for responses. 1 responses (25 bytes) received. Deleting request. Sending request 4
Starting event pump for 5 seconds.
Done waiting for responses. 1 responses (25 bytes) received. Deleting request.
Quitting...
</pre><p><b>LBMRESP</b></p>
<p>Output for lbmresp should resemble the following:</p>
<pre class="fragment">$ lbmresp -v topicname
Request [topicname][TCP:10.29.1.78:14371][0], 25 bytes
Sending response. 1 responses of 25 bytes each (25 total bytes).
Done sending responses. Deleting response.
Request [topicname][TCP:10.29.1.78:14371][1], 25 bytes
Sending response. 1 responses of 25 bytes each (25 total bytes).
Done sending responses. Deleting response.
Request [topicname][TCP:10.29.1.78:14371][2], 25 bytes
Sending response. 1 responses of 25 bytes each (25 total bytes).
Done sending responses. Deleting response.
Request [topicname][TCP:10.29.1.78:14371][3], 25 bytes
Sending response. 1 responses of 25 bytes each (25 total bytes).
Done sending responses. Deleting response.
Request [topicname][TCP:10.29.1.78:14371][4], 25 bytes
Sending response. 1 responses of 25 bytes each (25 total bytes).
Done sending responses. Deleting response.
[topicname][TCP:10.29.1.78:14371], End of Transport Session
</pre><p><br />
 </p>
<h1><a class="anchor" id="selfdescribingmessaging"></a>
Self Describing Messaging</h1>
<p>The UM Self-Describing Messaging (SDM) feature provides an API that simplifies the creation and use of messages by your applications. An SDM message contains one or more fields and each field consists of the following:</p>
<ul>
<li>
A name </li>
<li>
A type </li>
<li>
A value </li>
</ul>
<p>Each named field may appear only once in a message. If multiple fields of the same name and type are needed, array fields are available. A field in a nested message may have the same name as a field in the outer message.</p>
<p>SDM is particularly helpful for creating messages sent across platforms by simplifying the creation of data formats. SDM automatically performs platform-specific data translations, eliminating endian conflicts.</p>
<p>Using SDM also simplifies message maintenance because the message format or structure can be independent of the source and receiver applications. For example, if your receivers query SDM messages for particular fields and ignore the order of the fields within the message, a source can change the field order if necessary with no modification of the receivers needed.</p>
<p>See the C, Java, and .NET API guides for details.</p>
<p><br />
 </p>
<h1><a class="anchor" id="predefinedmessages"></a>
Pre-Defined Messages</h1>
<p>The UM Pre-Defined Messages (PDM) feature provides an API similar to the SDM API, but allows you to define messages once and then use the definition to create messages that may contain self-describing data. Eliminating the need to repeatedly send a message definition increases the speed of PDM over SDM. The ability to use arrays created in a different programming language also improves performance.</p>
<p>The PDM library lets you create, serialize, and deserialize messages using pre-defined knowledge about the possible fields that may be used. You can create a definition that a) describes the fields to be sent and received in a message, b) creates the corresponding message, and c) adds field values to the message. This approach offers several performance advantages over SDM, as the definition is known in advance. However, the usage pattern is slightly different than the SDM library, where fields are added directly to a message without any type of definition.</p>
<p>A PDM message contains one or more fields and each field consists of the following:</p>
<ul>
<li>
A name </li>
<li>
A type </li>
<li>
A value </li>
</ul>
<p>Each named field may appear only once in a message. If multiple fields of the same name and type are needed, array fields are available. A field in a nested message may have the same name as a field in the outer message.</p>
<p>See the C, Java, and .NET Application Programmer's Interfaces for complete references of PDM functions, field types and message field operations. The C API also has information and code samples about how to create definitions and messages, set field values in a message, set the value of array fields in a message, serialize, deserialize and dispose of messages, and fetch values from a message.</p>
<dl class="section note"><dt>Note</dt><dd>The Pre-Defined Messaging (PDM) feature is not supported on the OpenVMS platform.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="typicalpdmusagepatterns"></a>
Typical PDM Usage Patterns</h2>
<p>The typical PDM usage patterns can usually be broken down into two categories: sources (which need to serialize a message for sending) and receivers (which need to deserialize a message to extract field values). However, for optimum performance for both sources and receivers, first set up the definition and a single instance of the message only once during a setup or initialization phase, as in the following example workflow:</p>
<ol>
<li>
Create a definition and set its id and version. </li>
<li>
Add field information to the definition to describe the types of fields to be in the message. </li>
<li>
Create a single instance of a message based on the definition. </li>
<li>
Set up a source to do the following: <ul>
<li>
Add field values to the message instance. </li>
<li>
Serialize the message so that it can be sent. </li>
</ul>
</li>
<li>
Likewise, set up a receiver to do the following: <ul>
<li>
Deserialize the received bytes into the message instance. </li>
<li>
Extract the field values from the message. </li>
</ul>
</li>
</ol>
<p><br />
 </p>
<h2><a class="anchor" id="gettingstartedwithpdm"></a>
Getting Started with PDM</h2>
<p>PDM APIs are provided in C, Java, and C#, however, the examples in this section are Java based.</p>
<p><b>PDM Code Example, Source</b></p>
<p>Translating the Typical PDM Usage Patterns to Java for a source produces the following:</p>
<pre class="fragment">private PDMDefinition defn;
private PDMMessage msg;
private PDMFieldInfo fldInfo100;
private PDMFieldInfo fldInfo101;
private PDMFieldInfo fldInfo102;

public void setupPDM() {
  //Create the definition with 3 fields and using int field names
  defn = new PDMDefinition(3, true);

  //Set the definition id and version
  defn.setId(1001);
  defn.setMsgVersMajor((byte)1);
  defn.setMsgVersMinor((byte)0);

  //Create information for a boolean, int32, and float fields (all required)
  fldInfo100 = defn.addFieldInfo(100, PDMFieldType.BOOLEAN, true);
  fldInfo101 = defn.addFieldInfo(101, PDMFieldType.INT32, true);
  fldInfo102 = defn.addFieldInfo(102, PDMFieldType.FLOAT, true);

  //Finalize the definition and create the message defn.finalizeDef();
  msg = new PDMMessage(defn);
}

public void sourceUsePDM() {
  //Call the function to setup the definition and message
  setupPDM();

  //Example values for the message boolean
  fld100Val = true;
  int fld101Val = 7;
  float fld102Val = 3.14F;

  //Set each field value in the message
  msg.setFieldValue(fldInfo100, fld100Val);
  msg.setFieldValue(fldInfo101, fld101Val);
  msg.setFieldValue(fldInfo102, fld102Val);

  //Serialize the message to bytes
  byte[] buffer = msg.toBytes();
}
</pre><p><b>PDM Code Example, Receiver</b></p>
<p>Translating the Typical PDM Usage Patterns to Java for a receiver produces the following:</p>
<pre class="fragment">private PDMDefinition defn;
private PDMMessage msg;
private PDMFieldInfo fldInfo100;
private PDMFieldInfo fldInfo101;
private PDMFieldInfo fldInfo102;

public void setupPDM() {
  //Create the definition with 3 fields and using int field names
  defn = new PDMDefinition(3, true);

  //Set the definition id and version
  defn.setId(1001);
  defn.setMsgVersMajor((byte)1);
  defn.setMsgVersMinor((byte)0);

  //Create information for a boolean, int32, and float field (all required)
  fldInfo100 = defn.addFieldInfo(100, PDMFieldType.BOOLEAN, true);
  fldInfo101 = defn.addFieldInfo(101, PDMFieldType.INT32, true);
  fldInfo102 = defn.addFieldInfo(102, PDMFieldType.FLOAT, true);

  //Finalize the definition and create the message
  defn.finalizeDef();
  msg = new PDMMessage(defn);
}

public void receiverUsePDM(byte[] buffer) {
  //Call the function to setup the definition and message
  setupPDM();

  //Values to be retrieved from the message
  boolean fld100Val;
  int fld101Val;
  float fld102Val;

  //Deserialize the bytes into a message
  msg.parse(buffer);

  //Get each field value from the message
  fld100Val = msg.getFieldValueAsBoolean(fldInfo100);
  fld101Val = msg.getFieldValueAsInt32(fldInfo101);
  fld102Val = msg.getFieldValueAsFloat(fldInfo102);
}
</pre><p><b>PDM Code Example Notes</b></p>
<p>In the examples above, the setupPDM() function is called once to set up the PDM definition and message. It is identical in both the source and receiver cases and simply sets up a definition that contains three required fields with integer names (100, 101, 102). Once finalized, it can create a message that leverages its pre-defined knowledge about these three required fields. The source example adds the three sample field values (a boolean, int32, and float) to the message, which is then serialized to a byte array. In the receiver example, the message parses a byte array into the message and then extracts the three field values.</p>
<p><br />
 </p>
<h2><a class="anchor" id="usingthepdmapi"></a>
Using the PDM API</h2>
<p>The following code snippets expand upon the previous examples to demonstrate the usage of additional PDM functionality (but use "..." to eliminate redundant code).</p>
<p><b>Reusing the Message Object</b></p>
<p>Although the examples use a single message object (which provides performance benefits due to reduced message creation and garbage collection), it is not explicitly required to reuse a single instance. However, multiple threads should not access a single message instance.</p>
<p><b>Number of Fields</b></p>
<p>Although the number of fields above is initially set to 3 in the PDMDefinition constructor, if you add more fields to the definition with the addFieldInfo method, the definition grows to accommodate each field. Once the definition is finalized, you cannot add additional field information because the definition is now locked and ready for use in a message.</p>
<p><b>String Field Names</b></p>
<p>The examples above use integer field names in the setupPDM() function when creating the definition. You can also use string field names when setting up the definition. However, you still must use a FieldInfo object to set or get a field value from a message, regardless of field name type. Notice that false is passed to the PDMDefinition constructor to indicate string field names should be used. Also, the overloaded addFieldInfo function uses string field names (.Field100.) instead of the integer field names.</p>
<pre class="fragment">...
public void setupPDM() {
  //Create the definition with 3 fields and using string field names
  defn = new PDMDefinition(3, false);
  ...
  //Create information for a boolean, int32, and float field (all required)
  fldInfo100 = defn.addFieldInfo("Field100", PDMFieldType.BOOLEAN, true);
  fldInfo101 = defn.addFieldInfo("Field101", PDMFieldType.INT32, true);
  fldInfo102 = defn.addFieldInfo("Field102", PDMFieldType.FLOAT, true);
  ...
}
...
</pre><p><b>Retrieving FieldInfo from the Definition</b></p>
<p>At times, it may be easier to lookup the FieldInfo from the definition using the integer name (or string name if used). This eliminates the need to store the reference to the FieldInfo when getting or setting a field value in a message, but it does incur a performance penalty due to the lookup in the definition to retrieve the FieldInfo. Notice that there are no longer FieldInfo objects being used when calling addFieldInfo and a lookup is being done for each call to msg.getFieldValueAs* to retrieve the FieldInfo by integer name.</p>
<pre class="fragment">private PDMDefinition defn;
private PDMMessage msg;

public void setupPDM() {
  ...
  //Create information for a boolean, int32, and float field (all required)
  defn.addFieldInfo(100, PDMFieldType.BOOLEAN, true);
  defn.addFieldInfo(101, PDMFieldType.INT32, true);
  defn.addFieldInfo(102, PDMFieldType.FLOAT, true);
  ...
}

public void receiverUsePDM(byte[] buffer) {
  ...
  //Get each field value from the message
  fld100Val = msg.getFieldValueAsBoolean(defn.getFieldInfo(100));
  fld101Val = msg.getFieldValueAsInt32(defn.getFieldInfo(101));
  fld102Val = msg.getFieldValueAsFloat(defn.getFieldInfo(102));
}
</pre><p><b>Required and Optional Fields</b></p>
<p>When adding field information to a definition, you can indicate that the field is optional and may not be set for every message that uses the definition. Do this by passing false as the third parameter to the addFieldInfo function. Using required fields (fixed-required fields specifically) produces the best performance when serializing and deserializing messages, but causes an exception if all required fields are not set before serializing the message. Optional fields allow the concept of sending "null" as a value for a field by simply not setting that field value on the source side before serializing the message. However, after parsing a message, a receiver should check the isFieldValueSet function for an optional field before attempting to read the value from the field to avoid the exception mentioned above.</p>
<pre class="fragment">...
private PDMFieldInfo fldInfo103;
...
public void setupPDM() {
  ...
  //Create information for a boolean, int32, and float field (all required)
  // as well as an optional int8 field
  fldInfo100 = defn.addFieldInfo(100, PDMFieldType.BOOLEAN, true);
  fldInfo101 = defn.addFieldInfo(101, PDMFieldType.INT32, true);
  fldInfo102 = defn.addFieldInfo(102, PDMFieldType.FLOAT, true);
  fldInfo103 = defn.addFieldInfo(103, PDMFieldType.INT8, false);
  ...
}

public void sourceUsePDM() {
  ...
  //Set each field value in the message
  // except do not set the optional field
  msg.setFieldValue(fldInfo100, fld100Val);
  msg.setFieldValue(fldInfo101, fld101Val);
  msg.setFieldValue(fldInfo102, fld102Val);
  ...
}

...
private PDMFieldInfo fldInfo103;
...
public void setupPDM() {
  ...
  //Create information for a boolean, int32, and float field (all required)
  // as well as an optional int8 field
  fldInfo103 = defn.addFieldInfo(103, PDMFieldType.INT8, false);
  ...
}

public void receiverUsePDM(byte[] buffer) {
  ...
  byte fld103Val;
  ...
  if(msg.isFieldValueSet(fldInfo103)) {
    fld103Val = msg.getFieldValueAsInt8(fldInfo103);
  }
}
</pre><p><b>Fixed String and Fixed Unicode Field Types</b></p>
<p>A variable length string typically does not have the performance optimizations of fixed-required fields. However, by indicating "required", as well as the field type FIX_STRING or FIX_UNICODE and specifying an integer number of fixed characters, PDM sets aside an appropriate fixed amount of space in the message for that field and treats it as an optimized fixed-required field. Strings of a smaller length can still be set as the value for the field, but the message allocates the specified fixed number of bytes for the string. Specify Unicode strings in the same manner (with FIX_UNICODE as the type) and in "UTF-8" format.</p>
<pre class="fragment">...
private PDMFieldInfo fldInfo104;
...
public void setupPDM() {
  ...
  fldInfo104 = defn.addFieldInfo(104, PDMFieldType.FIX_STRING, 12, true);
  ...
}

public void sourceUsePDM() {
  ...
  String fld104Val = "Hello World!";

  //Set each field value in the message
  // except do not set the optional field
  msg.setFieldValue(fldInfo100, fld100Val);
  msg.setFieldValue(fldInfo101, fld101Val);
  msg.setFieldValue(fldInfo102, fld102Val);
  msg.setFieldValue(fldInfo104, fld104Val);
  ...
}

...
private PDMFieldInfo fldInfo104;
...
public void setupPDM() {
  ...
  fldInfo104 = defn.addFieldInfo(104, PDMFieldType.FIX_STRING, 12, true);
  ...
}
public void receiverUsePDM(byte[] buffer) {
  ...
  String fld104Val;
  ...

  fld104Val = msg.getFieldValueAsString(fldInfo104);
}
</pre><p><b>Variable Field Types</b></p>
<p>The field types of STRING, UNICODE, BLOB, and MESSAGE are all variable length field types. They do not require a length to be specified when adding field info to the definition. You can use a BLOB field to store an arbitrary binary objects (in Java as an array of bytes) and a MESSAGE field to store a PDMMessage object,</p>
<p>which enables "nesting" PDMMessages inside other PDMMessages. Creating and using a variable length string field is nearly identical to the previous fixed string example.</p>
<pre class="fragment">...
private PDMFieldInfo fldInfo105;
...
public void setupPDM() {
  ...
  fldInfo105 = defn.addFieldInfo(105, PDMFieldType.STRING, true);
  ...
}

public void sourceUsePDM() {
  ...
  String fld105Val = "variable length value";
  ...
  msg.setFieldValue(fldInfo105, fld105Val);
  ...
}

...
private PDMFieldInfo fldInfo105;
...
public void setupPDM() {
  ...
  fldInfo105 = defn.addFieldInfo(105, PDMFieldType.STRING, true);
  ...
}
public void receiverUsePDM(byte[] buffer) {
  ...
  String fld105Val;
  ...

  fld105Val = msg.getFieldValueAsString(fldInfo105);
}
</pre><p>Retrieve the BLOB field values with the getFieldValueAsBlob function, and the MESSAGE field values with the getFieldValueAsMessage function.</p>
<p><b>Array Field Types</b></p>
<p>For each of the scalar field types (fixed and variable length), a corresponding array field type uses the convention *_ARR for the type name (ex: BOOLEAN_ARR, INT32_ARR, STRING_ARR, etc.). This lets you set and get Java values such as an int[] or string[] directly into a single field. In addition, all of the array field types can specify a fixed number of elements for the size of the array when they are defined, or if not specified, behave as variable size arrays. Do this by passing an extra parameter to the addFieldInfo function of the definition.</p>
<p>To be treated as a fixed-required field, an array type field must be required as well as be specified as a fixed size array of fixed length elements. For instance, a required BOOLEAN_ARR field defined with a size of 3 would be treated as a fixed-required field. Also, a required FIX_STRING_ARR field defined with a size of 5 and fixed string length of 7 would be treated as a fixed-required field. However, neither a STRING_ARR field nor a BLOB_ARR field are treated as a fixed length field even if the size of the array is specified, since each element of the array can be variable in length. In the example below, field 106 and field 108 are both treated as fixed-required fields, but field 107 is not because it is a variable size array field type.</p>
<pre class="fragment">...
private PDMFieldInfo fldInfo106;
private PDMFieldInfo fldInfo107;
private PDMFieldInfo fldInfo108;
...

public void setupPDM() {
  ...
  //Create information for a boolean, int32, and float field (all required)
  // as well as an optional int8 field
  ...
  //A required, fixed size array of 3 boolean elements
  fldInfo106 = defn.addFieldInfo(106, PDMFieldType.BOOLEAN_ARR, true, 3);
  //An optional, variable size array of int32 elements
  fldInfo107 = defn.addFieldInfo(107, PDMFieldType.INT32_ARR, false);
  //A required, fixed size array of 2 element which are each 5 character strings
  fldInfo108 = defn.addFieldInfo(108, PDMFieldType.FIX_STRING_ARR, 5, true, 2);
  ...
}

public void sourceUsePDM() {
  ...
  //Example values for the message
  ...
  boolean fld106Val[] = {true, false, true};
  int fld107Val[] = {1, 2, 3, 4, 5};
  String fld108Val[] = {"aaaaa", "bbbbb"};

  //Set each field value in the message
  ...
  msg.setFieldValue(fldInfo106, fld106Val);
  msg.setFieldValue(fldInfo107, fld107Val);
  msg.setFieldValue(fldInfo108, fld108Val);
  ...
}

...
private PDMFieldInfo fldInfo106;
private PDMFieldInfo fldInfo107;
private PDMFieldInfo fldInfo108;
...
public void setupPDM() {
  ...
  //Create information for a boolean, int32, and float field (all required)
  // as well as an optional int8 field
  ...
  //A required, fixed size array of 3 boolean elements
  fldInfo106 = defn.addFieldInfo(106, PDMFieldType.BOOLEAN_ARR, true, 3);
  //An optional, variable size array of int32 elements
  fldInfo107 = defn.addFieldInfo(107, PDMFieldType.INT32_ARR, false);
  //A required, fixed size array of 2 element which are each 5 character strings
  fldInfo108 = defn.addFieldInfo(108, PDMFieldType.FIX_STRING_ARR, 5, true, 2);
  ...
}

public void receiverUsePDM(byte[] buffer) {
  ...
  //Values to be retrieved from the message
  ...
  boolean fld106Val[];
  int fld107Val[];
  String fld108Val[];

  //Deserialize the bytes into a message
  msg.parse(buffer);

  //Get each field value from the message
  ...
  fld106Val = msg.getFieldValueAsBooleanArray(fldInfo106);
  if(msg.isFieldValueSet(fldInfo107)) {
    fld107Val = msg.getFieldValueAsInt32Array(fldInfo107);
  }

  fld108Val = msg.getFieldValueAsStringArray(fldInfo108);
}
</pre><p><b>Definition Included In Message</b></p>
<p>Optionally, a PDM message can also include the definition when it is serialized to bytes. This enables receivers to parse a PDM message without having pre-defined knowledge of the message, although including the definition with the message affects message size and performance of message deserialization. Notice that the setIncludeDefinition function is called with an argument of true for a source that serializes the definition as part of the message.</p>
<pre class="fragment">private PDMDefinition defn;
private PDMMessage msg;

public void setupPDM() {
  //Create the definition with 3 fields and using int field names
  defn = new PDMDefinition(3, true);
  ...

  //Finalize the definition and create the message
  defn.finalizeDef();
  msg = new PDMMessage(defn);

  //Set the flag to indicate that the definition should also be serialized
  msg.setIncludeDefinition(true);
}
...
</pre><p>For a receiver, the setupPDM function does not need to set any flags for the message but rather should define a message without a definition, since we assume the source provides the definition. If a definition is set for a message, it will attempt to use that definition instead of the definition on the incoming message (unless the ids are different).</p>
<pre class="fragment">private PDMDefinition defn;
private PDMMessage msg;

public void setupPDM() {
  //Don't define a definition

  //Create a message without a definition since the incoming message will have it
  msg = new PDMMessage();
}
...
</pre><p><b>The PDM Field Iterator</b></p>
<p>You can use the PDM Field Iterator to check all defined message fields to see if set, or to extract their values. You can extract a field value as an Object using this method, but due to the casting involved, we recommend you use the type specific get method to extract the exact value. Notice the use of field.isValueSet to check to see if the field value is set and the type specific get methods such as getBooleanValue and getFloatValue.</p>
<pre class="fragment">...

public void setupPDM() {
  //Create the definition with 3 fields and using int field names
  defn = new PDMDefinition(3, true);

  //Set the definition id and version
  defn.setId(1001);
  defn.setMsgVersMajor((byte)1);
  defn.setMsgVersMinor((byte)0);

  //Create information for a boolean, int32, and float field (all required)
  // as well as an optional int8 field
  fldInfo100 = defn.addFieldInfo(100, PDMFieldType.BOOLEAN, true);
  fldInfo101 = defn.addFieldInfo(101, PDMFieldType.INT32, true);
  fldInfo102 = defn.addFieldInfo(102, PDMFieldType.FLOAT, true);
  fldInfo103 = defn.addFieldInfo(103, PDMFieldType.INT8, false);
  fldInfo104 = defn.addFieldInfo(104, PDMFieldType.FIX_STRING, 12, true);
  fldInfo105 = defn.addFieldInfo(105, PDMFieldType.STRING, true);
  //A required, fixed size array of 3 boolean elements
  fldInfo106 = defn.addFieldInfo(106, PDMFieldType.BOOLEAN_ARR, true, 3);
  //An optional, variable size array of int32 elements
  fldInfo107 = defn.addFieldInfo(107, PDMFieldType.INT32_ARR, false);
  //A required, fixed size array of 2 element which are each 5 character strings
  fldInfo108 = defn.addFieldInfo(108, PDMFieldType.FIX_STRING_ARR, 5, true, 2);

  //Finalize the definition and create the message
  defn.finalizeDef();
  msg = new PDMMessage(defn);
}

public void receiveAndIterateMessage(byte[] buffer) {
  msg.parse(buffer);
  PDMFieldIterator iterator = msg.createFieldIterator();
  PDMField field = null;
  while(iterator.hasNext()) {
    field = iterator.next();
    System.out.println("Field set? " +field.isValueSet());
    switch(field.getIntName()) {
      case 100:
        boolean val100 = field.getBooleanValue();
        System.out.println("Field 100's value is: " + val100);
        break;
      case 101:
        int val101 = field.getInt32Value();
        System.out.println("Field 101's value is: " + val101);
        break;
      case 102:
        float val102 = field.getFloatValue();
        System.out.println("Field 102's value is: " + val102);
        break;
      default:
        //Casting to object is possible but not recommended
        Object value = field.getValue();
        int name = field.getIntName();
        System.out.println("Field " + name + "'s value is: " + value);
        break;
    }
  }
}
</pre><p>Sample Output (106, 107, 108 are array objects as expected):</p>
<pre class="fragment">Field set? true
Field 100's value is: true
Field set? true
Field 101's value is: 7
Field set? true
Field 102's value is: 3.14
Field set? false
Field 103's value is: null
Field set? true
Field 104's value is: Hello World!
Field set? true
Field 105's value is: Variable
Field set? true
Field 106's value is: [Z@527736bd
Field set? true
Field 107's value is: [I@10aadc97
Field set? true
Field 108's value is: [Ljava.lang.String;@4178460d
</pre><p><b>Using the Definition Cache</b></p>
<p>The PDM Definition Cache assists with storing and looking up definitions by their id and version. In some scenarios, it may not be desirable to maintain the references to the message and the definition from a setup phase by the application. A source could optionally create the definition during the setup phase and store it in the definition cache. At a later point in time, it could retrieve the definition from the cache and use it to create the message without needing to maintain any references to the objects.</p>
<pre class="fragment">public void createAndStoreDefinition() {
  PDMDefinition myDefn = new PDMDefinition(3, true);
  //Set the definition id and version
  myDefn.setId(2001);
  myDefn.setMsgVersMajor((byte)1);
  myDefn.setMsgVersMinor((byte)0);

  //Create information for a boolean, int32, and float field (all required)
  myDefn.addFieldInfo(100, PDMFieldType.BOOLEAN, true);
  myDefn.addFieldInfo(101, PDMFieldType.INT32, true);
  myDefn.addFieldInfo(102, PDMFieldType.FLOAT, true);

  myDefn.finalizeDef();

  PDMDefinitionCache.getInstance().put(myDefn);
}

public void createMessageUsingCache() {
  PDMDefinition myFoundDefn = PDMDefinitionCache.getInstance().get(2001, 1, 0);
  if(myFoundDefn != null) {
    PDMMessage myMsg = new PDMMessage(myFoundDefn);
    //Get FieldInfo from defn and then set field values in myMsg
    //...
  }
}
</pre><p>A more advanced use of the PDM Definition Cache is by a receiver which may need to receive messages with different definitions and the definitions are not being included with the messages. The receiver can create the definitions in advance and then set a flag that allows automatic lookup into the definition cache when parsing a message (which is not on by default). Before receiving messages, the receiver should do something similar to createAndStoreDefinition (shown below) to set up definitions and put them in the definition cache. Then the flag to allow automatic lookup should be set as shown below in the call to setTryToLoadDefFromCache(true). This allows the PDMMessage to be created without a definition and still successfully parse a message by leveraging the definition cache.</p>
<pre class="fragment">public void createAndStoreDefinition() {
  PDMDefinition myDefn = new PDMDefinition(3, true);
  //Set the definition id and version
  myDefn.setId(2001);
  myDefn.setMsgVersMajor((byte)1);
  myDefn.setMsgVersMinor((byte)0);

  //Create information for a boolean, int32, and float field (all required)
  myDefn.addFieldInfo(100, PDMFieldType.BOOLEAN, true);
  myDefn.addFieldInfo(101, PDMFieldType.INT32, true);
  myDefn.addFieldInfo(102, PDMFieldType.FLOAT, true);

  myDefn.finalizeDef();
  PDMDefinitionCache.getInstance().put(myDefn);

  //Create and store other definitions
  //...
}

public void receiveKnownMessages(byte[] buffer) {
  PDMMessage myMsg = new PDMMessage();
  //Set the flag that enables messages to try
  // looking up the definition in the cache automatically
  // when parsing a byte buffer
  myMsg.setTryToLoadDefFromCache(true);
  myMsg.parse(buffer);

  if (myMsg.getDefinition().getId() == 2001
      &amp;&amp; myMsg.getDefinition().getMsgVersMajor() == 1
      &amp;&amp; myMsg.getDefinition().getMsgVersMinor() == 0) {
    PDMDefinition myDefn = PDMDefinitionCache.getInstance().get(2001, 1, 0);
    PDMFieldInfo fldInfo100 = myDefn.getFieldInfo(100);
    PDMFieldInfo fldInfo101 = myDefn.getFieldInfo(101);
    PDMFieldInfo fldInfo102 = myDefn.getFieldInfo(102);

    boolean fld100Val;
    int fld101Val;
    float fld102Val;

    //Get each field value from the message
    fld100Val = myMsg.getFieldValueAsBoolean(fldInfo100);
    fld101Val = myMsg.getFieldValueAsInt32(fldInfo101);
    fld102Val = myMsg.getFieldValueAsFloat(fldInfo102);

    System.out.println(fld100Val + " " + fld101Val + " " + fld102Val);
  }
}
</pre><p><br />
 </p>
<h2><a class="anchor" id="migratingfromsdm"></a>
Migrating from SDM</h2>
<p>Applications using SDM with a known set of message fields are good candidates for migrating from SDM to PDM. With SDM, the source typically adds fields to an SDM message without a definition. But, as shown above in the PDM examples, creating/adding a PDM definition before adding field values is fairly straightforward.</p>
<p>However, certain applications may be incapable of building a definition in advance due to the ad-hoc nature of their messaging needs, in which case a self-describing format like SDM may be preferred.</p>
<p><b>Simple Migration Example</b></p>
<p>The following source code shows a basic application that serializes and deserializes three fields using SDM and PDM. The setup method in both cases initializes the object instances so they can be reused by the source and receiver methods.</p>
<p>The goal of the sourceCreateMessageWith functions is to produce a byte array by setting field values in a message object. With SDM, actual Field classes are created, values are set, the Field classes are added to a</p>
<p>Fields class, and then the Fields class is added to the SDMessage. With PDM, FieldInfo objects are created during the setup phase and then used to set specific values in the PDMMessage.</p>
<p>The goal of the receiverParseMessageWith functions is to produce a message object by parsing the byte array and then extract the field values from the message. With SDM, the specific field is located and casted to the correct field class before getting the field value. With PDM, the appropriate getFieldValueAs function is called with the corresponding FieldInfo object created during the setup phase to extract the field value.</p>
<pre class="fragment">public class Migration {
  //SDM Variables
  private LBMSDMessage srcSDMMsg;
  private LBMSDMessage rcvSDMMsg;

  //PDM Variables
  private PDMDefinition defn;
  private PDMFieldInfo fldInfo100;
  private PDMFieldInfo fldInfo101;
  private PDMFieldInfo fldInfo102;
  private PDMMessage srcPDMMsg;
  private PDMMessage rcvPDMMsg;

  public static void main(String[] args) {
    Migration app = new Migration();
    System.out.println("Setting up PDM Definition and Message");
    app.setupPDM();
    System.out.println("Setting up SDM Messages");
    app.setupSDM();

    byte[] sdmBuffer;
    sdmBuffer = app.sourceCreateMessageWithSDM();
    app.receiverParseMessageWithSDM(sdmBuffer);

    byte[] pdmBuffer;
    pdmBuffer = app.sourceCreateMessageWithPDM();
    app.receiverParseMessageWithPDM(pdmBuffer);
  }

  public void setupSDM() {
    rcvSDMMsg = new LBMSDMessage();
    srcSDMMsg = new LBMSDMessage();
  }

  public void setupPDM() {
    //Create the definition with 3 fields and using int field names
    defn = new PDMDefinition(3, false);

    //Set the definition id and version
    defn.setId(1001);
    defn.setMsgVersMajor((byte)1);
    defn.setMsgVersMinor((byte)0);

    //Create information for a boolean, int32, and float field (all required)
    // as well as an optional int8 field
    fldInfo100 = defn.addFieldInfo("Field100", PDMFieldType.INT8, true);
    fldInfo101 = defn.addFieldInfo("Field101", PDMFieldType.INT16, true);
    fldInfo102 = defn.addFieldInfo("Field102", PDMFieldType.INT32, true);

    //Finalize the definition and create the message defn.finalizeDef();
    srcPDMMsg = new PDMMessage(defn);
    rcvPDMMsg = new PDMMessage(defn);
  }

  public byte[] sourceCreateMessageWithSDM() {
    byte[] buffer = null;

    LBMSDMField fld100 = new LBMSDMFieldInt8("Field100", (byte)0x42);
    LBMSDMField fld101 = new LBMSDMFieldInt16("Field101", (short)0x1ead);
    LBMSDMField fld102 = new LBMSDMFieldInt32("Field102", 12345);
    LBMSDMFields fset = new LBMSDMFields();

    try {
      fset.add(fld100);
      fset.add(fld101);
      fset.add(fld102);
    } catch (LBMSDMException e) {
      System.out.println ( e );
    }

    srcSDMMsg.set(fset);
    try {
      buffer = srcSDMMsg.data();
    } catch (IndexOutOfBoundsException e) {
      System.out.println ( "SDM Exception occurred during build of message:" );
      System.out.println ( e.toString() );
    } catch (LBMSDMException e) {
      System.out.println ( e.toString() );
    }
    return buffer;
  }

  public byte[] sourceCreateMessageWithPDM() {
    //Set each field value in the message
    srcPDMMsg.setFieldValue(fldInfo100, (byte)0x42);
    srcPDMMsg.setFieldValue(fldInfo101, (short)0x1ead);
    srcPDMMsg.setFieldValue(fldInfo102, 12345);

    //Serialize the message to bytes
    byte[] buffer = srcPDMMsg.toBytes();
    return buffer;
  }

  public void receiverParseMessageWithSDM(byte[] buffer) {
    //Values to be retrieved from the message byte fld100Val;
    short fld101Val;
    int fld102Val;

    //Deserialize the bytes into a message
    try {
      rcvSDMMsg.parse(buffer);
    } catch (LBMSDMException e) {
      System.out.println(e.toString());
    }

    LBMSDMField fld100 = rcvSDMMsg.locate("Field100");
    LBMSDMField fld101 = rcvSDMMsg.locate("Field101");
    LBMSDMField fld102 = rcvSDMMsg.locate("Field102");

    //Get each field value from the message
    fld100Val = ((LBMSDMFieldInt8)fld100).get();
    fld101Val = ((LBMSDMFieldInt16)fld101).get();
    fld102Val = ((LBMSDMFieldInt32)fld102).get();

    System.out.println("SDM Results: Field100=" + fld100Val +
                       ", Field101=" + fld101Val +
                       ", Field102=" + fld102Val);
  }

  public void receiverParseMessageWithPDM(byte[] buffer) {
    //Values to be retrieved from the message
    byte fld100Val;
    short fld101Val;
    int fld102Val;

    //Deserialize the bytes into a message
    rcvPDMMsg.parse(buffer);

    //Get each field value from the message
    fld100Val = rcvPDMMsg.getFieldValueAsInt8(fldInfo100);
    fld101Val = rcvPDMMsg.getFieldValueAsInt16(fldInfo101);
    fld102Val = rcvPDMMsg.getFieldValueAsInt32(fldInfo102);

    System.out.println("PDM Results: Field100=" + fld100Val +
                       ", Field101=" + fld101Val +
                       ", Field102=" + fld102Val);
  }
}
</pre><p>Notice that with sourceCreateMessageWithSDM function, the three fields (name and value) are created and added to the fset variable, which is then added to the SDM message. On the other hand, the sourceCreateMessageWithPDM function uses the FieldInfo object references to add the field values to the message for each of the three fields.</p>
<p>Also notice that the receiverParseMessageWithSDM requires a cast to the specific field class (like LBMSDMFieldInt8) once the field has been located. After the cast, calling the get method returns the expected value. On the other hand the receiverParseMessageWithPDM uses the FieldInfo object reference to directly retrieve the field value using the appropriate getFieldValueAs* method.</p>
<p><b>SDM Raw Classes</b></p>
<p>Several SDM classes with Raw in their name could be used as the value when creating an LBMSDMField. For example, an LBMSDMRawBlob instance could be created from a byte array and then that the LBMSDMRawBlob could be used as the value to a LBMSDMFieldBlob as shown in the following example.</p>
<pre class="fragment">byte[] blob = new byte[25];
LBMSDMRawBlob rawSDMBlob = new LBMSDMRawBlob(blob);
try {
  LBMSDMField fld103 = new LBMSDMFieldBlob("Field103",rawSDMBlob);
} catch (LBMSDMException e1) {
  System.out.println(e1);
}
</pre><p>The actual field named "Field103" is created in the try block using the rawSDMBlob variable which has been created to wrap the blob byte array. This field can be added to a LBMSDMFields object, which then uses it in a LBMSDMessage.</p>
<p>In PDM, there are no "Raw" classes that can be created. When setting the value for a field for a message, the appropriate variable type should be passed in as the value. For example, setting the field value for a BLOB field would mean simply passing the byte array directly in the setValue method as shown in the following code snippet since the field is defined as type BLOB.</p>
<pre class="fragment">private PDMFieldInfo fldInfo103;
public void setupPDM() {
  ...
  fldInfo103 = defn.addFieldInfo("Field103", PDMFieldType.BLOB, true);
  ...
  byte[] blob = new byte[25];

  srcPDMMsg.setFieldValue(fldInfo103, blob);
  ...
}
</pre><p>The PDM types of DECIMAL, TIMESTAMP, and MESSAGE expect a corresponding instance of PDMDecimal, PDMTimestamp, and PDMMessage as the field value when being set in the message so those types do require an instantiation instead of using a native Java type. For example, if "Field103" had been of type PDMFieldType.DECIMAL, the following code would be used to set the value.</p>
<pre class="fragment">PDMDecimal decimal = new PDMDecimal((long)2, (byte)32);
srcPDMMsg.setFieldValue(fldInfo103, decimal);
</pre><p><br />
 </p>
<h1><a class="anchor" id="sendingtosources"></a>
Sending to Sources</h1>
<p>There are many use cases where a subscriber application wants to send a message to a publisher application. For example, a client application which subscribes to market data may want to send a refresh request to the publishing feed handler. While this is possible to do with normal sources and receivers, UM supports a streamlined method of doing this.</p>
<p>As of UM version 6.10, a <a class="el" href="umobjects.html#sourcestring">Source String</a> can be used as a destination for sending a unicast immediate message. The UM library will establish a TCP connection to the publisher's context via its <em>request port</em>. The publishing application can receive this message either from a normal <a class="el" href="umobjects.html#receiverobject">Receiver Object</a>, or from a context immediate message callback via configuration options <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmulticastimmediatemessagingoperation.html#immediatemessagetopicreceiverfunctioncontext">immediate_message_topic_receiver_function (context)</a> or <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmulticastimmediatemessagingoperation.html#immediatemessagereceiverfunctioncontext">immediate_message_receiver_function (context)</a> (for topicless messages).</p>
<p><br />
 </p>
<h2><a class="anchor" id="sourcestringfromreceiveevent"></a>
Source String from Receive Event</h2>
<p>A receiving application's receiver callback function can obtain a source's source string from the message structure. However, that string is not suitable to being passed directly to the unicast immediate message send function.</p>
<p>Here's a code fragment in C for receiving a message from a source, and sending a message back to the originating source. For clarity, error detection and handling code is omitted.</p>
<pre class="fragment">int user_receiver_callback(lbm_rcv_t *rcv, lbm_msg_t *msg, void *clientd)
{
  ...
  switch (msg-&gt;type) {
    ...
  case LBM_MSG_DATA:
    /* user code which processes received message and sets up "msg_for_src" */
    ...
    /* A valid UIM destination is "SOURCE:" + source string. */
    char destination[LBM_MSG_MAX_SOURCE_LEN + 8];
    strcpy(destination, "SOURCE:");
    strcat(destination, msg-&gt;source);

    err = lbm_unicast_immediate_message(ctx, destination, NULL,   /* no topic */
                                       msg_for_src, sizeof(msg_for_src),
                                       LBM_SRC_NONBLOCK);  /* Called from context thread. */
    ...
  }  /* switch msg-&gt;type */
  ...
}  /* user_receiver_callback */
</pre><p>The <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aaa7a945411e63884f12918417e8d117c">lbm_msg_t</a> structure supplies the source string, and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a497d77b133cea1547c3346fcba99872a">lbm_unicast_immediate_message()</a> is used to send a topicless immediate message to the source's context. Alternatively, a request message could be sent with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ae011c7a66e1db1f012d7f9633dbd321d">lbm_unicast_immediate_request()</a>. If the receive events are delivered without an event queue, then <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ab8a470f02029480f179cc4872b7fa713">LBM_SRC_NONBLOCK</a> is needed.</p>
<p>The example above uses the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aa47eb604db7dc9fd53f9650ed940e058">LBM_MSG_DATA</a> message type. Most receiver event (message) types also contain a valid source string. Other likely candidates for this use case might be: <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ab5489080adc7157549a9930b30c68425">LBM_MSG_BOS</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a88920e0a4188081f9a14fc8f76c18578">LBM_MSG_UNRECOVERABLE_LOSS</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a6629139aaf902976c8df9de3f37d10db">LBM_MSG_UNRECOVERABLE_LOSS_BURST</a>.</p>
<p>Note that in this example, a topicless message is sent. This requires the publishing application to use the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmulticastimmediatemessagingoperation.html#immediatemessagereceiverfunctioncontext">immediate_message_receiver_function (context)</a> option to set up a callback for receipt of topicless immediate messages. Alternatively, a topic name can be supplied to the unicast immediate message function, in which case the publishing application would either create a normal <a class="el" href="umobjects.html#receiverobject">Receiver Object</a> for that topic, or would configure a callback with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmulticastimmediatemessagingoperation.html#immediatemessagetopicreceiverfunctioncontext">immediate_message_topic_receiver_function (context)</a>.</p>
<p>A Java program obtains the source string via <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMMessage.html#a5691adf8b8b740c7813d2f8d605c394d">com::latencybusters::lbm::LBMMessage::source</a>, and sends topicless unicast immediate messages via <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMContext.html#af565951d6e1b6b974c8ebd42bc0cfe16">com::latencybusters::lbm::LBMContext::sendTopicless</a>.</p>
<p>A .NET implementation is essentially the same as Java.</p>
<p><br />
 </p>
<h2><a class="anchor" id="sourcestringfromsourcenotificationfunction"></a>
Source String from Source Notification Function</h2>
<p>Some subscribing applications need to send a message to the publisher as soon as possible after the publisher is subscribed. Receiver events can sometimes take significant time to be delivered. The source string can be obtained via the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpdeliverycontrol.html#sourcenotificationfunctionreceiver">source_notification_function (receiver)</a> configuration option. This defines a callback function which is called at the start of the process of subscribing to a source.</p>
<p>Here's a code fragment in C for sending a message to a newly-discovered source. For clarity, error detection and handling code is omitted.</p>
<p>During initialization, when the receiver is defined, the callback must be configured using the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/structlbm__rcv__src__notification__func__t__stct.html">lbm_rcv_src_notification_func_t_stct</a> structure:</p>
<pre class="fragment">  lbm_rcv_src_notification_func_t src_notif_callback_info;
  src_notif_callback_info.create_func = src_notif_callback_create;  /* User function. */
  src_notif_callback_info.delete_func = src_notif_callback_delete;  /* User function. */
  src_notif_callback_info.clientd = NULL;   /* Can be user's receiver-specific state. */
  ...
  lbm_rcv_topic_attr_t *rcv_topic_attr;
  err = lbm_rcv_topic_attr_create(&amp;rcv_topic_attr);

  err = lbm_rcv_topic_attr_setopt(rcv_topic_attr, "source_notification_function",
                                 &amp;src_notif_callback_info, sizeof(src_notif_callback_info));

  lbm_topic_t *receiver_topic;
  err = lbm_rcv_topic_lookup(&amp;receiver_topic, ctx, receiver_topic_name, rcv_topic_attr);

  lbm_rcv_t *receiver;
  err = lbm_rcv_create(&amp;receiver, ctx, receiver_topic, ...);
</pre><p>This creates the <a class="el" href="umobjects.html#receiverobject">Receiver Object</a> with the source notification callback configured. Note that the source notification callback has both a create and a delete function, to facilitate state management by the user.</p>
<pre class="fragment">void * src_notif_callback_create(const char *source_name, void *clientd)
{
  /* This function is called when the subscription is being set up. */

  /* user code which sets up "msg_for_src" */
  ...
  /* A valid UIM destination is "SOURCE:" + source string. */
  char destination[LBM_MSG_MAX_SOURCE_LEN + 8];
  strcpy(destination, "SOURCE:");
  strcat(destination, source_name);

  err = lbm_unicast_immediate_message(ctx, destination, NULL,   /* no topic */
                                     msg_for_src, sizeof(msg_for_src),
                                     LBM_SRC_NONBLOCK);  /* Called from context thread. */
  ...
  return NULL;  /* Can be per-source state. */
}  /* src_notif_callback_create */


int src_notif_callback_delete(const char *source_name, void *clientd, void *source_clientd) {
  /* This function not used for anything in this example, but could be used to
   * to clean up per-source state. */
  return 0;
}  /* src_notif_callback_delete */
</pre><p>A Java program configures the source notification callback via <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMReceiverAttributes.html#ada8450c3e6c34d298256279418f026a4">com::latencybusters::lbm::LBMReceiverAttributes::setSourceNotificationCallbacks</a>.</p>
<p>A .NET implementation is essentially the same as Java.</p>
<p><br />
 </p>
<h2><a class="anchor" id="sendingtosourcereadiness"></a>
Sending to Source Readiness</h2>
<p>In most use cases for sending messages to a source, there is an implicit assumption that a subscribing receiver is fully set up and ready to receive messages from the publisher. However, due to the asynchronous nature of UM, there is no straight-forward way for a receiver to know the earliest point in time when messages sent by the source will be delivered to the receiver. For example, in a routed network (using the UM Router), a receiver might deliver BOS to the application, but that just means that the connection to the proper UM Router is complete. There could still be delays in the entire end-to-end path being able to deliver messages.</p>
<p>Also, be aware that although unicast immediate messages are delivered via TCP, these messages are not guaranteed. Especially in a routed network, there exists the possibility that a message will fail to reach the publisher.</p>
<p>In most cases, the immediate message is received by the publisher, and by the time the publisher reacts, the end-to-end source-to-receiver path is active. However, in the unlikely event that something goes wrong, a subscribing application should implement a timeout/retry mechanism. This advice is not specific to the "sending to source" use cases, and should be built into any kind of request/response-oriented use case.</p>
<p><br />
 </p>
<h1><a class="anchor" id="multicastimmediatemessaging"></a>
Multicast Immediate Messaging</h1>
<p>As an alternative to the normal, source-based UM messaging model, Multicast Immediate Messaging (MIM) offers advantages to short-lived topics and applications that cannot tolerate a delay between source creation and the sending of the first message. See the Knowledge Base article, Avoiding or Minimizing Delay Before Sending for background on this delay and other head-loss mitigation techniques.</p>
<p>Multicast Immediate Messaging avoids delay by eliminating the topic resolution process. MIM accomplishes this by:</p>
<ul>
<li>
Configuring transport information into sending and receiving applications. </li>
<li>
Including topic strings within each message. </li>
</ul>
<p>MIM is well-suited to applications where a small number of messages are sent to a topic. By eliminating topic resolution, MIM also reduces one of the causes of head-loss, defined as the loss of initial messages sent over a new transport session. Messages sent before topic resolution is complete will be lost.</p>
<p>MIM is typically not used for normal Streaming data because messages are somewhat less efficiently handled than source-based messages. Inefficiencies derive from larger message sizes due to the inclusion of the topic name, and on the receiving side, the MIM delivery controller hashing of topic names to find receivers, which consumes some extra CPU. If you have a high-message-rate stream, you should use a source-based method and not MIM. If head-loss is a concern and delay before sending is not feasible, then consider using late join (although this replaces head-loss with some head latency).</p>
<p>Note: Multicast Immediate Messaging can benefit from hardware acceleration. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportacceleration.html">Transport Acceleration Options</a> for more information</p>
<dl class="section note"><dt>Note</dt><dd>With the UMQ product, you cannot use MIM with Queuing.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="temporarytransportsession"></a>
Temporary Transport Session</h2>
<p>MIM uses the same reliable multicast algorithms as LBT-RM. When a sending application sends a message with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a24e5bff3a70e571bb12024af67b47cbb">lbm_multicast_immediate_message()</a>, MIM creates a temporary transport session. Note that no topic-level source object is created.</p>
<p>MIM automatically deletes the temporary transport session after a period of inactivity defined by <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmulticastimmediatemessagingoperation.html#mimsrcdeletiontimeoutcontext">mim_src_deletion_timeout (context)</a> which defaults to 30 seconds. A subsequent send creates a new transport session. Due to the possibility of head-loss in the switch, it is recommended that sending applications use a long deletion timeout if they continue to use MIM after significant periods of inactivity.</p>
<p>MIM forces all topics across all sending applications to be concentrated onto a single multicast address to which ALL applications listen, even if they aren't interested in any of the topics. Thus, all topic filtering must happen in UM.</p>
<p>MIM can also be used to send an UM request message with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a54f3933e4dd154a9c7bb72598d0d9ef1">lbm_multicast_immediate_request()</a>. For example, an application can use MIM to request initialization information right when it starts up. MIM sends the response directly to the initializing application, avoiding the topic resolution delay inherent in the normal source-based <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ad4d06f66b8404684e191ca178e0cc09b">lbm_send_request()</a> function.</p>
<p><br />
 </p>
<h2><a class="anchor" id="mimnotifications"></a>
MIM Notifications</h2>
<p>MIM notifications differ in the following ways from normal UM source-based sending.</p>
<ul>
<li>
When a sending application's MIM transport session times out and is deleted, the receiving applications do not receive an EOS notification. </li>
<li>
Applications with a source notification callback are not informed of a MIM sender. Since source notification is basically a hook into the topic resolution system, this should not come as a surprise. </li>
<li>
MIM sending supports the non-blocking flag. However, it does not provide an LBM_SRC_EVENT_WAKEUP notification when the MIM session becomes writable again. </li>
<li>
MIM sends unrecoverable loss notifications to a context callback, not to a receiver callback. See <a class="el" href="umfeatures.html#losshandling">Loss Handling</a>. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="receivingimmediatemessages"></a>
Receiving Immediate Messages</h2>
<p>MIM does not require any special type of receiver. It uses the topic-based publish/subscribe model so an application must still create a receiver for a topic to receive MIM messages.</p>
<p>If needed, an application can send topic-less messages using MIM. A MIM sender passes in a NULL string instead of a topic name. The message goes out on the MIM multicast address and is received by all other receivers. A receiving application can use <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a374f135dddf7794130509f97b1e96cf8">lbm_context_rcv_immediate_msgs()</a> to set the callback procedure and delivery method for non-topic immediate messages.</p>
<p><br />
 </p>
<h2><a class="anchor" id="mimandwildcardreceivers"></a>
MIM and Wildcard Receivers</h2>
<p>When an application receives an immediate message, it's topic is hashed to see if there is at least one regular (non-wildcard) receiver object listening to the topic. If so, then MIM delivers the message data to the list of receivers.</p>
<p>However, if there are no regular receivers for that topic in the receive hash, MIM runs the message topic through all existing wildcard patterns and delivers matches to the appropriate wildcard receiver objects without creating sub-receivers. The next MIM message received for the same topic will again be run through all existing wildcard patterns. This can consume significant CPU resources since it is done on a per-message basis.</p>
<p><br />
 </p>
<h2><a class="anchor" id="losshandling"></a>
Loss Handling</h2>
<p>The receiving application can set up a context callback to be notified of MIM unrecoverable loss (<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a7129f39b95974676e0ca74d88f58c498">lbm_mim_unrecloss_function_cb()</a>). It is not possible to do this notification on a topic basis because the receiving UM has no way of knowing which topics were affected by the loss.</p>
<p><br />
 </p>
<h2><a class="anchor" id="mimconfiguration"></a>
MIM Configuration</h2>
<p>As of UM 3.1, MIM supports ordered delivery. As of UM 3.3.2, the MIM configuration option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmulticastimmediatemessagingoperation.html#mimordereddeliverycontext">mim_ordered_delivery (context)</a> defaults to ordered delivery.</p>
<p>See the <a href="../Config/index.html">UM Configuration Guide</a> for the descriptions of the MIM configuration options.</p>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmulticastimmediatemessagingnetwork.html">Multicast Immediate Messaging Network Options</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmulticastimmediatemessagingreliability.html">Multicast Immediate Messaging Reliability Options</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmulticastimmediatemessagingoperation.html">Multicast Immediate Messaging Operation Options</a> </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="mimexampleapplications"></a>
MIM Example Applications</h2>
<p>UM includes two example applications that illustrate MIM.</p>
<ul>
<li>
<p class="startli"><a href="../example/lbmimsg.c">lbmimsg.c</a> - application that sends immediate messages as fast as it can to a given topic (single source). See also the Java example, <a href="../java_example/lbmimsg.java">lbmimsg.java</a> and the .NET example, <a href="../dotnet_example/lbmimsg.cs">lbmimsg.cs</a>.</p>
<p class="endli"></p>
</li>
<li>
<a href="../example/lbmireq.c">lbmireq.c</a> - application that sends immediate requests to a given topic (single source) and waits for responses. </li>
</ul>
<p><b>lbmimsg.c</b></p>
<p>We can demonstrate the default operation of Immediate Messaging with lbmimsg and lbmrcv.</p>
<ol>
<li>
Run <b>lbmrcv -v topicName</b> </li>
<li>
Run <b>lbmimsg topicName</b> </li>
</ol>
<p>The lbmrcv output should resemble the following:</p>
<pre class="fragment">Immediate messaging target: TCP:10.29.1.78:14391
1     secs.  0     Kmsgs/sec.  0     Kbps
1     secs.  0     Kmsgs/sec.  0     Kbps
1     secs.  0     Kmsgs/sec.  0     Kbps
[topicName][LBTRM:10.29.1.78:14390:644c8862:224.10.10.21:14401][0], 25 bytes
[topicName][LBTRM:10.29.1.78:14390:644c8862:224.10.10.21:14401][1], 25 bytes
[topicName][LBTRM:10.29.1.78:14390:644c8862:224.10.10.21:14401][2], 25 bytes
[topicName][LBTRM:10.29.1.78:14390:644c8862:224.10.10.21:14401][3], 25 bytes
[topicName][LBTRM:10.29.1.78:14390:644c8862:224.10.10.21:14401][4], 25 bytes
[topicName][LBTRM:10.29.1.78:14390:644c8862:224.10.10.21:14401][5], 25 bytes
[topicName][LBTRM:10.29.1.78:14390:644c8862:224.10.10.21:14401][6], 25 bytes
</pre><p>Each line in the lbmrcv output is a message received, showing the topic name, transport type, receiver IP:Port, multicast address and message number.</p>
<p><b>lbmireq.c</b></p>
<p>Sending an UM request by MIM can be demonstrated with lbmireq and lbmrcv, which shows a single request being sent by lbmireq and received by lbmrcv. (lbmrcv sends no response.)</p>
<ol>
<li>
Run <b>lbmrcv -v topicName</b> </li>
<li>
Run <b>lbmireq topicName</b> </li>
</ol>
<p>The lbmrcv output should resemble the following:</p>
<pre class="fragment">$ lbmrcv -v topicName
Immediate messaging target: TCP:10.29.1.78:14391
1     secs.  0     Kmsgs/sec.  0     Kbps
1     secs.  0     Kmsgs/sec.  0     Kbps
1     secs.  0     Kmsgs/sec.  0     Kbps
[topicName][LBTRM:10.29.1.78:14390:92100885:224.10.10.21:14401][0],   Request
1     secs.  0     Kmsgs/sec.  0     Kbps
1     secs.  0     Kmsgs/sec.  0     Kbps
1     secs.  0     Kmsgs/sec.  0     Kbps
1     secs.  0     Kmsgs/sec.  0     Kbps
1     secs.  0     Kmsgs/sec.  0     Kbps
1     secs.  0     Kmsgs/sec.  0     Kbps
</pre><p>The lbmireq output should resemble the following:</p>
<pre class="fragment">$ lbmireq topicName
Using TCP port 4392 for responses
Sending 1 requests of size 25 bytes to target &lt;&gt; topic &lt;topicName&gt;
Sending request 0
Sent request 0. Pausing 5 seconds.
Done waiting for responses. 0 responses (0 bytes) received. Deleting request
Quitting...
Lingering for 5 seconds...
</pre><p><br />
 </p>
<h1><a class="anchor" id="spectrum"></a>
Spectrum</h1>
<p>UM Spectrum, which refers to a "spectrum of channels", allows the application designer to sub-divide a topic into any number of channels, which can be individually subscribed to by a receiving application. This provides an extra level of message filtering.</p>
<p>The sending application first allocates the desired number of source channel objects using <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a73298f53aa9c5572cd0b1e68a4ec435a">lbm_src_channel_create()</a>. Then it creates a topic source in the normal way. Finally, the application sends messages using <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a091b5806bf18d10ebd0d9117e0c70229">lbm_src_send_ex()</a>, specifying the source channel object in the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a21504de56612c7c6e4be655402b47a37">lbm_src_send_ex_info_t</a>'s channel_info field.</p>
<p>A receiving application first creates a topic receiver in the normal way. Then it subscribes to channels using <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aa8304114445d291e6f16472d733ab250">lbm_rcv_subscribe_channel()</a> or lbm_wrcv_subscribe_channel(). Since each channel requires a different receiver callback, the receiver application can achieve more granular filtering of messages. Moreover, messages are received in-order across channels since all messages are part of the same topic stream.</p>
<p>You can accomplish the same level of filtering with a topic space design that creates separate topics for each channel, however, UM cannot guarantee the delivery of messages from multiple sources/topics in any particular order. Not only can UM Spectrum deliver the messages over many channels in the order they were sent by the source, but it also reduces topic resolution traffic since UM advertises only topics, not channels.</p>
<dl class="section note"><dt>Note</dt><dd>With the UMQ product, you cannot use UM Spectrum with Queuing.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="spectrumperformanceadvantages"></a>
Spectrum Performance Advantages</h2>
<p>The use of separate callbacks for different channels improves filtering and also relieves the source application of the task of including filtering information in the message data.</p>
<p>Java and .NET performance also receives a boost because messages not of interest can be discarded before they transition to the Java or .NET level.</p>
<p><br />
 </p>
<h2><a class="anchor" id="spectrumconfigurationoptions"></a>
Spectrum Configuration Options</h2>
<p>Spectrum's default behavior delivers messages on any channels the receiver has subscribed to on the callbacks specified when subscribing, and all other messages on the receiver's default callback. This behavior can be changed with the following configuration options.</p>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpdeliverycontrol.html#nullchannelbehaviorreceiver">null_channel_behavior (receiver)</a> - behavior for messages delivered with no channel information. </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpdeliverycontrol.html#unrecognizedchannelbehaviorreceiver">unrecognized_channel_behavior (receiver)</a> - behavior for messages delivered with channel information but are on a channel for which the receiver has not registered interest. </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpdeliverycontrol.html#channelmaptableszreceiver">channel_map_tablesz (receiver)</a> - controls the size of the table used by a receiver to store channel subscriptions. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="smartsourcesandspectrum"></a>
Smart Sources and Spectrum</h2>
<p><a class="el" href="umfeatures.html#smartsources">Smart Sources</a> support Spectrum, but via different API functions. You need to tell UM that you intend to use spectrum at Smart Source creation time using the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpsmartsource.html#smartsrcenablespectrumchannelsource">smart_src_enable_spectrum_channel (source)</a> configuration option. This pre-allocates space in the message header for the spectrum channel.</p>
<p>With Smart Sources, there is no need to allocate a Spectrum source object with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a73298f53aa9c5572cd0b1e68a4ec435a">lbm_src_channel_create()</a>. Instead, you simply set the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a5aa5ef8cbf768dd5ad5bb8a709cf9d78">LBM_SSRC_SEND_EX_FLAG_CHANNEL</a> flag and the spectrum channel number in the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a33886eeac2e67170effea009d2dc3a35">lbm_ssrc_send_ex_info_t</a> passed to the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a2f50f56536778332e9f5712b06546425">lbm_ssrc_send_ex()</a> API function. For example:</p>
<pre class="fragment">  lbm_ssrc_send_ex_info_t ss_send_info;
  memset((char *)&amp;ss_send_info, 0, sizeof(ss_send_info));
  /* If this flag had been cleared previously, must set it. */
  ss_send_info.flags |= LBM_SSRC_SEND_EX_FLAG_CHANNEL;
  ss_send_info.channel = desired_channel_number;

  err = lbm_ssrc_send_ex(ss, msg_buff, msg_size, 0, &amp;ss_send_info);
</pre><p>When a Smart Source is created with Spectrum enabled, it is possible to send messages without a Spectrum channel, either by clearing the LBM_SSRC_SEND_EX_FLAG_CHANNEL flag in <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a33886eeac2e67170effea009d2dc3a35">lbm_ssrc_send_ex_info_t</a>, or by simply not supplying a <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a33886eeac2e67170effea009d2dc3a35">lbm_ssrc_send_ex_info_t</a> object by passing NULL for the <code>info</code> parameter. This suppresses all features enabled by that structure.</p>
<dl class="section note"><dt>Note</dt><dd>If using both Spectrum and <a class="el" href="umfeatures.html#messageproperties">Message Properties</a> with a single Smart Source, there is an added restriction: it is not possible to send a message omitting only one of those features. I.e. if both are enabled when the Smart Source is created, it is not possible to send a message with a message property and not a channel, and it is not possible to send a message with a channel and not a property. This is because the message header is defined at Smart Source creation, and the header either must contain both or neither.</dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="hotfailoverhf"></a>
Hot Failover (HF)</h1>
<p>UM Hot Failover (HF) lets you implement sender redundancy in your applications. You can create multiple HF senders in different UM contexts, or, for even greater resiliency, on separate machines. There is no hard limit to the number of HF sources, and different HF sources can use different transport types.</p>
<dl class="section note"><dt>Note</dt><dd>With the UMQ product, you cannot use Hot Failover with Queuing.</dd></dl>
<p>Hot Failover receivers filter out the duplicate messages and deliver one message to your application. Thus, sources can drop a few messages or even fail completely without causing message loss, as long as the HF receiver receives each message from at least one source.</p>
<p>The following diagram displays Hot Failover operation.</p>
<div class="image">
<img src="Hot_Failover.png" alt="Hot_Failover.png"/>
</div>
 <p>In the figure above, HF sources send copies of Message X. An HF receiver delivers the first copy of Message X it receives to the application, and discards subsequent copies coming from the other sources.</p>
<p><br />
 </p>
<h2><a class="anchor" id="implementinghotfailoversources"></a>
Implementing Hot Failover Sources</h2>
<p>You create Hot Failover sources with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ab5f6226d21dd4294bbad7d9f3e7c0bf6">lbm_hf_src_create()</a>. This returns a source object with internal state information that lets it send HF messages. You delete HF sources with the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a29d45db8f76835b4ae78f4568c25712f">lbm_src_delete()</a> function.</p>
<p>HF sources send HF messages via <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ac515c1425d9b3f04f1e2cea5d66d3005">lbm_hf_src_send_ex()</a> or <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#acb6f42a8811cb998b4b19748b190f39b">lbm_hf_src_sendv_ex()</a>. These functions take a sequence number, supplied via the exinfo object, that HF receivers use to identify the same message sent from different HF sources. The exinfo has an hf_sequence_number, with a flag (LBM_SRC_SEND_EX_FLAG_HF_32 or LBM_SRC_SEND_EX_FLAG_HF_64) that identifies whether it's a 32- or 64-bit number. Each HF source sends the same message content for a given sequence number, which must be coordinated by your application.</p>
<p>If the source needs to restart its sequence number to an earlier value (e.g. start of day; not needed for normal wraparound), delete and re-create the source and receiver objects. Without re-creating the objects, the receiver sees the smaller sequence number, assumes the data are duplicate, and discards it. In (and only in) cases where this cannot be done, use <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a9f7ed3785938fcfd4771965d6430c4f2">lbm_hf_src_send_rcv_reset()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Your application must synchronize calling <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ac515c1425d9b3f04f1e2cea5d66d3005">lbm_hf_src_send_ex()</a> or <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#acb6f42a8811cb998b4b19748b190f39b">lbm_hf_src_sendv_ex()</a> with all threads sending on the same source. (One symptom of not doing so is messages appearing at the receiver as inside intentional gaps and being erroneously discarded.)</dd></dl>
<p>Please be aware that non-HF receivers created for an HF topic receive multiple copies of each message. We recommend you establish local conventions regarding the use of HF sources, such as including "HF" in the topic name.</p>
<p>For an example source application, see <a href="../example/lbmhfsrc.c">lbmhfsrc.c</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="implementinghotfailoverreceivers"></a>
Implementing Hot Failover Receivers</h2>
<p>You create HF receivers with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ac208c246a6e856e24e1130060e1806c3">lbm_hf_rcv_create()</a>, and delete them using <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#abc68152bcf4d18ef1d31d8f6a15ac080">lbm_hf_rcv_delete()</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a755bd1ee0a12622098b618cef46d254f">lbm_hf_rcv_delete_ex()</a>.</p>
<p>Incoming messages have an hf_sequence_number field containing the sequence number, and a message flag (LBM_MSG_FLAG_HF_32 or LBM_MSG_FLAG_HF_64) noting the bit size.</p>
<dl class="section note"><dt>Note</dt><dd>Previous UM versions used sequence_number for HF message identification. This field holds a 32-bit value and is still set for backwards compatibility, but if the HF sequence numbers are 64-bit lengths, this non-HF sequence number is set to 0. Also, you can retrieve the original (non-HF) topic sequence number via lbm_msg_retrieve_original_sequence_number() or, in Java and .NET, via LBMMessage.osqn().</dd></dl>
<p>For the maximum time period to recover lost messages, the HF receiver uses the minimum of the LBT-RM and LBT-RU NAK generation intervals (<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmreliability.html#transportlbtrmnakgenerationintervalreceiver">transport_lbtrm_nak_generation_interval (receiver)</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrureliability.html#transportlbtrunakgenerationintervalreceiver">transport_lbtru_nak_generation_interval (receiver)</a>). Each transport protocol is configured as normal, but the lost message recovery timer is the minimum of the two settings.</p>
<p>Some lbm_msg_t objects coming from HF receivers may be flagged as having "passed through" the HF receiver. This means that the message has not been ordered with other HF messages. These messages have the LBM_MSG_FLAG_HF_PASS_THROUGH flag set. UM flags messages sent from HF sources using <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a91f4b9cb04fe1323ec56833211cc5cb7">lbm_src_send()</a> in this manner, as do all non-HF sources. Also, UM flags EOS, no source notification, and requests in this manner as well.</p>
<p>For an example receiver application, see <a href="../example/lbmhfrcv.c">lbmhfrcv.c</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="implementinghotfailoverwildcardreceivers"></a>
Implementing Hot Failover Wildcard Receivers</h2>
<p>To create an HF wildcard receiver, set option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grphotfailoveroperation.html#hfreceiverwildcardreceiver">hf_receiver (wildcard_receiver)</a> to 1, then create a wildcard receiver with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a5b5d52f6b87499213757b73b09bc8160">lbm_wildcard_rcv_create()</a>. This actually creates individual HF receivers on a per-topic basis, so that each topic can have its own set of HF sequence numbers. Once the HF wildcard receiver detects that all sources for a particular topic are gone it closes the individual topic HF receivers and discards the HF sequence information (unlike a standard HF receiver). You can extend or control the delete timeout period of individual HF receivers with option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpwildcardreceiver.html#resolvernosourcelingertimeoutwildcardreceiver">resolver_no_source_linger_timeout (wildcard_receiver)</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="javaandnet"></a>
Java and .NET</h2>
<p>For information on implement the HF feature in a Java application, go to UM Java API and see the documentation for classes <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMHotFailoverReceiver.html">com::latencybusters::lbm::LBMHotFailoverReceiver</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMHotFailoverSource.html">com::latencybusters::lbm::LBMHotFailoverSource</a>.</p>
<p>For information on implement the HF feature in a .NET application, go to UM .NET API and navigate to Namespaces-&gt;<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBM.html">com.latencybusters.lbm</a>-&gt;LBMHotFailoverReceiver and LBMHotFailoverSource.</p>
<p><br />
 </p>
<h2><a class="anchor" id="usinghotfailoverwithpersistence"></a>
Using Hot Failover with Persistence</h2>
<p>When implementing Hot Failover with Persistence, you must consider the following impact on hardware resources:</p>
<ul>
<li>
Additional storage space required for a Persistent Store </li>
<li>
Higher disk activity </li>
<li>
Higher network activity </li>
<li>
Increased application complexity regarding message filtering </li>
</ul>
<p>Also note that you must enable UME explicit ACKs and Hot Failover duplicate delivery in each Hot Failover receiving application.</p>
<p>For detailed information on using Hot Failover with Persistence, see the Knowledge Base article <a href="https://kb.informatica.com/faq/5/Pages/80173.aspx">FAQ: Is UMP compatible with Hot Failover?</a></p>
<p><br />
 </p>
<h2><a class="anchor" id="hotfailoverintentionalgapsupport"></a>
Hot Failover Intentional Gap Support</h2>
<p>UM supports intentional gaps in HF message streams. Your HF sources can supply message sequence numbers with number gaps up to 1073741824. HF receivers automatically detect the gaps and consider any missing message sequence numbers as not sent and do not attempt recovery for these missing sequence numbers. See the following example.</p>
<ol>
<li>
HF source 1 sends message sequence numbers: 10, 11, 12, 13, 25, 26, 38 </li>
<li>
HF source 2 sends message sequence numbers: 10, 11, 12, 13, 25, 26, 38 </li>
</ol>
<p>HF receiver 1 receives message sequence numbers in order with no pause between any messages: 10, 11, 12, 13, 25, 26, 38</p>
<p><br />
 </p>
<h2><a class="anchor" id="hotfailoveroptionalmessages"></a>
Hot Failover Optional Messages</h2>
<p>Hot Failover sources can send optional messages that HF receivers can be configured to receive or not receive (<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grphotfailoveroperation.html#hfoptionalmessagesreceiver">hf_optional_messages (receiver)</a>). HF receivers detect an optional message by checking <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/structlbm__msg__t__stct.html#a9041a176f44dca95c3a5c6cc23d32d6c">lbm_msg_t.flags</a> for LBM_MSG_FLAG_HF_OPTIONAL. HF sources indicate an optional message by passing <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a5bf62d916b1acee97156dc8077ac3584">LBM_SRC_SEND_EX_FLAG_HF_OPTIONAL</a> in the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/structlbm__src__send__ex__info__t__stct.html#aa450a079510ebdc97b19625d10bd18ea">lbm_src_send_ex_info_t.flags</a> field to <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ac515c1425d9b3f04f1e2cea5d66d3005">lbm_hf_src_send_ex()</a> or <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#acb6f42a8811cb998b4b19748b190f39b">lbm_hf_src_sendv_ex()</a>. In the examples below, optional messages appear with an "o" after the sequence number.</p>
<ol>
<li>
HF source 1 sends message sequence numbers: 10, 11, 12, 13o, 14o, 15, 16o, 17o, 18o, 19o, 20 </li>
<li>
HF source 2 sends message sequence numbers: 10, 11, 12, 13o, 14o, 15, 16o, 17o, 18o, 19o, 20 </li>
</ol>
<p>HF receiver 1 receives: 10, 11, 12, 13o, 14o, 15, 16o, 17o, 18o, 19o, 20</p>
<p>HF receiver 2, configured to ignore optional messages, receives: 10, 11, 12, 15, 20</p>
<p><br />
 </p>
<h2><a class="anchor" id="usinghotfailoverwithordereddelivery"></a>
Using Hot Failover with Ordered Delivery</h2>
<p>An HF receiver takes some of its operating parameters directly from the receive topic attributes. The <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#ordereddeliveryreceiver">ordered_delivery (receiver)</a> setting indicates the ordering for the HF receiver.</p>
<dl class="section note"><dt>Note</dt><dd>UM supports Arrival Order with HF only when all sources use the same transport type.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="hotfailoveracrossmultiplecontexts"></a>
Hot Failover Across Multiple Contexts</h2>
<p>If you have a receiving application on a multi-homed machine receiving HF messages from HF sources, you can set up the Hot Failover Across Contexts (HFX) feature. This involves setting up a separate UM context to receive HF messages over each NIC and then creating an HFX Object, which drops duplicate HF messages arriving over all contexts. Your receiving application then receives only one copy of each HF message. The HFX feature achieves the same effect across multiple contexts as the normal Hot Failover feature does within a single context.</p>
<p>The following diagram displays Hot Failover operation across UM contexts.</p>
<div class="image">
<img src="Hot_Failover_X.png" alt="Hot_Failover_X.png"/>
</div>
 <p>For each context that receives HF messages, create one HFX Receiver per topic. Each HFX Receiver can be configured independently by passing in a UM Receiver attributes object during creation. A unique client data pointer can also be associated with each HFX Receiver. The HFX Object is a special Ultra Messaging object and does not live in any UM context.</p>
<p>Note: You never have to call lbm_topic_lookup() for a HFX Receiver. If you are creating HFX Receivers along with normal UM receivers for the same topic, do not interleave the calls. For example, call <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a82e9efbf70242d83ab287916ac497645">lbm_hfx_create()</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ae717b7b9923a6e4277ae9f7409983ffc">lbm_hfx_rcv_create()</a> for the topic. Then call lbm_topic_lookup() and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aa7491c50fefbc2b70f8035fce7ac1477">lbm_rcv_create()</a> for the topic to create the normal UM receivers.</p>
<p>The following outlines the general procedure for HFX.</p>
<ol>
<li>
Create an HFX Object for every HF topic of interest with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a82e9efbf70242d83ab287916ac497645">lbm_hfx_create()</a>, passing in an attributes object created with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a0e904e14d61eee45af197c17f7e3dc08">lbm_hfx_attr_create()</a> to specify any attributes desired. </li>
<li>
Create a context for the first NIC receiving HF messages with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a8058947690bd0995bc2c59d4a61b462f">lbm_context_create()</a>. </li>
<li>
Create a HFX Receiver for every HF topic with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ae717b7b9923a6e4277ae9f7409983ffc">lbm_hfx_rcv_create()</a>, passing in UM Receive Topic Attributes. </li>
<li>
Repeat steps 2 and 3 for all NICs receiving HF message </li>
<li>
Receive messages. The HFX Object identifies and drops all duplicates, delivering messages through a single callback (and optional event queue) specified when you created the HFX Object. </li>
</ol>
<p>Delete each HFX Receiver with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a096626db73533d6c39b22765014485b7">lbm_hfx_rcv_delete()</a> or <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a08d8cbd7f47af1d7b2199c85ecf7c44c">lbm_hfx_rcv_delete_ex()</a>. Delete the HFX Object with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#abc9924a0bd826db0c45a42d7199030b1">lbm_hfx_delete()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>When writing source-side HF applications for HFX, be aware that HFX receivers do not support hf_sequence, 64-bit sequence numbers, the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a9f7ed3785938fcfd4771965d6430c4f2">lbm_hf_src_send_rcv_reset()</a> function, or HF wildcard receivers. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/config.tag:../Config/" href="../Config/grphotfailoveroperation.html">Hot Failover Operation Options</a>, especially HFX-specific options.</dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="daemonstatistics"></a>
Daemon Statistics</h1>
<p>The Persistent Store daemon and the UM Router daemon each have a simple web server which provides operational information. This information is important for monitoring the operation and performance of these daemons. However, while the web-based presentation is convenient for manual, on-demand monitoring, it is not suitable for automated collection and recording of operational information for historical analysis.</p>
<p>Starting with UM version 6.11, a feature called "Daemon Statistics" has been added to the Store and Router daemons. This feature supports the background publishing of their operational information via UM messages. System designers can now subscribe to this information for their own automated monitoring systems.</p>
<p>While the information published by the Store and the Router daemons differ in their content, the general feature usage is the same between them. When the feature is configured, the daemon will periodically collect and publish its operational information.</p>
<p>The following sections give general information which is common across both daemons, followed by links to daemon-specific details.</p>
<p><br />
 </p>
<h2><a class="anchor" id="daemonstatisticsstructures"></a>
Daemon Statistics Structures</h2>
<p>The operational information is published as messages of different types sent over a normal UM topic source (topic name configurable). Each message is in the form of a binary, C-style data structure.</p>
<p>There are generally two categories of messages: <em>config</em> and <em>stat</em>. A given instance of a category config message does not have content which changes over time. An instance of a category stat message has content that does change over time. The daemon-specific documentation indicates which messages are in which category.</p>
<p>Each message type is configured for a publishing interval. However, config category messages are treated differently than stat. When the publishing interval for a given instance of a config message expires, the message is re-published unconditionally. These publishing intervals are typically set to long periods. However, when the publishing interval for a stat message expires, the message is checked to see if its content has materially changed since the last interval. If not, then the message is <em>not</em> republished. The publishing interval for a stat message is typically set to shorter periods to see those changes as they occur.</p>
<p>Finally, note that while the contents of a given instance of a config message does not change over time, new instances of the message type can be sent as a result of state changes in the store. For example, a new instance of <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/umedmonmsgs_8h.html#a3e3a1b935708cc8ac42cb70b0caf6808">umestore_repo_dmon_config_msg_t</a> is published each time a new source registers with the store.</p>
<p>More detailed information is available in the daemon-specific documentation referenced below.</p>
<p><br />
 </p>
<h2><a class="anchor" id="daemonstatisticsbinarydata"></a>
Daemon Statistics Binary Data</h2>
<p>The messages published are in binary form and map onto the C data structures defined for each message type.</p>
<p>The byte order of the structure fields is defined as the host endian architecture of the publishing daemon. Thus, if a monitoring host receiving the messages has the same endian architecture, the binary structures can be used directly. If the monitoring host has the opposite endian architecture, the receiver must byte-swap the fields.</p>
<p>The message structure is designed to make it possible for a monitoring application to detect a mismatch in endian architecture. Detection and byte swapping is demonstrated with daemon-specific example monitoring applications.</p>
<p>More detailed information is available in the daemon-specific documentation referenced below.</p>
<p><br />
 </p>
<h2><a class="anchor" id="daemonstatisticsversioning"></a>
Daemon Statistics Versioning</h2>
<p>Each message sent by the daemon consists of a standard header followed by a message-type-specific set of fields. The standard header contains a <code>version</code> field which identifies the version of the C include file used to build the daemon.</p>
<p>For example, the Store daemon is built with the include file <code><a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/umedmonmsgs_8h.html">umedmonmsgs.h</a></code>. With each daemon statistics message sent by the Store daemon, it sets the header version field to <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/umedmonmsgs_8h.html#af43ca32ea1917897c4ff1310d214c20b">LBM_UMESTORE_DMON_VERSION</a>. With each new release of the UM package, if that include file changes in a substantive way, the value of <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/api.tag:../API/" href="../API/umedmonmsgs_8h.html#af43ca32ea1917897c4ff1310d214c20b">LBM_UMESTORE_DMON_VERSION</a> is increased. In this way, a monitoring application can determine if it is receiving messages from a store daemon whose data structures match the monitoring application's structure definitions.</p>
<p>More detailed information is available in the daemon-specific documentation referenced below.</p>
<p><br />
 </p>
<h2><a class="anchor" id="daemonstatisticsrequests"></a>
Daemon Statistics Requests</h2>
<p>The daemon can optionally be configured to respond to requests to transmit information. The request might be sent by a monitoring application which has only just started running and needs a full snapshot of the operational information. The monitoring application sends a request to the daemon, and the daemon sends information messages in response. This is especially important for rarely-published message types, like those of the config category.</p>
<p>The request message is sent via standard UM <a class="el" href="fundamentalconcepts.html#requestresponse">Request/Response</a> messaging. The request message is formatted as an ASCII string, and is sent as a unicast immediate request message. The daemon reacts by parsing the request and sending a UM response with status information about the parse. If the request was parsed successfully, the daemon then publishes the requested daemon information in the normal way (over the configured topic). There are daemon-specific example applications which demonstrate the use of this request feature.</p>
<p>There is also an optional limited ability for the monitoring application to request modification of the configured settings for Daemon Statistics.</p>
<p>More detailed information is available in the daemon-specific documentation referenced below.</p>
<p><br />
 </p>
<h2><a class="anchor" id="daemonstatisticsdetails"></a>
Daemon Statistics Details</h2>
<p>For details on the Persistent Store's daemon statistics feature, see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/ume.tag:../UME/" href="../UME/storedaemonstatistics.html">Store Daemon Statistics</a>.</p>
<p>For details on the UM Router's daemon statistics feature, see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/Design/gateway.tag:../Gateway/" href="../Gateway/umrouterdaemonstatistics.html">UM Router Daemon Statistics</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
</body>
</html>
