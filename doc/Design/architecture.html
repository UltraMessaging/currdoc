<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Concepts Guide: Architecture</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen_manual.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Concepts Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('architecture.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Architecture </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>UM is designed to be a flexible architecture. Unlike many messaging systems, UM does not require an intermediate daemon to handle routing issues or protocol processing. This increases the performance of UM and returns valuable computation time and memory back to applications that would normally be consumed by messaging daemons.</p>
<p><br />
 </p>
<h1><a class="anchor" id="udpbasedtopicresolutiondetails"></a>
UDP-Based Topic Resolution Details&nbsp;&nbsp;<small><a href="#udpbasedtopicresolutiondetails">&lt;-</a></small></h1>
<p>The following diagram illustrates UDP-based Topic Resolution. The diagram references multicast configuration options, but the concepts apply equally to unicast.</p>
<div class="image">
<img src="TopicResolution.png" alt="TopicResolution.png"/>
</div>
 <p>By default, Ultra Messaging relies on UDP-based Topic Resolution. UDP-based TR uses <em>queries</em> (TQRs) and <em>advertisements</em> (TIRs) to resolve topics. These TQRs and TIRs are sent in UDP datagrams, typically with more than one TIR or TQR in a given datagram.</p>
<p>UDP-based topic resolution traffic can benefit from hardware acceleration. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grptransportacceleration.html">Transport Acceleration Options</a> for more information.</p>
<p>For Multicast UDP, TR datagrams are sent to an IP multicast group and UDP port configured with the Ultra Messaging configuration options <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpmulticastresolvernetwork.html#resolvermulticastaddresscontext">resolver_multicast_address (context)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpmulticastresolvernetwork.html#resolvermulticastportcontext">resolver_multicast_port (context)</a>).</p>
<p>For Unicast UDP, TR datagrams are sent to the IP address and port of the "lbmrd" daemon. See the UM configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpunicastresolvernetwork.html#resolverunicastdaemoncontext">resolver_unicast_daemon (context)</a>.</p>
<p>Note that if both Multicast and Unicast are configured, the Unicast has higher precedence, and Multicast will not be used.</p>
<p>UDP-based Topic Resolution occurs in the following phases:</p>
<ul>
<li>
Initial Phase - Period that allows you to resolve a topic aggressively. This phase can be configured to run differently from the defaults or completely disabled. </li>
<li>
Sustaining Phase - Period that allows new receivers to resolve a topic after the Initial Phase. Can also be the primary period of topic resolution if you disable the Initial Phase. This phase can also be configured to run differently from the defaults or completely disabled. </li>
<li>
Quiescent Phase - The quiet phase where Topic Resolution datagrams are no longer sent in an unsolicited way. This reduces the CPU and network resources consumed by TR, and also reduces latency outliers (<a class="el" href="umglossary.html#glossaryjitter">jitter</a>). However, in large deployments, especially those that include wide-area networks, the Quiescent Phase is sometimes disabled, by configuring the Sustaining Phase to continue forever. This is done to avoid <a class="el" href="umglossary.html#glossarydeafness">deafness</a> issues. </li>
</ul>
<p>The phases of topic resolution are specific to individual topics. A single context can have some topics in each of the three phases running concurrently.</p>
<p><br />
 </p>
<h2><a class="anchor" id="sourcesadvertise"></a>
Sources Advertise&nbsp;&nbsp;<small><a href="#sourcesadvertise">&lt;-</a></small></h2>
<p>For UDP-based TR, Sources use Topic Resolution in the following ways:</p>
<ul>
<li>
<p class="startli">Unsolicited advertisement of active sources. When a source is first created, it enters the Initial Phase of TR. During the Initial, and subsequent Sustaining phases, the source sends Topic Information Record datagrams (TIRs) to all the other contexts in the <a class="el" href="fundamentalconcepts.html#topicresolutiondomain">TRD</a>. The source does this in an unsolicited manner; it advertises even if there are no receivers for its topic.</p>
<p class="endli"></p>
</li>
<li>
Respond to Topic Queries. When a receiver is first created, it enters the Initial phase of TR. During the Initial, and subsequent Sustaining phases, the receiver sends Topic Query Records (TQRs) to all other contexts in the TRD. When a source receives a TQR for its topic, it will restart its Sustaining Phase of advertising to ensure that the receiver discovers the source. </li>
</ul>
<p>A TIR contains all the information that the receiver needs to join the topic's <a class="el" href="fundamentalconcepts.html#transportsessions">Transport Session</a>. The TIR datagram sent unsolicited is identical to the TIR sent in response to a TQR. Depending on the transport type, a TIR will contain one of the following groups of information:</p>
<ul>
<li>
For transporttcp, the source address, TCP port and Session ID. </li>
<li>
For <a class="el" href="transporttypes.html#transportlbtrm">Transport LBT-RM</a>, the source address, the multicast group address, the UDP destination port, LBT-RM Session ID, and the unicast UDP port to which NAKs are sent. </li>
<li>
For <a class="el" href="transporttypes.html#transportlbtru">Transport LBT-RU</a>, the source address, UDP port and Session ID. </li>
<li>
For <a class="el" href="transporttypes.html#transportlbtipc">Transport LBT-IPC</a>, the Host ID, LBT-IPC Session ID and Transport ID. </li>
<li>
For transportlbtsmx, the Host ID, LBT-SMX Session ID and Transport ID. </li>
</ul>
<p>See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html">UDP-Based Resolver Operation Options</a> for more information.</p>
<p><br />
 </p>
<h2><a class="anchor" id="receiversquery"></a>
Receivers Query&nbsp;&nbsp;<small><a href="#receiversquery">&lt;-</a></small></h2>
<p>For UDP-based TR, when an application creates a receiver within a context, the new receiver first checks the context's resolver cache for any matching sources that the context has already discovered. Those will be joined immediately.</p>
<p>In addition, the receiver normally initiates a process of sending Topic Query Records (TQRs). This triggers sources for the receiver's topic to advertise, if they are not already. This allows sources which are in their Quiescent Phase to be discovered by new receivers.</p>
<p>A TQR consists primarily of the topic string.</p>
<p><br />
 </p>
<h2><a class="anchor" id="wildcardreceivertopicresolution"></a>
Wildcard Receiver Topic Resolution&nbsp;&nbsp;<small><a href="#wildcardreceivertopicresolution">&lt;-</a></small></h2>
<p>For UDP-based TR, <a class="el" href="umobjects.html#umwildcardreceivers">UM Wildcard Receivers</a> use Topic Resolution in conceptually the same ways as a single-topic receiver, although some of the details are different. Instead of searching the resolver cache for a specific topic, a new wildcard receiver object searches for all sources that match the wildcard pattern.</p>
<p>Also, the TQRs contain the wildcard pattern, and all sources matching the pattern will advertise.</p>
<p>Finally, wildcard receivers omit the Sustaining Phase for sending Queries. They only support Initial and Quiescent Phases.</p>
<p>See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpwildcardreceiver.html">Wildcard Receiver Options</a> for more information.</p>
<p><br />
 </p>
<h2><a class="anchor" id="initialphase"></a>
Initial Phase&nbsp;&nbsp;<small><a href="#initialphase">&lt;-</a></small></h2>
<p>For UDP-based TR, the initial topic resolution phase for a topic is an aggressive phase that can be used to resolve all topics before sending any messages. During the initial phase, network traffic and CPU utilization might actually be higher. You can completely disable this phase, if desired. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/exampleconfigurationscenarios.html#disablingaspectsoftopicresolution">Disabling Aspects of Topic Resolution</a> for more information.</p>
<p><b>Advertising in the Initial Phase</b></p>
<p>For the initial phase default settings, the resolver issues the first advertisement as soon as the scheduler can process it. The resolver issues the second advertisement 10 ms later, or at the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolveradvertisementminimuminitialintervalsource">resolver_advertisement_minimum_initial_interval (source)</a>. For each subsequent advertisement, UM doubles the interval between advertisements. The source sends an advertisement at 20 ms, 40 ms, 80 ms, 160 ms, 320 ms and finally at 500 ms, or the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolveradvertisementmaximuminitialintervalsource">resolver_advertisement_maximum_initial_interval (source)</a>. These 8 advertisements require a total of 1130 ms. The interval between advertisements remains at the maximum 500 ms, resulting in 7 more advertisements before the total duration of the initial phase reaches 5000 ms, or the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolveradvertisementminimuminitialdurationsource">resolver_advertisement_minimum_initial_duration (source)</a>. This concludes the initial advertisement phase for the topic.</p>
<div class="image">
<img src="Resolver_Initial_Phase_TIR.png" alt="Resolver_Initial_Phase_TIR.png"/>
</div>
 <p>The initial phase for a topic can take longer than the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolveradvertisementminimuminitialdurationsource">resolver_advertisement_minimum_initial_duration (source)</a> if many topics are in resolution at the same time. The configuration options, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolverinitialadvertisementspersecondcontext">resolver_initial_advertisements_per_second (context)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolverinitialadvertisementbpscontext">resolver_initial_advertisement_bps (context)</a> enforce a rate limit on topic advertisements for the entire UM context. A large number of topics in resolution - in any phase - or long topic names may exceed these limits.</p>
<p>If a source advertising in the initial phase receives a topic query, it responds with a topic advertisement. UM recalculates the next advertisement interval from that point forward as if the advertisement was sent at the nearest interval.</p>
<p><b>Querying in the Initial Phase</b></p>
<p>Querying activity by receivers in the initial phase operates in similar fashion to advertising activity, although with different interval defaults. The <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolverqueryminimuminitialintervalreceiver">resolver_query_minimum_initial_interval (receiver)</a> default is 20 ms. Subsequent intervals double in length until the interval reaches 200 ms, or the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolverquerymaximuminitialintervalreceiver">resolver_query_maximum_initial_interval (receiver)</a>. The query interval remains at 200 ms until the initial querying phase reaches 5000 ms, or the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolverqueryminimuminitialdurationreceiver">resolver_query_minimum_initial_duration (receiver)</a>.</p>
<div class="image">
<img src="Resolver_Initial_Phase_TQR.png" alt="Resolver_Initial_Phase_TQR.png"/>
</div>
 <p>The initial query phase completes when it reaches the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolverqueryminimuminitialdurationreceiver">resolver_query_minimum_initial_duration (receiver)</a>. The initial query phase also has UM context-wide rate limit controls (<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolverinitialqueriespersecondcontext">resolver_initial_queries_per_second (context)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolverinitialquerybpscontext">resolver_initial_query_bps (context)</a>) that can result in the extension of a phase's duration in the case of a large number of topics or long topic names.</p>
<p><br />
 </p>
<h2><a class="anchor" id="sustainingphase"></a>
Sustaining Phase&nbsp;&nbsp;<small><a href="#sustainingphase">&lt;-</a></small></h2>
<p>For UDP-based TR, the sustaining topic resolution phase follows the initial phase and can be a less active phase in which a new receiver resolves its topic. It can also act as the sole topic resolution phase if you disable the initial phase. The sustaining phase defaults use less network resources than the initial phase and can also be modified or disabled completely. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/exampleconfigurationscenarios.html#disablingaspectsoftopicresolution">Disabling Aspects of Topic Resolution</a> for details.</p>
<p><b>Advertising in the Sustaining Phase</b></p>
<p>For the sustaining phase defaults, a source sends an advertisement every second (<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolveradvertisementsustainintervalsource">resolver_advertisement_sustain_interval (source)</a>) for 1 minute (<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolveradvertisementminimumsustaindurationsource">resolver_advertisement_minimum_sustain_duration (source)</a>). When this duration expires, the sustaining phase of advertisement for a topic ends. If a source receives a topic query, the sustaining phase resumes for the topic and the source completes another duration of advertisements.</p>
<div class="image">
<img src="Resolver_Sustain_Phase_TIR.png" alt="Resolver_Sustain_Phase_TIR.png"/>
</div>
 <p>The sustaining advertisement phase has UM context-wide rate limit controls (<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolversustainadvertisementspersecondcontext">resolver_sustain_advertisements_per_second (context)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolversustainadvertisementbpscontext">resolver_sustain_advertisement_bps (context)</a>) that can result in the extension of a phase's duration in the case of a large number of topics or long topic names.</p>
<p><b>Querying in the Sustaining Phase</b></p>
<p>Default sustaining phase querying operates the same as advertising. Unresolved receivers query every second (<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolverquerysustainintervalreceiver">resolver_query_sustain_interval (receiver)</a>) for 1 minute (<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolverqueryminimumsustaindurationreceiver">resolver_query_minimum_sustain_duration (receiver)</a>). When this duration expires, the sustaining phase of querying for a topic ends.</p>
<div class="image">
<img src="Resolver_Sustain_Phase_TQR.png" alt="Resolver_Sustain_Phase_TQR.png"/>
</div>
 <p>Sustaining phase queries stop when one of the following events occurs:</p>
<ul>
<li>
The receiver discovers multiple sources that equal <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolutionnumberofsourcesquerythresholdreceiver">resolution_number_of_sources_query_threshold (receiver)</a>. </li>
<li>
The sustaining query phase reaches the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolverqueryminimumsustaindurationreceiver">resolver_query_minimum_sustain_duration (receiver)</a>. </li>
</ul>
<p>The sustaining query phase also has UM context-wide rate limit controls (<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolversustainqueriespersecondcontext">resolver_sustain_queries_per_second (context)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolversustainquerybpscontext">resolver_sustain_query_bps (context)</a>) that can result in the extension of a phase's duration in the case of a large number of topics or long topic names.</p>
<p><br />
 </p>
<h2><a class="anchor" id="quiescentphase"></a>
Quiescent Phase&nbsp;&nbsp;<small><a href="#quiescentphase">&lt;-</a></small></h2>
<p>For UDP-based TR, this phase is the absence of topic resolution activity for a given topic. It is possible that some topics may be in the quiescent phase at the same time other topics are in initial or sustaining phases of topic resolution.</p>
<p>This phase ends if either of the following occurs.</p>
<ul>
<li>
A new receiver sends a query. </li>
<li>
Your application calls <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ae6dd7c56acf916ef66658cc1ebc7a525">lbm_context_topic_resolution_request()</a> that provokes the sending of topic queries for any receiver or wildcard receiver in this state. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="storecontextnameresolution"></a>
Store (context) Name Resolution&nbsp;&nbsp;<small><a href="#storecontextnameresolution">&lt;-</a></small></h2>
<p>For UDP-based TR, with the UMP/UMQ products, topic resolution facilitates the resolution of persistent Store names to a DomainID:IPAddress:Port.</p>
<p>Topic Resolution resolves Store (or context) names by sending context name queries and context name advertisements over the topic resolution channel. A Store name resolves to the Store's DomainID:IPAddress:Port. You configure the Store's name and IPAddress:Port in the Store's XML configuration file. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/ume.tag:../UME/" href="../UME/persistencearchitecture.html#identifyingpersistentstores">Identifying Persistent Stores</a> for more information.</p>
<p>If you do not use the <a class="el" href="fundamentalconcepts.html#umrouter">DRO</a>, the DomainID is zero. Otherwise, the DomainID represents the Topic Resolution Domain where the Store resides. Stores learn their DomainID by listening to Topic Resolution traffic.</p>
<p>Via the Topic Resolution channel, sources query for Store names and Stores respond with an advertisement when they see a query for their own Store name. The advertisement contains the Store's DomainID:IPAddress:Port.</p>
<p>For a new source configured to use Store names (<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umestorenamesource">ume_store_name (source)</a>), the resolver issues the first context name query as soon as the scheduler can process it. The resolver issues the second advertisement 100 ms later, or at the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolvercontextnamequeryminimumintervalcontext">resolver_context_name_query_minimum_interval (context)</a>. For each subsequent query, UM doubles the interval between queries. The source sends a query at 200 ms, 400 ms, 800 ms and finally at 1000 ms, or the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolvercontextnamequerymaximumintervalcontext">resolver_context_name_query_maximum_interval (context)</a>. The interval between queries remains at the maximum 1000 ms until the total time querying for a Store (context) name equals <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolvercontextnamequerydurationcontext">resolver_context_name_query_duration (context)</a>. The default for this duration is 0 (zero) which means the resolver continues to send queries until the name resolves. After a Store name resolves, the resolver stops sending queries.</p>
<p>If a source sees advertisements from multiple Stores with the same name, or a Store sees an advertisement that matches its own Store name, the source issues a warning log message. The source also issues an informational log message whenever it detects that a resolved Store (context) name changes to a different DomainID:IPAddress:Port.</p>
<p><br />
 </p>
<h2><a class="anchor" id="udptopicresolutionconfigurationoptions"></a>
UDP Topic Resolution Configuration Options&nbsp;&nbsp;<small><a href="#udptopicresolutionconfigurationoptions">&lt;-</a></small></h2>
<p>See the following sections in <a href="../../Config/index.html">UM Configuration Guide</a> for more information:</p>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html">UDP-Based Resolver Operation Options</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpmulticastresolvernetwork.html">Multicast Resolver Network Options</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpunicastresolvernetwork.html">Unicast Resolver Network Options</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpwildcardreceiver.html">Wildcard Receiver Options</a> </li>
</ul>
<p><b>Assigning Different Configuration Options to Individual Topics</b></p>
<p>You can set configuration options differently for individual topics, either by using <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/xmlconfigurationfiles.html">XML Configuration Files</a> (the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/xmlconfigurationfiles.html#umelementtopic">&lt;topic&gt;</a> element), or by using the API functions for setting configuration options programmatically (e.g. <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a1afc75f0fb3601d072b3463e7acf16a6">lbm_rcv_topic_attr_setopt()</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a96ea052dce2e6376684cbf2003407cbf">lbm_src_topic_attr_setopt()</a>).</p>
<p><br />
 </p>
<h2><a class="anchor" id="unicasttopicresolution"></a>
Unicast UDP Topic Resolution&nbsp;&nbsp;<small><a href="#unicasttopicresolution">&lt;-</a></small></h2>
<p>By default UM expects multicast connectivity between all sources and receivers. When only unicast connectivity is available, you may configure all sources and receivers to use unicast topic resolution. This requires that you run one or more instances of the UM unicast topic resolution daemon (lbmrd), which perform the same topic resolution activities as multicast topic resolution. You configure your applications to use the lbmrd daemons with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpunicastresolvernetwork.html#resolverunicastdaemoncontext">resolver_unicast_daemon (context)</a>.</p>
<p>See <a class="el" href="manpagesforlbmrd.html#lbmrdmanpage">Lbmrd Man Page</a> for details on running the lbmrd daemon.</p>
<p>The lbmrd can run on any machine, including the source or receiver. Of course, sources will also have to select a transport protocol that uses unicast addressing (e.g. TCP, TCP-LB, or LBT-RU). The lbmrd maintains a table of clients (address and port pairs) from which it has received a topic resolution message, which can be any of the following:</p>
<ul>
<li>
Topic Information Records (TIR) - also known as topic advertisements </li>
<li>
Topic Query Records (TQR) </li>
<li>
keepalive messages, which are only used in unicast topic resolution </li>
</ul>
<p>After lbmrd receives a TQR or TIR, it forwards it to all known clients. If a client (i.e. source or receiver) is not sending either TIRs or TQRs, it sends a keepalive message to lbmrd according to the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolverunicastkeepaliveintervalcontext">resolver_unicast_keepalive_interval (context)</a>. This registration with the lbmrd allows the client to receive advertisements or queries from lbmrd. lbmrd maintains no state about topics, only about clients.</p>
<p><b>LBMRD with the DRO Best Practice</b></p>
<p>If you're using the lbmrd for topic resolution across a <a class="el" href="fundamentalconcepts.html#umrouter">DRO</a>, you may want all of your domains discovered and all routes to be known before creating any topics. If so, change the UM configuration option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolverunicastforcealivecontext">resolver_unicast_force_alive (context)</a>, from the default setting to 1 so your contexts start sending keepalives to lbmrd immediately. This makes your startup process cleaner by allowing your contexts to discover the other Topic Resolution Domains and establish the best routes. The trade-off is a little more network traffic every 5 seconds.</p>
<p><b>Unicast Topic Resolution Resilience</b></p>
<p>Running multiple instances of lbmrd allows your applications to continue operation in the face of a lbmrd failure. Your applications' sources and receivers send topic resolution messages as usual, however, rather than sending every message to each lbmrd instance, UM directs messages to lbmrd instances in a round-robin fashion. Since the lbmrd does not maintain any resolver state, as long as one lbmrd instance is running, UM continues to forward LBMR packets to all connected clients. UM switches to the next active lbmrd instance every 250-750 ms.</p>
<p><br />
 </p>
<h2><a class="anchor" id="networkaddresstranslationnat"></a>
Network Address Translation (NAT)&nbsp;&nbsp;<small><a href="#networkaddresstranslationnat">&lt;-</a></small></h2>
<p>For UDP-based TR, if your network architecture includes LANs that are bridged with Network Address Translation (NAT), UM receivers will not be able to connect directly to UM sources across the NAT. Sources send Topic Resolution advertisements containing their local IP addresses and ports, but receivers on the other side of the NAT cannot access those sources using those local addresses/ports. They must use alternate addresses/ports, which the NAT forwards according to the NAT's configuration.</p>
<p>The recommended method of establishing UM connectivity across a NAT is to run a pair of DROs connected with a single TCP peer link. In this usage, the LANs on each side of the NAT are distinct Topic Resolution Domains.</p>
<p>Alternatively, if the NAT can be configured to allow two-way UDP traffic between the networks, the lbmrd can be configured to modify Topic Resolution advertisements according to a set of rules defined in an XML configuration file. Those rules allow a source's advertisements forwarded to local receivers to be sent as-is, while advertisements forwarded to remote receivers are modified with the IP addresses and ports that the NAT expects. In this usage, the LANs on each side of the NAT are combined into a single Topic Resolution domain.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="topicresolutiondescription.html#tcpbasedtopicresolutiondetails">TCP-based Topic Resolution</a> using the SRS does not support this form of NAT operation. If you want to mix SRS and lbmrd operation on the same network, <a href="https://ultramessaging.github.io/UM_Support.html">contact Informatica Support</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Using an lbmrd NAT configuration severely limits the UM features that can be used across the NAT. Normal source-to-receiver traffic is supported, but the following more-advanced UM features are not compatible with lbmrd NAT: <ul>
<li>
<a class="el" href="fundamentalconcepts.html#persistence">Persistence</a> </li>
<li>
<a class="el" href="fundamentalconcepts.html#queuing">Queuing</a> </li>
<li>
<a class="el" href="fundamentalconcepts.html#requestresponse">Request/Response</a> </li>
<li>
<a class="el" href="fundamentalconcepts.html#latejoin">Late Join</a> </li>
<li>
<a class="el" href="umfeatures.html#offtransportrecoveryotr">Off-Transport Recovery (OTR)</a> </li>
<li>
<a class="el" href="umfeatures.html#sendingtosources">Sending to Sources</a> </li>
<li>
<a class="el" href="umfeatures.html#unicastimmediatemessaging">Unicast Immediate Messaging</a> (UIM) </li>
</ul>
Late Join, sending to sources, and OTR can be made to work if applications are configured to use the default value (0.0.0.0) for <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpunicastimmediatemessagingnetwork.html#requesttcpinterfacecontext">request_tcp_interface (context)</a>. This means that you cannot use <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#defaultinterfacecontext">default_interface (context)</a>. Be aware that the <a class="el" href="fundamentalconcepts.html#umrouter">DRO</a> requires a valid interface be specified for <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpunicastimmediatemessagingnetwork.html#requesttcpinterfacecontext">request_tcp_interface (context)</a>. Thus, <b>lbmrd NAT support for Late Join, Request/Response, and OTR is not compatible with UM topologies that contain the DRO</b>.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="examplenatconfiguration"></a>
Example NAT Configuration&nbsp;&nbsp;<small><a href="#examplenatconfiguration">&lt;-</a></small></h2>
<p>In this example, there are two networks, A and B, that are interconnected via a NAT firewall. Network A has IP addresses in the 10.1.0.0/16 range, and B has IP addresses in the 192.168.1/24 range. The NAT is configured such that hosts in network B have no visibility into network A, and can send TCP and UDP packets to only a single host in A (10.1.1.50) via the NAT's external IP address 192.168.1.1, ports 12000 and 12001. I.e. packets sent from B to 192.168.1.1:12000 are forwarded to 10.1.1.50:12000, and packets from B to 192.168.1.1:12001 are forwarded to 10.1.1.50:12001. Hosts in network A have full visibility of network B and can send TCP and UDP packets to hosts in B by their local 192 addresses and ports. Those packets have their source addresses changed to 192.168.1.1.</p>
<p>Since hosts in network A have full visibility into network B, receivers in network A should be able to use source advertisements from network B without any changes. However, receivers in network B will not be able to use source advertisements from network A unless those advertisements' IP addresses are transformed.</p>
<p>The lbmrd is configured for NAT using its XML configuration file:</p>
<div class="fragment"><div class="line">&lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span> encoding=<span class="stringliteral">&quot;UTF-8&quot;</span> ?&gt;</div><div class="line">&lt;lbmrd version=<span class="stringliteral">&quot;1.0&quot;</span>&gt;</div><div class="line">  &lt;daemon&gt;</div><div class="line">    &lt;interface&gt;10.1.1.50&lt;/interface&gt;</div><div class="line">    &lt;port&gt;12000&lt;/port&gt;</div><div class="line">  &lt;/daemon&gt;</div><div class="line">  &lt;domains&gt;</div><div class="line">    &lt;domain name=<span class="stringliteral">&quot;Net-NYC&quot;</span>&gt;</div><div class="line">      &lt;network&gt;10.1.0.0/16&lt;/network&gt;</div><div class="line">    &lt;/domain&gt;</div><div class="line">    &lt;domain name=<span class="stringliteral">&quot;Net-NJC&quot;</span>&gt;</div><div class="line">      &lt;network&gt;192.168.1/24&lt;/network&gt;</div><div class="line">    &lt;/domain&gt;</div><div class="line">  &lt;/domains&gt;</div><div class="line">  &lt;transformations&gt;</div><div class="line">    &lt;transform source=<span class="stringliteral">&quot;Net-NYC&quot;</span> destination=<span class="stringliteral">&quot;Net-NJC&quot;</span>&gt;</div><div class="line">      &lt;rule&gt;</div><div class="line">        &lt;match address=<span class="stringliteral">&quot;10.1.1.50&quot;</span> port=<span class="stringliteral">&quot;*&quot;</span>/&gt;</div><div class="line">        &lt;replace address=<span class="stringliteral">&quot;192.168.1.1&quot;</span> port=<span class="stringliteral">&quot;*&quot;</span>/&gt;</div><div class="line">      &lt;/rule&gt;</div><div class="line">    &lt;/transform&gt;</div><div class="line">  &lt;/transformations&gt;</div><div class="line">&lt;/lbmrd&gt;</div></div><!-- fragment --><p>The lbmrd must be run on 10.1.1.50.</p>
<p>The application on 10.1.1.50 should be configured with:</p>
<pre class="fragment">context resolver_unicast_daemon 10.1.1.50:12000
source transport_tcp_port 12001
</pre><p>The applications in the 192 network should be configured with:</p>
<pre class="fragment">context resolver_unicast_daemon 192.168.1.1:12000
source transport_tcp_port 12100
</pre><p>With this, the application on 10.1.1.50 is able to create sources and receivers that communicate with applications in the 192 network.</p>
<p>See <a class="el" href="lbmrdconfigurationfile.html">lbmrd Configuration File</a> for full details of the XML configuration file.</p>
<p><br />
 </p>
<h1><a class="anchor" id="udpbasedtopicresolutionstrategies"></a>
UDP-Based Topic Resolution Strategies&nbsp;&nbsp;<small><a href="#udpbasedtopicresolutionstrategies">&lt;-</a></small></h1>
<p>Configuring UDP-based TR frequently involves a process of weighing the costs and benefits of different goals. The most common goals involved are:</p>
<ul>
<li>
<b>Avoid "deafness".</b> <a class="el" href="umglossary.html#glossarydeafness">deafness</a> is when there is a source and a receiver for a topic, but the receiver does not discover the source. This is usually a very high priority goal. </li>
<li>
<b>Minimize the delay before a transport session is joined.</b> This is especially important when a new source is created and the application wants to wait until all existing receivers have fully joined the transport session before sending messages. </li>
<li>
<b>Minimizing impact on the system.</b> Sending and receiving TR datagrams consumes CPU, network bandwidth, and can introduce latency outliers (<a class="el" href="umglossary.html#glossaryjitter">jitter</a>) on active data transports. </li>
<li>
<b>Maximizing scalability and flexibility.</b> Some deployments are tightly-coupled, carefully controlled, and well-defined. In those cases, scalability and flexibility might not be high-priority goals. Other deployments are loosely-coupled, and consist of many different application groups that do not necessarily coordinate their use of UM with each other. In those cases, scalability and flexibility can be important. </li>
<li>
<b>Fault tolerance.</b> Some environments, especially those that include Wide Area Networks, can have periodic degradation or loss of network connectivity. It is desired that after a given network problem is resolved, UM will quickly and automatically reestablish normal operation without <a class="el" href="umglossary.html#glossarydeafness">deafness</a>. </li>
</ul>
<p>The right TR strategy for a given deployment can depend heavily on the relative importance of these and other goals. It is impossible to give a "one size fits all" solution. Most users work with Informatica engineers to design a custom configuration.</p>
<p>Most users employ a variation on a few basic strategies. Note for the most part, these strategies do not depend on the specific UDP protocol (Multicast vs. Unicast). Normally Multicast is chosen, except where network or policy restrictions forbid it.</p>
<p><br />
 </p>
<h2><a class="anchor" id="defaulttr"></a>
Default TR&nbsp;&nbsp;<small><a href="#defaulttr">&lt;-</a></small></h2>
<p>The main characteristics of UM's default TR settings are: </p><ul>
<li>
Multicast UDP. </li>
<li>
Three phases enabled (Initial, Sustaining, Quiescent). Unsolicited TIRs and TQRs nominally last for 65 seconds, although that number can grow as the number of sources or receivers in a context increases. </li>
</ul>
<p>The default settings can be fine for reasonably small, static deployments, typically not including Wide Area Networks. (A "static" deployment is one where sources, and receivers are, for the most part, created during system startup, and deleted during system shutdown. Contrast with a "dynamic" system where applications come and go during normal operation, with sources and receivers being created and deleted at unpredictable times.)</p>
<p>Advantages: </p><ul>
<li>
Simplicity. </li>
<li>
In a network where sources and receivers are relatively static, the consumption of resources by TR stops reasonably quickly. </li>
</ul>
<p>Disadvantages: </p><ul>
<li>
As the numbers of contexts, sources, and receivers grow, the traffic load during the initial phase can be very intense, leading to packet loss and potential <a class="el" href="umglossary.html#glossarydeafness">deafness</a> issues. In these cases, the initial phase can be configured to be less aggressive, or disabled altogether. </li>
<li>
If a network outage lasts longer than 65 seconds, it is possible for new sources and receivers to be deaf to each other, due to entering their quiescent phases. In these cases, the sustaining phase can be configured for longer durations. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="querycentrictr"></a>
Query-Centric TR&nbsp;&nbsp;<small><a href="#querycentrictr">&lt;-</a></small></h2>
<p>The main characteristics of Query-centric TR are: </p><ul>
<li>
Unsolicited TIRs are severely limited or disabled. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/exampleconfigurationscenarios.html#disablingaspectsoftopicresolution">Disabling Aspects of Topic Resolution</a>. </li>
<li>
TQRs are extended, often to infinity. </li>
</ul>
<p>Query-centric TR can be useful for large-scale, dynamic systems, especially those that may have many sources for which there are no receivers during normal operation. For example, in some market data distribution architectures, many tens of thousands of sources are created, but a fairly small percentage of them have receivers at any given time. In that case, it is unnecessary to advertise sources on topics that have no receivers.</p>
<p>Note that this strategy does not prevent advertisements. Each TQR will trigger one or more sources to send a TIR in response.</p>
<p>Advantages: </p><ul>
<li>
For some deployments, can result in significantly reduced TR loading due to removal of TIRs for topics with no receivers. </li>
</ul>
<p>Disadvantages: </p><ul>
<li>
To avoid <a class="el" href="umglossary.html#glossarydeafness">deafness</a> issues, the Query sustaining phase is usually extended, often to infinity. This consumes CPU and Network bandwidth, and can introduce latency outliers (<a class="el" href="umglossary.html#glossaryjitter">jitter</a>). </li>
<li>
For topics that have receivers, both TQR and TIR traffic are present. (In contrast, a <a class="el" href="architecture.html#advertisecentrictr">Advertise-Centric TR</a> strategy removes the TQRs, but at the expense of advertising <em>all</em> sources, even those that have no receivers.) </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="knownquerythresholdtr"></a>
Known Query Threshold TR&nbsp;&nbsp;<small><a href="#knownquerythresholdtr">&lt;-</a></small></h2>
<p>In a special case of Query-centric TR, certain classes of topics have a specific number of sources. For example, in point-to-point use cases, a particular topic has exactly one source. As another example, some market data distribution architectures have two sources for each topic, a primary and a warm standby.</p>
<p>For those topics where it is known how many sources there should be, the configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolutionnumberofsourcesquerythresholdreceiver">resolution_number_of_sources_query_threshold (receiver)</a> can be combined with Query-centric TR to great benefit. Configure the receiver to query forever, and configure the query threshold to the number of expected sources. When the receiver discovers at least that many sources for the topic, it suppresses queries. Note that if a source exits and the receiver detects <a class="el" href="fundamentalconcepts.html#receiverbosandeosevents">EOS</a>, the number of known sources decreases. If the number drops below the threshold, queries resume.</p>
<p>For example, consider a market data system with a primary and warm standby source for each topic. Unsolicited advertisements are disabled (see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/exampleconfigurationscenarios.html#disablingaspectsoftopicresolution">Disabling Aspects of Topic Resolution</a>), and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolutionnumberofsourcesquerythresholdreceiver">resolution_number_of_sources_query_threshold (receiver)</a> is set to 2. The receiver will query until it has discovered two sources, at which point it will stop sending queries. If a source fails, the receiver resumes sending queries until it again has two sources.</p>
<p>The advantage here is that it is no longer necessary to extend the Sustaining phase forever to avoid deafness.</p>
<p>NOTE: wildcard receivers do not fit well with this model of TR. Wildcard receivers have their own query mechanism; see <a class="el" href="architecture.html#wildcardreceivertopicresolution">Wildcard Receiver Topic Resolution</a>. In particular, there is no wildcard equivalent to the number of sources query threshold. In a query-centric model, wildcard queries must be extended to avoid potential deafness issues. However, in most deployments, the number of wildcard receiver objects is small compared to the number of regular single-topic receivers, so using the Known Query Threshold TR model can still be beneficial.</p>
<p><br />
 </p>
<h2><a class="anchor" id="advertisecentrictr"></a>
Advertise-Centric TR&nbsp;&nbsp;<small><a href="#advertisecentrictr">&lt;-</a></small></h2>
<p>The main characteristics of Advertise-centric TR are: </p><ul>
<li>
Unsolicited TQRs are severely limited or disabled. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/exampleconfigurationscenarios.html#disablingaspectsoftopicresolution">Disabling Aspects of Topic Resolution</a>. </li>
<li>
TIRs are extended, often to infinity. </li>
</ul>
<p>Advertise-centric TR can be useful for large-scale, dynamic systems, especially those that may have very few sources for which there are no receivers. For example, most order management and routing systems use messaging in a point-to-point fashion, and every source should have a receiver. In that case, it is unnecessary to extend queries.</p>
<p>Advantages: </p><ul>
<li>
For some deployments, can result in moderate reduced TR loading due to reduction of TQRs. </li>
</ul>
<p>Disadvantages: </p><ul>
<li>
To avoid <a class="el" href="umglossary.html#glossarydeafness">deafness</a> issues, the Advertising sustaining phase is usually extended, often to infinity. This consumes CPU and Network bandwidth, and can introduce latency outliers (<a class="el" href="umglossary.html#glossaryjitter">jitter</a>). </li>
<li>
For topics that have no receivers, TIR traffic is present. (In contrast, a <a class="el" href="architecture.html#querycentrictr">Query-Centric TR</a> strategy removes the TIRs for topics that have no receivers, but at the expense of introducing both TQRs and TIRs.) </li>
<li>
In a deployment that includes the <a class="el" href="fundamentalconcepts.html#umrouter">DRO</a>, some number of TQRs are necessary to inform the Router that the context is interested in the topic. To avoid deafness issues, it is recommended to extend the Querying Sustaining Phase, although at a reduced rate. </li>
<li>
If the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpudpbasedresolveroperation.html#resolutionnosourcenotificationthresholdreceiver">resolution_no_source_notification_threshold (receiver)</a> feature is used, some number of TQRs are necessary. </li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="messagebatching"></a>
Message Batching&nbsp;&nbsp;<small><a href="#messagebatching">&lt;-</a></small></h1>
<p>This section is about source-side batching - publishers batching messages when sending. See also <a class="el" href="advancedoptimizations.html#receivesidebatching">Receive-Side Batching</a>.</p>
<p>Batching many small messages into fewer network packets decreases the per-message CPU load, thereby increasing throughput. Let's say it costs 2 microseconds of CPU to fully process a message. If you process 10 messages per second, you won't notice the load. If you process half a million messages per second, you saturate the CPU. So to achieve high message rates, you have to reduce the per-message CPU cost with some form of message batching. These per-message costs apply to both the sender and the receiver.</p>
<p>Many people are under the impression that while batching reduces CPU load, it increases message latency. There are circumstances where this can happen, but it is also true that careful use of batching can result in small latency increases or none at all. In fact, there are common circumstances where <a class="el" href="architecture.html#intelligentbatching">Intelligent Batching</a> will reduce average latency.</p>
<p>The most common forms of source-side batching employed with UM are: </p><ul>
<li>
<a class="el" href="architecture.html#implicitbatching">Implicit Batching</a> </li>
<li>
<a class="el" href="architecture.html#intelligentbatching">Intelligent Batching</a> </li>
<li>
<a class="el" href="architecture.html#applicationbatching">Application Batching</a> </li>
</ul>
<p>Note that implicit and intelligent batching are not supported for UMQ Brokered Queuing, <a class="el" href="advancedoptimizations.html#smartsources">Smart Sources</a>, or <a class="el" href="transporttypes.html#transportlbtsmx">Transport LBT-SMX</a>.</p>
<p>When using a kernel-bypass network driver (e.g. Solarflare's Onload), there are special considerations when batching. See <a class="el" href="architecture.html#datagrammaxsizeandnetworkmtu">Datagram Max Size and Network MTU</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="implicitbatching"></a>
Implicit Batching&nbsp;&nbsp;<small><a href="#implicitbatching">&lt;-</a></small></h2>
<p>With implicit batching, UM automatically batches smaller messages into <a class="el" href="fundamentalconcepts.html#transportsessions">Transport Session</a> datagrams. The implicit batching configuration options, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpimplicitbatching.html#implicitbatchingintervalsource">implicit_batching_interval (source)</a> (default = 200 milliseconds) and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpimplicitbatching.html#implicitbatchingminimumlengthsource">implicit_batching_minimum_length (source)</a> (default = 2048 bytes) govern UM implicit message batching. Although these are source options, they actually apply to the Transport Session to which the source was assigned.</p>
<p>See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpimplicitbatching.html">Implicit Batching Options</a>.</p>
<p>See also <a class="el" href="umobjects.html#sourceconfigurationandtransportsessions">Source Configuration and Transport Sessions</a>.</p>
<p>UM establishes the implicit batching parameters when it creates the Transport Session. Any sources assigned to that Transport Session use the implicit batching limits set for that Transport Session, and the limits apply to any and all sources subsequently assigned to that Transport Session. This means that batched transport datagrams can contain messages on multiple topics.</p>
<p><b>Implicit Batching Operation</b></p>
<p>Implicit Batching buffers messages until:</p>
<ul>
<li>
the buffer size exceeds the configured <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpimplicitbatching.html#implicitbatchingminimumlengthsource">implicit_batching_minimum_length (source)</a>, or </li>
<li>
the oldest message in the buffer has been in the buffer for <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpimplicitbatching.html#implicitbatchingintervalsource">implicit_batching_interval (source)</a> milliseconds, or </li>
<li>
adding another message would cause the buffer to exceed the configured <a class="el" href="architecture.html#datagrammaxsizes">Datagram Max Sizes</a> for the underlying transport type. </li>
</ul>
<p>When at least one condition is met, UM flushes the buffer, pushing the messages onto the network.</p>
<p>Note that the two size-related parameters operate somewhat differently. When the application sends a message, the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpimplicitbatching.html#implicitbatchingminimumlengthsource">implicit_batching_minimum_length (source)</a> option will trigger a flush <em>after</em> the message is sent. I.e. a sent datagram will typically be larger than the value specified by <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpimplicitbatching.html#implicitbatchingminimumlengthsource">implicit_batching_minimum_length (source)</a> (hence the use of the word "minimum"). In contrast, the transport_*_datagram_max_size option will trigger a flush <em>before</em> the message is sent. I.e. a sent datagram will never be larger than the transport_*_datagram_max_size option. If both size conditions apply, the <a class="el" href="architecture.html#datagrammaxsizes">Datagram Max Sizes</a> takes priority.</p>
<p>It may appear this design introduces significant latencies for low-rate topics. However, remember that Implicit Batching operates on a Transport Session basis. Typically many low-rate topics map to the same Transport Session, providing a high aggregate rate. The <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpimplicitbatching.html#implicitbatchingintervalsource">implicit_batching_interval (source)</a> option is a last resort to prevent messages from becoming stuck in the Implicit Batching buffer. If your UM deployment frequently uses the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpimplicitbatching.html#implicitbatchingintervalsource">implicit_batching_interval (source)</a> to push out the data (i.e. if the entire Transport Session has periods of inactivity longer than the value of <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpimplicitbatching.html#implicitbatchingintervalsource">implicit_batching_interval (source)</a> (defaults to 200 ms), then either the implicit batching options need to be fine-tuned (reducing one or both), or you should consider an alternate form of batching. See <a class="el" href="architecture.html#intelligentbatching">Intelligent Batching</a>.</p>
<p>The minimum value for the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpimplicitbatching.html#implicitbatchingintervalsource">implicit_batching_interval (source)</a> is 3 milliseconds. The actual minimum amount of time that data stays in the buffer depends on your Operating System and its scheduling clock interval. For example, on a Solaris 8 machine, the actual time is can be as much as 20 milliseconds. On older Microsoft Windows machines, the time can be as much as 16 milliseconds. On a Linux 2.6 kernel, the actual time is 3 milliseconds (+/- 1).</p>
<p><b>Implicit Batching Example</b></p>
<p>The following example demonstrates how the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpimplicitbatching.html#implicitbatchingminimumlengthsource">implicit_batching_minimum_length (source)</a> is actually a trigger or floor, for sending batched messages. It is sometimes misconstrued as a ceiling or upper limit.</p>
<pre class="fragment">source implicit_batching_minimum_length 2000
</pre><ol>
<li>
The first send by your application puts 1900 bytes into the batching buffer, which is below the minimum, so UM holds it. </li>
<li>
The second send fills the batching buffer to 3800 bytes, well over the minimum. UM sends it down to the transport layer, which builds a 3800-byte (plus overhead) datagram and sends it. </li>
<li>
The sender's Operating System performs <a class="el" href="umglossary.html#glossaryipfragmentation">IP fragmentation</a> on the datagram to produce packets, and the receiving Operating System reassembles the datagram. </li>
<li>
UM reads the datagram from the socket at the receiver. </li>
<li>
UM parses out the two messages and delivers them to the appropriate topic levels, which deliver the data. </li>
</ol>
<p>The proper setting of the implicit batching parameters often represents a trade-off between latency and efficiency, where efficiency affects the highest throughput attainable. In general, a large minimum length setting increases efficiency and allows a higher peak message rate, but at low message rates a large minimum length can increase latency. A small minimum length can lower latency at low message rates, but does not allow the message rate to reach the same peak levels due to inefficiency. An intelligent use of implicit batching and application-level flushing can be used to implement an adaptive form of batching known as <a class="el" href="architecture.html#intelligentbatching">Intelligent Batching</a> which can provide low latency and high throughput with a single setting.</p>
<p><br />
 </p>
<h2><a class="anchor" id="intelligentbatching"></a>
Intelligent Batching&nbsp;&nbsp;<small><a href="#intelligentbatching">&lt;-</a></small></h2>
<p>Intelligent Batching uses Implicit Batching along with your application's knowledge of the messages it must send. It is a form of dynamic adaptive batching that automatically adjusts for different message rates. Intelligent Batching can provide significant savings of CPU resources without adding any noticeable latency.</p>
<p>For example, your application might receive input events in a batch, and therefore know that it must produce a corresponding batch of output messages. Or the message producer works off of an input queue, and it can detect messages in the queue. In any case, if the application knows that it has more messages to send without going to sleep, it simply does normal sends to UM, letting Implicit Batching send only when the buffer meets the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpimplicitbatching.html#implicitbatchingminimumlengthsource">implicit_batching_minimum_length (source)</a> threshold.</p>
<p>However, when the application detects that it has no more messages to send after it sends the current message, it sets the FLUSH flag (LBM_MSG_FLUSH) when sending the message which instructs UM to flush the implicit batching buffer immediately by sending all messages to the transport layer. Refer to <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a91f4b9cb04fe1323ec56833211cc5cb7">lbm_src_send()</a> in the UM API documentation (UM C API, UM Java API, or UM .NET API) for all the available send flags.</p>
<p>When using Intelligent Batching, it is usually advisable to increase the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpimplicitbatching.html#implicitbatchingminimumlengthsource">implicit_batching_minimum_length (source)</a> option to 10 times the size of the average message, to a maximum value of 8196. This tends to strike a good balance between batching length and flushing frequency, giving you low latencies across a wide variation of message rates.</p>
<p><br />
 </p>
<h2><a class="anchor" id="applicationbatching"></a>
Application Batching&nbsp;&nbsp;<small><a href="#applicationbatching">&lt;-</a></small></h2>
<p>In all of the above situations, your application sends individual messages to UM and lets UM decide when to push the data onto the wire (often with application help). With application batching, your application buffers messages itself and sends a group of messages to UM with a single send. Thus, UM treats the send as a single message. On the receiving side, your application needs to know how to dissect the UM message into individual application messages.</p>
<p>This approach is most useful for Java or .NET applications where there is a higher per-message cost in delivering an UM message to the application. It can also be helpful when using an <a class="el" href="umobjects.html#eventqueueobject">event queue</a> to deliver received messages. This imposes a thread switch cost for each UM message. At low message rates, this extra overhead is not noticeable. However, at high message rates, application batching can significantly reduce CPU overhead.</p>
<p><br />
 </p>
<h2><a class="anchor" id="explicitbatching"></a>
Explicit Batching&nbsp;&nbsp;<small><a href="#explicitbatching">&lt;-</a></small></h2>
<dl class="section warning"><dt>Warning</dt><dd><b>The Explicit Batching feature is deprecated and may be removed in a future release</b>. Users are advised to use <a class="el" href="architecture.html#implicitbatching">Implicit Batching</a> or <a class="el" href="architecture.html#intelligentbatching">Intelligent Batching</a>.</dd></dl>
<p>UM allows you to group messages for a particular topic with explicit batching. The purpose of grouping messages with explicit batching is to allow the receiving application to detect the first and last messages of a group without needing to examine the message contents.</p>
<dl class="section note"><dt>Note</dt><dd>Explicit Batching does not guarantee that all the messages of a group will be sent in a single datagram.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Explicit Batching does not provide any kind of transactional guarantee. It is possible to receive some messages of a group while others are unrecoverably lost. If the first and/or last messages of a group are unrecoverably lost, then the receiving application will not have an indication of start and/or end of the group.</dd></dl>
<p>When your application sends a message (<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a91f4b9cb04fe1323ec56833211cc5cb7">lbm_src_send()</a>) it may flag the message as being the start of a batch (LBM_MSG_START_BATCH) or the end of a batch (LBM_MSG_END_BATCH). All messages sent between the start and end are grouped together. The flag used to indicate the end of a batch also signals UM to send the message immediately to the implicit batching buffer. At this point, <a class="el" href="architecture.html#implicitbatching">Implicit Batching</a> completes the batching operation. UM includes the start and end flags in the message so receivers can process the batched messages effectively.</p>
<p>Unlike Intelligent Batching which allows intermediate messages to trigger flushing according to the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpimplicitbatching.html#implicitbatchingminimumlengthsource">implicit_batching_minimum_length (source)</a> option, explicit batching holds all messages until the batch is completed. This feature is useful if you configure a relatively small <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpimplicitbatching.html#implicitbatchingminimumlengthsource">implicit_batching_minimum_length (source)</a> and your application has a batch of messages to send that exceeds the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpimplicitbatching.html#implicitbatchingminimumlengthsource">implicit_batching_minimum_length (source)</a>. By releasing all the messages at once, Implicit Batching maximizes the size of the network datagrams.</p>
<p><b>Explicit Batching Example</b></p>
<p>The following example demonstrates explicit batching.</p>
<pre class="fragment">source implicit_batching_minimum_length 8000
</pre><ol>
<li>
Your application performs 10 sends of 100 bytes each as a single explicit batch. </li>
<li>
At the 10th send (which completes the batch), UM delivers the 1000 bytes of messages to the implicit batch buffer. </li>
<li>
Let's assume that the buffer already has 7899 bytes of data in it from other topics on the same Transport Session </li>
<li>
UM adds the first 100-byte message to the buffer, bringing it to 7999. </li>
<li>
UM adds the second 100-byte message, bringing it up to 8099 bytes, which exceeds <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpimplicitbatching.html#implicitbatchingminimumlengthsource">implicit_batching_minimum_length (source)</a> but is below the 8192 <a class="el" href="architecture.html#datagrammaxsizes">Datagram Max Sizes</a>. </li>
<li>
UM sends the 8099 bytes (plus overhead) datagram. </li>
<li>
UM adds the third through tenth messages to the implicit batch buffer. These messages will be sent when either <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpimplicitbatching.html#implicitbatchingminimumlengthsource">implicit_batching_minimum_length (source)</a> is again exceeded, or the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpimplicitbatching.html#implicitbatchingintervalsource">implicit_batching_interval (source)</a> is met, or a message arrives in the buffer with the flush flag (LBM_MSG_FLUSH) set. </li>
</ol>
<p><br />
 </p>
<h2><a class="anchor" id="adaptivebatching"></a>
Adaptive Batching&nbsp;&nbsp;<small><a href="#adaptivebatching">&lt;-</a></small></h2>
<dl class="section warning"><dt>Warning</dt><dd><b>The Adaptive Batching feature is deprecated and may be removed in a future release</b>. Users are advised to use <a class="el" href="architecture.html#implicitbatching">Implicit Batching</a> or <a class="el" href="architecture.html#intelligentbatching">Intelligent Batching</a>.</dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="messagefragmentationandreassembly"></a>
Message Fragmentation and Reassembly&nbsp;&nbsp;<small><a href="#messagefragmentationandreassembly">&lt;-</a></small></h1>
<p>Message fragmentation is the process by which an arbitrarily large message is split into a series of smaller pieces or <em>fragments</em>. Reassembly is the process of putting the pieces back together into a single contiguous message. Ultra Messaging performs <a class="el" href="umglossary.html#glossaryumfragmentation">UM fragmentation</a> and reassembly on large user messages. When a user message is small enough, it fits into a single fragment.</p>
<p>Note that there is another layer of fragmentation and reassembly that happens in the TCP/IP network stack, usually by the host operating system. This <a class="el" href="umglossary.html#glossaryipfragmentation">IP fragmentation</a> of datagrams into packets happens when sending datagrams larger than the <a href="https://en.wikipedia.org/wiki/Maximum_transmission_unit">MTU</a> of the network medium, usually 1500 bytes. However, this fragmentation and reassembly happens transparently to and independently of Ultra Messaging. In the UM documentation, "fragmentation" generally refers to the higher-level <a class="el" href="umglossary.html#glossaryumfragmentation">UM fragmentation</a>.</p>
<p>Some users of UM have configured their network and systems for "jumbo frames", which provides an MTU of up to 9000 bytes. This can provide efficiency benefits, but is not practical for most users. This document assumes an MTU of 1500.</p>
<p>Another term that Ultra Messaging borrows from networking is "datagram". In the UM documentation, a <em>datagram</em> is a unit of data which is sent to the transport (network socket or shared memory). In the case of network-based transport types, this refers to a buffer which is sent to the network socket in a single system call.</p>
<p>(Be aware that for UDP-based transport types (LBT-RM and LBT-RU), the UM datagrams are in fact sent as UDP datagrams. For non-UDP-based transports, the use of the term "datagram" is retained for consistency.)</p>
<p>The mapping of message fragments to datagrams depends on three factors: </p><ol>
<li>
User message size, </li>
<li>
Configured <a class="el" href="architecture.html#datagrammaxsizes">Datagram Max Sizes</a> for the source's transport type, and </li>
<li>
Use of the <a class="el" href="architecture.html#implicitbatching">Implicit Batching</a> feature. </li>
</ol>
<p>When configured, the source implicit batching feature combines multiple small user messages into a single datagram no greater than the size of the transport type's configured <a class="el" href="architecture.html#datagrammaxsizes">Datagram Max Sizes</a>.</p>
<p>Large user messages can be split into N fragments, the first N-1 of which are approximately the size of the transport type's configured <a class="el" href="architecture.html#datagrammaxsizes">Datagram Max Sizes</a>, and the Nth fragment containing the left-over bytes.</p>
<p>A subscriber's receiver callback can get information about a message's fragments by calling <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#afa760960c21f502a8cb4c5ec5d97f91b">lbm_msg_retrieve_fragment_info()</a>.</p>
<p>A publisher can test an individual sent message to see if UM fragmented it via the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a350c2cab7f6f029276ebc323b7d73795">LBM_SRC_EVENT_SEQUENCE_NUMBER_INFO</a> source event, which is enabled by sending the message using the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a091b5806bf18d10ebd0d9117e0c70229">lbm_src_send_ex()</a> function and setting the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ab99586b3f3b469aa6f2e2da632fa5be0">LBM_SRC_SEND_EX_FLAG_SEQUENCE_NUMBER_INFO</a> flag or <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ae2b7b029ca6a3fcfc2cd67d809930a95">LBM_SRC_SEND_EX_FLAG_SEQUENCE_NUMBER_INFO_FRAGONLY</a> flag.</p>
<dl class="section note"><dt>Note</dt><dd>The SMX transport type does not support fragmentation.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="datagrammaxsizes"></a>
Datagram Max Sizes&nbsp;&nbsp;<small><a href="#datagrammaxsizes">&lt;-</a></small></h2>
<p>Each transport type has its own default maximum datagram size. For example, LBT-RM and LBT-RU have 8K as their default maximum datagram sizes, while TCP and IPC have 64K as their default maximums. These different defaults represent optimal values for the different transport types, and in a simple UM network, it is usually not necessary to change them.</p>
<p>The configuration options are: </p><ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grptransporttcpoperation.html#transporttcpdatagrammaxsizecontext">transport_tcp_datagram_max_size (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmoperation.html#transportlbtrmdatagrammaxsizecontext">transport_lbtrm_datagram_max_size (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtruoperation.html#transportlbtrudatagrammaxsizecontext">transport_lbtru_datagram_max_size (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtipcoperation.html#transportlbtipcdatagrammaxsizecontext">transport_lbtipc_datagram_max_size (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtsmxoperation.html#transportlbtsmxdatagrammaxsizesource">transport_lbtsmx_datagram_max_size (source)</a> - note this is a source-scoped option; the others are context-scoped. </li>
</ul>
<p>Note that the transport's datagram max size option limits the size of the UM <em>payload</em>, and does not include overhead specific to the underlying transport type. For example, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmoperation.html#transportlbtrmdatagrammaxsizecontext">transport_lbtrm_datagram_max_size (context)</a> does not include the UDP, IP, or packet overhead. The actual network frame can be larger than than the configured datagram max size.</p>
<dl class="section attention"><dt>Attention</dt><dd>When a DRO is being used in a UM network, it is usually advisable to override the different transports' datagram max sizes to make them all the same. This should be done for all applications and UM daemons, in all <a class="el" href="fundamentalconcepts.html#topicresolutiondomain">Topic Resolution Domains</a> (TRDs). See DRO <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/gateway.tag:../Gateway/" href="../Gateway/umrouterconcepts.html#protocolconversion">Protocol Conversion</a>.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="datagrammaxsizeandnetworkmtu"></a>
Datagram Max Size and Network MTU&nbsp;&nbsp;<small><a href="#datagrammaxsizeandnetworkmtu">&lt;-</a></small></h2>
<p>By default, when a UM source is building an outgoing message, it reserves space for the largest possible UM header. This fixed-size reservation is subtracted from the configured datagram max size to determine how much user data can be added to the datagram. Since most UM messages do not need a large UM header, there can be cases where a user message that <em>could</em> fit in a single datagram without exceeding the configured datagram limit will instead be split into two fragments, each carried in a datagram that is significantly below the configured datagram limit.</p>
<p>When UM is configured with a datagram max size of 8K or more, this space inefficiency does not pose a noticeable problem since the header reservation is a small percentage of the full 8K. However, for users who want to avoid <a class="el" href="umglossary.html#glossaryipfragmentation">IP fragmentation</a>, the datagrams should be limited to 1472 bytes. In this case, the space inefficiency becomes objectionable; packets will often not be as full as they should be.</p>
<p>For most networks, Informatica recommends setting the <a class="el" href="architecture.html#datagrammaxsizes">Datagram Max Sizes</a> to a minimum of 8K, and allowing the operating system to perform IP fragmentation. Some network engineers have learned that IP fragmentation can place a burden on network hardware (routers and switches), but this is true only if the network network hardware has to perform the fragmentation. For most modern networks, the entire fabric is designed to handle a common MTU, typically of 1500 bytes. Thus, a UDP datagram larger than 1500 bytes is fragmented once by the sending host's operating system, and the switches and routers only need to forward the already-fragmented packets. Switches and routers can forward fragmented packets without burden.</p>
<p>There are typically two circumstances where users should set UM's <a class="el" href="architecture.html#datagrammaxsizes">Datagram Max Sizes</a> to a smaller value: </p><ul>
<li>
If <a class="el" href="umglossary.html#glossarykernelbypass">kernel bypass</a> network drivers are being used which either don't handle IP fragments at all, or does handle them but only via the "slow path" (i.e. not accelerated). </li>
<li>
If the smallest MTU across a network path is smaller than the MTU of a host's network interface. For example, your hosts typically have an Ethernet connection with a 1500-byte MTU. But a WAN link might have a much smaller MTU. In that case, UM's <a class="el" href="architecture.html#datagrammaxsizes">Datagram Max Sizes</a> should be set to a value that keeps all packets within the WAN link's MTU. Note that in modern networks, it is rare to find links with an MTU below 1500. </li>
</ul>
<p>In both cases, the space inefficiency caused by reserving space for the largest possible UM header is objectionable.</p>
<p>The preferred solution is to use UM version 6.14 or beyond and enable the <a class="el" href="architecture.html#dynamicfragmentationreduction">Dynamic Fragmentation Reduction</a> feature.</p>
<p>For pre-6.14 UM, it can be possible to artificially increase the <a class="el" href="architecture.html#datagrammaxsizes">Datagram Max Sizes</a> to a value above the desired limit. See <a class="el" href="architecture.html#datagramsandkernelbypassnetworkdrivers">Setting Datagram Max Sizes High</a>.</p>
<dl class="section note"><dt>Note</dt><dd>UM version 6.12 changed the amount of space that Smart Sources reserve for the UM header. This can mean that pre-6.12 smart source users upgrading to 6.12 and beyond may need to change their configuration. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/changelog.tag:../ChangeLog/" href="../ChangeLog/umversion6_12.html#smartsourceheadersizechange">Smart Source Header Size Change</a>.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="datagramsandkernelbypassnetworkdrivers"></a>
Setting Datagram Max Sizes High&nbsp;&nbsp;<small><a href="#datagramsandkernelbypassnetworkdrivers">&lt;-</a></small></h2>
<p>There are cases when the <a class="el" href="architecture.html#datagrammaxsizes">Datagram Max Sizes</a> must be set to a relatively small value to prevent IP fragmentation. However, as described in <a class="el" href="architecture.html#datagrammaxsizeandnetworkmtu">Datagram Max Size and Network MTU</a>, this is space inefficient and can result in more UM fragmentation than is necessary.</p>
<p>Some users set their datagram max size to a value <em>above</em> the desired limit, knowing that LBT-RM and LBT-RU will reserve a large number of bytes for the largest possible UM header. This allows traffic to more-efficiently fill packets, and therefore avoid unnecessary UM fragmentation. However, this technique is imperfect.</p>
<p>Setting the datagram max size above the desired limit technically gives UM permission to send a datagram up to that size. I.e. you cannot always count on the largest possible header space being reserved. In practice with a restricted use case (e.g. flushing every message), LBT-RM data messages may never go above the desired limit. But <a class="el" href="umglossary.html#glossarytsni">TSNI</a> messages can reach the full datagram max size, and so can <a class="el" href="architecture.html#implicitbatching">implicitly batched messages</a>.</p>
<p>Also, keep in mind that UM does not publish the internal reserved size, and does not guarantee that the reserved size will stay the same. Users who use this technique must determine their optimal datagram max size <em>empirically</em> through extensive testing within the constraints of their use cases.</p>
<p>As of UM version 6.14, Informatica recommends that kernel bypass users make use of the <a class="el" href="architecture.html#dynamicfragmentationreduction">Dynamic Fragmentation Reduction</a> feature. This allows setting the datagram max size to 1472 to prevent IP fragmentation, while ensuring that data messages are not unnecessarily fragmented.</p>
<p><br />
 </p>
<h2><a class="anchor" id="dynamicfragmentationreduction"></a>
Dynamic Fragmentation Reduction&nbsp;&nbsp;<small><a href="#dynamicfragmentationreduction">&lt;-</a></small></h2>
<p>As described in <a class="el" href="architecture.html#datagrammaxsizeandnetworkmtu">Datagram Max Size and Network MTU</a>, UM versions prior to 6.14 reserved an unnecessarily large size in each datagram for a worst-case header, resulting in the LBT-RM and LBT-RU protocols performing UM fragmentation at message sizes where they should not have to. In an effort to more-fully fill data packets, some users set their <a class="el" href="architecture.html#datagrammaxsizes">Datagram Max Sizes</a> above an MTU, but this can result in IP fragmentation.</p>
<p>As of UM version 6.14, enabling <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#dynamicfragmentationreductioncontext">dynamic_fragmentation_reduction (context)</a> lets UM's transport protocols more-fully utilize the configured datagram max size, thus avoiding unnecessary UM and IP fragmentation. This option is typically only of interest to users of LBT-RM and/or LBT-RU who need to avoid IP fragmentation, such as users of a <a class="el" href="umglossary.html#glossarykernelbypass">kernel-bypass driver</a>.</p>
<p>This allows the user to set the desired transport's datagram max size option to 1472, which prevents IP fragmentation on the transport session, while still efficiently filling the packets to close to the MTU.</p>
<p><b>Enabling Dynamic Fragmentation Reduction</b></p>
<p>Users of kernel bypass drivers sometimes set their datagram max sizes well above 1472. This avoids inefficient filling of packets, but still carries the risk that some messages will trigger IP fragmentation.</p>
<p>To use the Dynamic Fragmentation Reduction feature: </p><pre class="fragment">context dynamic_fragmentation_reduction 1
context transport_lbtrm_datagram_max_size 1472
context transport_lbtru_datagram_max_size 1472
# Technically, only RM and RU matter. But when DROs are present, allow
# protocol conversion by making all transports the same.
context transport_tcp_datagram_max_size 1472
context transport_lbtipc_datagram_max_size 1472
source transport_lbtsmx_datagram_max_size 1472
</pre><p> DRO users see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/gateway.tag:../Gateway/" href="../Gateway/umrouterconcepts.html#protocolconversion">Protocol Conversion</a>.</p>
<p><b>Upgrade Path</b></p>
<p>The Dynamic Fragmentation Reduction feature is designed to allow a gradual upgrade. Older versions of UM can interoperate with 6.14 and beyond using Dynamic Fragmentation Reduction, but certain requirements must be met.</p>
<p>Users interested in Dynamic Fragmentation Reduction are typically users of kernel-bypass drivers who want to set their datagram max sizes to 1 MTU. For efficiency purposes, they've empirically determined an optimal value which is noticeably higher than a network MTU. A typical value might be between 1800 and 1900.</p>
<p>During the upgrade period, you will be running upgraded UM programs (version 6.14 or beyond) with Dynamic Fragmentation Reduction enabled, and datagram max sizes set to 1472. These will successfully interoperate with older UM versions running with datagram max sizes between 1800 and 1900.</p>
<p>The exception to this rule is the DRO. In a mixed-version environment, the DRO should always be configured with the largest datagram max size values used in your network. I.e. if an older version application is set to 1800, a DRO running 6.14 or beyond should also be configured for 1800.</p>
<p>See also <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/gateway.tag:../Gateway/" href="../Gateway/umrouterconcepts.html#protocolconversion">Protocol Conversion</a>.</p>
<p><br />
 </p>
<h1><a class="anchor" id="ordereddelivery"></a>
Ordered Delivery&nbsp;&nbsp;<small><a href="#ordereddelivery">&lt;-</a></small></h1>
<p>With the Ordered Delivery feature, a receiver's <a class="el" href="fundamentalconcepts.html#deliverycontroller">Delivery Controller</a> can deliver messages to your application in sequence number order or arrival order. This feature can also reassemble fragmented messages or leave reassembly to the application. You can set Ordered Delivery via UM configuration option to one of three modes:</p>
<ul>
<li>
Sequence Number Order, Fragments Reassembled </li>
<li>
Arrival Order, Fragments Reassembled </li>
<li>
Arrival Order, Fragments Not Reassembled (deprecated) </li>
</ul>
<p>See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#ordereddeliveryreceiver">ordered_delivery (receiver)</a></p>
<p>Note that these ordering modes only apply to a specific topic from a single publisher. UM does not ensure ordering across different topics, or on a single topic across different publishers. See <a class="el" href="fundamentalconcepts.html#messageordering">Message Ordering</a> for more information.</p>
<p><br />
 </p>
<h2><a class="anchor" id="sequencenumberorderfragmentsreassembleddefaultmode"></a>
Sequence Number Order, Fragments Reassembled (Default Mode)&nbsp;&nbsp;<small><a href="#sequencenumberorderfragmentsreassembleddefaultmode">&lt;-</a></small></h2>
<p>In this mode, a receiver's <a class="el" href="fundamentalconcepts.html#deliverycontroller">Delivery Controller</a> delivers messages in sequence number order (the same order in which they are sent). This feature also guarantees reassembly of fragmented large messages. To enable sequence number ordered delivery, set the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#ordereddeliveryreceiver">ordered_delivery (receiver)</a> configuration option as shown:</p>
<pre class="fragment">receiver ordered_delivery 1
</pre><p>Please note that ordered delivery can introduce latency when packets are lost (new messages are buffered waiting for retransmission of lost packets).</p>
<p><br />
 </p>
<h2><a class="anchor" id="arrivalorderfragmentsreassembled"></a>
Arrival Order, Fragments Reassembled&nbsp;&nbsp;<small><a href="#arrivalorderfragmentsreassembled">&lt;-</a></small></h2>
<p>This mode delivers messages immediately upon reception, in the order the datagrams are received, except for fragmented messages, which UM holds and reassembles before delivering to your application. Be aware that messages can be delivered out of order, either because of message loss and retransmission, or because the networking hardware re-orders UDP packets. Your application can then use the sequence_number field of <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/structlbm__msg__t__stct.html">lbm_msg_t</a> objects to order or discard messages. But be aware that the sequence number may not always increase by 1; application messages larger than the <a class="el" href="architecture.html#datagrammaxsizes">Datagram Max Sizes</a> will be split into fragments, and each fragment gets its own sequence number. With the "Arrival Order, Fragments Reassembled" mode of delivery, UM will reassemble the fragments into the original large application message and deliver it with a single call to the application receiver callback. But that message's sequence_number will reflect the final fragment.</p>
<p>To enable this arrival-order-with-reassembly mode, set the following configuration option as shown:</p>
<pre class="fragment">receiver ordered_delivery -1
</pre><p><br />
 </p>
<h2><a class="anchor" id="arrivalorderfragmentsnotreassembled"></a>
Arrival Order, Fragments Not Reassembled&nbsp;&nbsp;<small><a href="#arrivalorderfragmentsnotreassembled">&lt;-</a></small></h2>
<dl class="section warning"><dt>Warning</dt><dd>This mode of delivery is deprecated and may be removed in a future version. The user is advised to use mode -1.</dd></dl>
<p>This mode allows messages to be delivered to the application immediately upon reception, in the order the datagrams are received. If a message is lost, UM will retransmit the message. In the meantime, any subsequent messages received are delivered immediately to the application, followed by the dropped packet when its retransmission is received. This mode has the lowest latency.</p>
<p>With this mode, the receiver delivers messages larger than the transport's <a class="el" href="architecture.html#datagrammaxsizes">Datagram Max Sizes</a> as individual fragments. The C API function, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#afa760960c21f502a8cb4c5ec5d97f91b">lbm_msg_retrieve_fragment_info()</a> returns fragmentation information for the message you pass to it, and can be used to reassemble large messages. (In Java and .NET, LBMMessage provides methods to return the same fragment information.) Note that reassembly is not required for small messages.</p>
<p>To enable this no-reassemble arrival-order mode, set the following configuration option as shown:</p>
<pre class="fragment">receiver ordered_delivery 0
</pre><p>When developing message reassembly code, consider the following:</p>
<ul>
<li>
Message fragments don't necessarily arrive in sequence number order. </li>
<li>
Some message fragments may never arrive (unrecoverable loss), so you must time out partial messages. </li>
</ul>
<p><b>Arrival order delivery without reassembly is not compatible with the following UM features:</b> </p><ul>
<li>
<a class="el" href="transporttypes.html#transportlbtsmx">Transport LBT-SMX</a> </li>
<li>
<a class="el" href="umfeatures.html#messageproperties">Message Properties</a> </li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="lossdetectionusingtsnis"></a>
Loss Detection Using TSNIs&nbsp;&nbsp;<small><a href="#lossdetectionusingtsnis">&lt;-</a></small></h1>
<p>A TSNI (Topic Sequence Number Information) message is an internal UM message sent by a source to inform receivers of the topic-level sequence number of the last message sent.</p>
<p>When a source enters an idle period during which it has no data traffic to send (5 seconds by default), that source will send one or more TSNI messages. The TSNI lets receivers know that the source is still active and also reminds receivers of the sequence number of the last message. This helps receivers become aware of any lost messages prior to the TSNI.</p>
<p>Sources send TSNIs over the same transport and on the same topic as normal data messages. You can set a time value of the TSNI interval with configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#transporttopicsequencenumberinfointervalsource">transport_topic_sequence_number_info_interval (source)</a>. You can also set a time value for the duration that the source sends contiguous TSNIs with configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#transporttopicsequencenumberinfoactivethresholdsource">transport_topic_sequence_number_info_active_threshold (source)</a>, after which time the source stops issuing TSNIs.</p>
<p><br />
 </p>
<h1><a class="anchor" id="receiverkeepaliveusingsesssionmessages"></a>
Receiver Keepalive Using Session Messages&nbsp;&nbsp;<small><a href="#receiverkeepaliveusingsesssionmessages">&lt;-</a></small></h1>
<p>When an LBT-RM, LBT-RU, or LBT-IPC <a class="el" href="fundamentalconcepts.html#transportsessions">Transport Session</a> enters an inactive period during which it has no messages to send, the UM context sends Session Messages (SMs). The first SM is sent after 200 milliseconds of inactivity (by default). If the period of inactivity continues additional SMs will be sent at increasing intervals, up to a maximum interval of 10 seconds (by default).</p>
<p>SMs serve three functions: </p><ol>
<li>
<b>Keepalive</b> - SMs inform receivers that transport sessions are still alive. If a receiver stops getting any kind of traffic for a transport session, after a configurable period of inactivity the receiver will time out the transport session and will assume that it has died. </li>
<li>
<b>Tail loss</b> - for UDP-based transport sessions (LBT-RM and LBT-RU), SMs are used to detect packet loss, specifically "tail loss", and trigger recovery. </li>
<li>
<b>Multicast Flows</b> - for multicast-based transport sessions (LBT-RM), SMs serve to keep the network hardware multicast flows "hot", so that replication and forwarding of multicast packets is done in hardware at line speed. </li>
</ol>
<p>Any other UM message on a transport session will suppress the sending of SMs, including data messages and TSNIs. (Topic Resolution messages are not sent on the transport session, and will not suppress sending SMs.) You can set time values for SM interval and duration with configuration options specific to their transport type.</p>
<div class="image">
<img src="SMs.png" alt="SMs.png"/>
</div>
 <p><br />
 </p>
<h1><a class="anchor" id="extendedmessagingexample"></a>
Extended Messaging Example&nbsp;&nbsp;<small><a href="#extendedmessagingexample">&lt;-</a></small></h1>
<p>This section illustrates many of the preceding concepts using an extended example of message passing. This example uses <a class="el" href="transporttypes.html#transportlbtrm">LBT-RM</a>, but for the purposes of this example, <a class="el" href="transporttypes.html#transportlbtru">LBT-RU</a> operates in a similar manner.</p>
<p>The example starts out with two applications, Publisher and Subscriber:</p>
<div class="image">
<img src="Ext_examp.png" alt="Ext_examp.png"/>
</div>
 <p>The publisher has created three source objects, for topics "A", "B", and "C" respectively. All three sources are mapped to a single LBT-RM <a class="el" href="fundamentalconcepts.html#transportsessions">Transport Session</a> by configuring them for the same <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmnetwork.html#transportlbtrmmulticastaddresssource">multicast group address</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmnetwork.html#transportlbtrmdestinationportsource">destination port</a>.</p>
<p>The Subscriber application creates two receivers, for topics "A" and "B".</p>
<p>The creation of sources and receivers triggers <a class="el" href="fundamentalconcepts.html#topicresolutionoverview">Topic Resolution</a>, and the subscriber joins the Transport Session once the topics are resolved. To be precise, the first receiver to discover a source triggers joining the Transport Session and creating a <a class="el" href="fundamentalconcepts.html#deliverycontroller">Delivery Controller</a>; subsequent source discoveries on the same Transport Session don't need to join; they only create Delivery Controllers. However, until such time as one or more publishing sources send their first <a class="el" href="fundamentalconcepts.html#umsoftwarestack">topic-layer</a> message, the source Transport Session sends no datagrams. The Transport Session is created, but has not yet "started".</p>
<p><br />
 </p>
<h2><a class="anchor" id="examplefirstmessage"></a>
Example: First Message&nbsp;&nbsp;<small><a href="#examplefirstmessage">&lt;-</a></small></h2>
<p>In this example, the first message on the Transport Session is generated by the publishing application sending an application message, in this case for topic "A".</p>
<div class="image">
<img src="Ext_examp_msg0.png" alt="Ext_examp_msg0.png"/>
</div>
 <p>The send function is passed the "flush" flag so that the message is sent immediately. The message is assigned a topic-level sequence number of 0, since it is the application's first message for that topic. The source-side transport layer wraps the application message in a datagram and gives it transport sequence number 0, since it is the first datagram sent on the Transport Session.</p>
<p>On the receive side, the first datagram (of any kind) on the Transport Session informs the transport layer that the Transport Session is active. The transport layer informs all mapped <a class="el" href="fundamentalconcepts.html#deliverycontroller">Delivery Controller</a> instances that the Transport Session has begun. Each Delivery Controller delivers a Beginning Of Session event (BOS) to the application callback for each receiver. The passed-in <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/structlbm__msg__t__stct.html">lbm_msg_t</a> structure has event <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/structlbm__msg__t__stct.html#ab25327dc4b4ebf527106f6e708dbc05f">type</a> equal to <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#ab5489080adc7157549a9930b30c68425">LBM_MSG_BOS</a>.</p>
<p>Note that the receiver for topic B gets a BOS even though no messages were received for it; the BOS event informs the receivers that the <em>Transport Session</em> is active, not the topic.</p>
<p>Finally, the transport layer passes the received datagram to the topic-A Delivery Controller, which passes the application message to the receiver callback. The passed-in <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/structlbm__msg__t__stct.html">lbm_msg_t</a> structure has event <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/structlbm__msg__t__stct.html#ab25327dc4b4ebf527106f6e708dbc05f">type</a> equal to <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#aa47eb604db7dc9fd53f9650ed940e058">LBM_MSG_DATA</a>, and a topic-level <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/structlbm__msg__t__stct.html#a414eaced619e9dfafbcb2c7608af8e7e">sequence_number</a> of 0. (The transport sequence number is not available to the application.)</p>
<p><br />
 </p>
<h2><a class="anchor" id="examplebatching"></a>
Example: Batching&nbsp;&nbsp;<small><a href="#examplebatching">&lt;-</a></small></h2>
<p>The publishing application now has two more messages to send. To maximize efficiency, it chooses to <a class="el" href="architecture.html#messagebatching">batch</a> the messages together:</p>
<div class="image">
<img src="Ext_examp_batch.png" alt="Ext_examp_batch.png"/>
</div>
 <p>The publishing application sends a message to topic "B", this time <em>without</em> the "flush" flag. The source-side topic layer buffers the message. Then the publishing application sends a message to topic "C", <em>with</em> the "flush" flag. The source-side transport layer wraps both application messages into a single datagram and gives it transport sequence number 1, since it is the second datagram sent on the Transport Session. But the two topic level sequence numbers are 0, since these are the first messages sent to those topics.</p>
<p>Note that almost no latency is added by batching, so long as the second message is ready to send immediately after the first. This method of low-latency batching is called <a class="el" href="architecture.html#intelligentbatching">Intelligent Batching</a>, and can greatly increase the maximum sustainable throughput of UM.</p>
<p>The subscriber gets the datagram and delivers the topic "B" message to the application receiver callback. It's topic-level <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/structlbm__msg__t__stct.html#a414eaced619e9dfafbcb2c7608af8e7e">sequence_number</a> is 0 since it was the first message sent to the "B" source. However, the subscriber application has no receiver for topic "C", so the message "C" is simply discarded.</p>
<p><br />
 </p>
<h2><a class="anchor" id="exampleumfragmentation"></a>
Example: UM Fragmentation&nbsp;&nbsp;<small><a href="#exampleumfragmentation">&lt;-</a></small></h2>
<p>The publishing application now has a topic "A" message to send that is larger than the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmoperation.html#transportlbtrmdatagrammaxsizecontext">maximum allowable datagram</a>.</p>
<div class="image">
<img src="Ext_examp_frag.png" alt="Ext_examp_frag.png"/>
</div>
 <p>The source-side topic layer splits the application message into two fragments and assigns each fragment its own topic-level sequence number (1 for the first, 2 for the second). The topic-layer gives each fragment separately to the transport layer, which wraps each fragment into its own datagram, consuming two transport sequence numbers (2 and 3). Note that the transport layer does not interpret these fragments as parts of a single larger message; from the transport's point of view, this simply two datagrams being sent.</p>
<p>The receive-side transport layer gets the datagrams and hands them to the Topic-A <a class="el" href="fundamentalconcepts.html#deliverycontroller">Delivery Controller</a> (receiver-side topic layer). The Delivery Controller reassembles the fragments in the correct order, and delivers the message to the application's receiver callback in a single call. The <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/structlbm__msg__t__stct.html#a414eaced619e9dfafbcb2c7608af8e7e">sequence_number</a> visible to the application is the topic-level sequence number of the <em>last</em> fragment (2 in this example).</p>
<p>Note that the application receiver callback never sees a topic sequence_number of 1 for topic "A". It saw 0 then 2, with 1 seemingly missing. However, the application can call <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#afa760960c21f502a8cb4c5ec5d97f91b">lbm_msg_retrieve_fragment_info()</a> to find out the range of topic sequence numbers consumed by a message.</p>
<p>The behavior described above is for the default <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#ordereddeliveryreceiver">ordered_delivery (receiver)</a> equal to 1. see <a class="el" href="architecture.html#ordereddelivery">Ordered Delivery</a> for alternative behaviors.</p>
<p><br />
 </p>
<h2><a class="anchor" id="examplelossrecovery"></a>
Example: Loss Recovery&nbsp;&nbsp;<small><a href="#examplelossrecovery">&lt;-</a></small></h2>
<p>Now the publishing application sends a message to topic C. But the datagram is lost, so the receiver does not see it. Also, right after the send to topic C, the application deletes the sources for topics B and C.</p>
<div class="image">
<img src="Ext_examp_loss1.png" alt="Ext_examp_loss1.png"/>
</div>
 <p>Deleting a source shortly after sending a message to it is contrary to best practice. Applications should pause between the last send to a topic and the deletion of the topic, preferable a delay of between 5 and 10 seconds. This gives receivers an opportunity to attempt recovery if the last message sent was lost. We delete the sources here to illustrate an important point.</p>
<p>Note that although the datagram was lost and two topics were deleted, nothing happens. The receiver does not request a retransmission because the receiver has no idea that the source sent a message. Also, the source-side topic layer does not explicitly inform the receiver that the topics are deleted.</p>
<p>Continuing the example, the publishing application sends another message, this time a message for topic A ("Topic-A, topic sqn=3"):</p>
<div class="image">
<img src="Ext_examp_recover1.png" alt="Ext_examp_recover1.png"/>
</div>
 <p>There are two notable events here: </p><ol>
<li>
<p class="startli">The "A" message is delivered immediately to the topic "A" receiver, even though earlier data was lost and not yet retransmitted. If this were TCP, the kernel would buffer and prevent delivery of subsequent data until the lost data is recovered.</p>
<p class="endli"></p>
</li>
<li>
The reception of that "A" message with transport sequence number 5 informs the receive-side transport layer that transport datagram #4 was lost. So it initiates a NAK/retransmission cycle. When the lost datagram is retransmitted, the receiver throws it away since it is for an unsubscribed topic. </li>
</ol>
<p>You might wonder: why NAK and retransmit datagram 4 if the subscriber is just going to throw it away? The subscriber NAKs it because it has no way of knowing which topic it contains; if it were topic B, then it would need that datagram. The publisher retransmits it because it does not know which topics the subscriber is interested in. It has no way of knowing that the subscriber will throw it away.</p>
<p>Regarding message "Topic-A, sqn=3", what if the publisher did not have that message to send? I.e. what if that "Topic-C, sqn=1" message were the last one for a while? This is called "tail loss" since the lost datagram is not immediately followed by a successful datagram. The subscriber has no idea that messages were sent but lost. In this case, the source-side transport layer would have sent a transport-level "session message" after about 200 ms of inactivity on the Transport Session. That session message would inform the receiver-side transport layer that datagram #5 was lost, and would trigger the NAK/retransmission.</p>
<p>Finally, note that the message for topic-C was retransmitted, even though the topic-C source was deleted. This is because the deletion of a source does not purge the transport layer's retransmission buffer of datagrams from that source. However, higher-level recovery mechanisms, such as late join and OTR, are no longer possible after the source is deleted. Also, if <em>all</em> sources on a Transport Session are deleted, the Transport Session itself is deleted, which makes even transport-level retransmission impossible. (Only <a class="el" href="fundamentalconcepts.html#persistence">Persistence</a> allows recovery after the transport session is deleted.)</p>
<p><br />
 </p>
<h2><a class="anchor" id="exampleunrecoverableloss"></a>
Example: Unrecoverable Loss&nbsp;&nbsp;<small><a href="#exampleunrecoverableloss">&lt;-</a></small></h2>
<p>The previous examples assume that events are happening in fairly rapid succession. In this example of unrecoverable loss, significantly longer time periods are involved.</p>
<p>Unrecoverable loss is what happens when UM tries to recover the lost data but it is unable to. There are many possible scenarios which can cause recovery efforts fail, most of which involve a massive overload of one or more components in the data flow.</p>
<p>To simplify this example, let's assume that, starting now, all NAKs are blocked by the network switch. If the publisher never sees the NAKs, it assumes that all datagrams were received successfully and does not retransmit anything.</p>
<div class="image">
<img src="Ext_examp_unrec.png" alt="Ext_examp_unrec.png"/>
</div>
 <p>At T=0, the message "Topic-A, sqn=4" is sent, but not received. Let's assume that the publisher has no more application messages to send for a while. With every application message sent, the source starts two activity timers: a transport-level "session" timer, and a topic-level "TSNI" timer. The session timer is for .2 seconds (see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmoperation.html#transportlbtrmsmminimumintervalsource">transport_lbtrm_sm_minimum_interval (source)</a>), and the TSNI timer is for 5 seconds (see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grpmajoroptions.html#transporttopicsequencenumberinfointervalsource">transport_topic_sequence_number_info_interval (source)</a>).</p>
<p>At T=0.2, the session timer expires and the source-side transport layer sends a session message. When the receive-side transport layer sees the session message, it learns that transport datagram #6 was lost. So it starts two receive-side transport-level timers: "NAK backoff" and "NAK generation". NAK backoff is shown here as .05 seconds, but is actually randomized between .025 and .075 (see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmreliability.html#transportlbtrmnakinitialbackoffintervalreceiver">transport_lbtrm_nak_initial_backoff_interval (receiver)</a>. The NAK generation is 10 seconds (see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmreliability.html#transportlbtrmnakgenerationintervalreceiver">transport_lbtrm_nak_generation_interval (receiver)</a>).</p>
<p>At T=0.25, the NAK backoff timer expires. Since the transport receiver still has not seen datagram #6, it sends a NAK. However, we are assuming that all NAKs are blocked, so the transport source never sees it. Over the next ~5 seconds, the source will send several more session messages and the receiver will send several more NAKs (not shown).</p>
<p>At T=5, the TSNI timer set by the source at T=0 expires. Since no application messages have been sent since then, the source sends a TSNI message for topic "A". This informs the Delivery Controller that it lost the message "Topic-A, sqn=4". However, the receive-side Delivery Controller (topic layer) does not initiate any recovery activity. It only sets a <em>topic-level</em> timer for the same amount of time as the transport's NAK generation timer, 10 seconds. The Delivery Controller assumes that the transport layer will do the actual data recovery.</p>
<p>At T=10.2, the receive-side transport layer's NAK generation timer (set at T=0.2) finally expires; the <em>transport layer</em> now considers datagram #6 as unrecoverable loss. The transport layer stops sending NAKs for that datagram, and it increments the receive-side transport statistic <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/structlbm__rcv__transport__stats__lbtrm__t__stct.html#aec81f344ce20a3485bbf2f5a65b5c61e">lbm_rcv_transport_stats_lbtrm_t_stct::unrecovered_tmo</a>. Note that it does <em>not</em> deliver an unrecoverable loss event to the application.</p>
<p>Over the next ~5 seconds, the Delivery Controller continues to wait for the missing message to be recovered by the transport receiver, but the transport receiver has already given up. You might wonder why the transport layer doesn't inform the Delivery Controller that the lost datagram was unrecoverable loss. The problem is that the transport layer does not know the contents of the lost datagram, and therefore does not know which topic to inform. That is why the Delivery Controller needs to set its own NAK generation timer at the point where it detects topic-level loss (at T=5).</p>
<p>Note that had sources src-B and src-C not been deleted earlier, messages sent to them could have been successfully received and processed during this entire 15-second period. However, any subsequent messages for topic "A" would need to be buffered until T=15. After the unrecoverable loss event is delivered for topic A sequence_number 4, subsequently received and buffered messages for topic "A" are delivered.</p>
<p><br />
 </p>
<h2><a class="anchor" id="exampletransportdeletion"></a>
Example: Transport Deletion&nbsp;&nbsp;<small><a href="#exampletransportdeletion">&lt;-</a></small></h2>
<p>During the previous 15 seconds, the source-side had sent a number of topic-level TSNI (for topic A) and transport-level session messages. At this point, the publishing application deletes source "A". Since sources "B" and "C" were deleted earlier, "A" was the last source mapped to the Transport Session. So UM deletes the Transport Session.</p>
<div class="image">
<img src="Ext_examp_del.png" alt="Ext_examp_del.png"/>
</div>
 <p>Note that no indication is sent from the source side to inform receivers of the removal of the sources, nor the Transport Session. So the receive-side transport layer has to time out the Transport Session after 60 seconds of inactivity (see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/config.tag:../Config/" href="../Config/grptransportlbtrmoperation.html#transportlbtrmactivitytimeoutreceiver">transport_lbtrm_activity_timeout (receiver)</a>).</p>
<p>The receive-side transport layer then informs both Delivery Controllers of the End Of Session event, which the Delivery Controllers pass onto the application receiver callback for each topic. The <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/structlbm__msg__t__stct.html">lbm_msg_t</a> structure has an event <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/structlbm__msg__t__stct.html#ab25327dc4b4ebf527106f6e708dbc05f">type</a> of <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Design/api.tag:../API/" href="../API/lbm_8h.html#a2647b87f92adb5a34ea129fbfeeed5a3">LBM_MSG_EOS</a>. The delivery controllers and the receive-side transport layer instance are then deleted.</p>
<p>However, note that the receiver objects will continue to exist. They are ready in case another publishing application starts up and creates sources for topics A and/or B.</p>
<p><br />
<br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
</body>
</html>
