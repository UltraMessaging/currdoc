<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>UM C API: Source code for lbmmontrudp.c</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen_api.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">UM C API
   &#160;<span id="projectnumber">6.14</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('lbmmontrudp_c_page.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Source code for lbmmontrudp.c </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">  All of the documentation and software included in this and any</span></div><div class="line"><span class="comment">  other Informatica Corporation Ultra Messaging Releases</span></div><div class="line"><span class="comment">  Copyright (C) Informatica Corporation. All rights reserved.</span></div><div class="line"><span class="comment">  </span></div><div class="line"><span class="comment">  Redistribution and use in source and binary forms, with or without</span></div><div class="line"><span class="comment">  modification, are permitted only as covered by the terms of a</span></div><div class="line"><span class="comment">  valid software license agreement with Informatica Corporation.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  Copyright (C) 2004-2021, Informatica Corporation. All Rights Reserved.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND INFORMATICA DISCLAIMS ALL WARRANTIES </span></div><div class="line"><span class="comment">  EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY IMPLIED WARRANTIES OF </span></div><div class="line"><span class="comment">  NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR </span></div><div class="line"><span class="comment">  PURPOSE.  INFORMATICA DOES NOT WARRANT THAT USE OF THE SOFTWARE WILL BE </span></div><div class="line"><span class="comment">  UNINTERRUPTED OR ERROR-FREE.  INFORMATICA SHALL NOT, UNDER ANY CIRCUMSTANCES, BE </span></div><div class="line"><span class="comment">  LIABLE TO LICENSEE FOR LOST PROFITS, CONSEQUENTIAL, INCIDENTAL, SPECIAL OR </span></div><div class="line"><span class="comment">  INDIRECT DAMAGES ARISING OUT OF OR RELATED TO THIS AGREEMENT OR THE </span></div><div class="line"><span class="comment">  TRANSACTIONS CONTEMPLATED HEREUNDER, EVEN IF INFORMATICA HAS BEEN APPRISED OF </span></div><div class="line"><span class="comment">  THE LIKELIHOOD OF SUCH DAMAGES.</span></div><div class="line"><span class="comment">  </span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef __VOS__</span></div><div class="line"><span class="preprocessor">#define _POSIX_C_SOURCE 200112L</span></div><div class="line"><span class="preprocessor">#include &lt;sys/time.h&gt;</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;time.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;limits.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;errno.h&gt;</span></div><div class="line"><span class="preprocessor">#ifdef _WIN32</span></div><div class="line"><span class="preprocessor">        #include &lt;winsock2.h&gt;</span></div><div class="line"><span class="preprocessor">        #include &lt;ws2tcpip.h&gt;</span></div><div class="line"><span class="preprocessor">        #define strcasecmp stricmp</span></div><div class="line"><span class="preprocessor">        #define snprintf _snprintf</span></div><div class="line">        <span class="keyword">typedef</span> <span class="keywordtype">int</span> ssize_t;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="preprocessor">        #include &quot;config.h&quot;</span></div><div class="line"><span class="preprocessor">        #include &lt;unistd.h&gt;</span></div><div class="line"><span class="preprocessor">        #if defined(__TANDEM)</span></div><div class="line"><span class="preprocessor">                #if defined(HAVE_TANDEM_SPT)</span></div><div class="line"><span class="preprocessor">                        #include &lt;ktdmtyp.h&gt;</span></div><div class="line"><span class="preprocessor">                        #include &lt;spthread.h&gt;</span></div><div class="line"><span class="preprocessor">                #else</span></div><div class="line"><span class="preprocessor">                        #include &lt;pthread.h&gt;</span></div><div class="line"><span class="preprocessor">                #endif</span></div><div class="line"><span class="preprocessor">        #else</span></div><div class="line"><span class="preprocessor">                #include &lt;pthread.h&gt;</span></div><div class="line"><span class="preprocessor">        #endif</span></div><div class="line"><span class="preprocessor">        #include &lt;strings.h&gt;</span></div><div class="line"><span class="preprocessor">        #include &lt;sys/socket.h&gt;</span></div><div class="line"><span class="preprocessor">        #include &lt;netinet/in.h&gt;</span></div><div class="line"><span class="preprocessor">        #include &lt;arpa/inet.h&gt;</span></div><div class="line"><span class="preprocessor">        #include &lt;unistd.h&gt;</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">#if defined(__VMS)</span></div><div class="line">        <span class="keyword">typedef</span> <span class="keywordtype">int</span> socklen_t;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lbmmon_8h.html">lbm/lbmmon.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;lbm/lbmmontrudp.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef _WIN32</span></div><div class="line"><span class="preprocessor">        #define LBMMON_INVALID_HANDLE INVALID_SOCKET</span></div><div class="line"><span class="preprocessor">        #define LBMMON_SOCKET_ERROR SOCKET_ERROR</span></div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="preprocessor">        #define LBMMON_INVALID_HANDLE -1</span></div><div class="line"><span class="preprocessor">        #define LBMMON_SOCKET_ERROR -1</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">#ifndef INADDR_NONE</span></div><div class="line"><span class="preprocessor">        #define INADDR_NONE ((in_addr_t) 0xffffffff)</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="comment">/*                                                                              </span></div><div class="line"><span class="comment">        Package all of the needed function pointers for this module into a</span></div><div class="line"><span class="comment">        lbmmon_transport_func_t structure.                                                                                                                                                              </span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="structlbmmon__transport__func__t__stct.html">lbmmon_transport_func_t</a> LBMMON_TRANSPORT_UDP =</div><div class="line">{</div><div class="line">        lbmmon_transport_udp_initsrc,</div><div class="line">        lbmmon_transport_udp_initrcv,</div><div class="line">        lbmmon_transport_udp_send,</div><div class="line">        lbmmon_transport_udp_receive,</div><div class="line">        lbmmon_transport_udp_src_finish,</div><div class="line">        lbmmon_transport_udp_rcv_finish,</div><div class="line">        lbmmon_transport_udp_errmsg,</div><div class="line">        NULL</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/*                                                                              </span></div><div class="line"><span class="comment">        For a statistics source, one of these gets returned as the TransportClientData.                                                                                                                                                         </span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div><div class="line">{</div><div class="line">        <span class="comment">/* Socket used to send a statistics packet */</span></div><div class="line"><span class="preprocessor">#ifdef _WIN32</span></div><div class="line">        SOCKET mSocket;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        <span class="keywordtype">int</span> mSocket;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        <span class="comment">/* Peer socket address */</span></div><div class="line">        <span class="keyword">struct </span>sockaddr_in mPeer;</div><div class="line">        <span class="comment">/* Mode */</span></div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> mMode;</div><div class="line">} lbmmon_transport_udp_src_t;</div><div class="line"></div><div class="line"><span class="preprocessor">#define MODE_UNICAST 0</span></div><div class="line"><span class="preprocessor">#define MODE_BROADCAST 1</span></div><div class="line"><span class="preprocessor">#define MODE_MULTICAST 2</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">        A queue of incoming statistics packets is maintained. This describes each </span></div><div class="line"><span class="comment">        entry in the queue.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">struct </span>lbmmon_transport_udp_rcv_node_t_stct</div><div class="line">{</div><div class="line">        <span class="comment">/* Pointer to the message */</span></div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * mMessage;</div><div class="line">        <span class="comment">/* Length of the message */</span></div><div class="line">        <span class="keywordtype">size_t</span> mMessageLength;</div><div class="line">        <span class="comment">/* Number of bytes of the message returned to caller */</span></div><div class="line">        <span class="keywordtype">size_t</span> mUsedBytes;</div><div class="line">        <span class="comment">/* Next entry in the queue */</span></div><div class="line">        <span class="keyword">struct </span>lbmmon_transport_udp_rcv_node_t_stct * mNext;</div><div class="line">};</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>lbmmon_transport_udp_rcv_node_t_stct lbmmon_transport_udp_rcv_node_t;</div><div class="line"></div><div class="line"><span class="comment">/*                                                                              </span></div><div class="line"><span class="comment">        For a statistics receiver, one of these gets returned as the TransportClientData.                                                                                                                                                               </span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div><div class="line">{</div><div class="line">        <span class="comment">/* Lock to prevent access by multiple threads */</span></div><div class="line"><span class="preprocessor">#ifdef _WIN32</span></div><div class="line">        CRITICAL_SECTION mLock;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        pthread_mutex_t mLock;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        <span class="comment">/* Socket used to receive packets */</span></div><div class="line"><span class="preprocessor">#ifdef _WIN32</span></div><div class="line">        SOCKET mSocket;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        <span class="keywordtype">int</span> mSocket;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        <span class="comment">/* Peer socket address */</span></div><div class="line">        <span class="keyword">struct </span>sockaddr_in mPeer;</div><div class="line">        <span class="comment">/* Interface */</span></div><div class="line">        <span class="keyword">struct </span>sockaddr_in mInterface;</div><div class="line">        <span class="comment">/* Multicast membership */</span></div><div class="line">        <span class="keyword">struct </span>ip_mreq mMulticastMembership;</div><div class="line">        <span class="comment">/* Mode */</span></div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> mMode;</div><div class="line">        <span class="comment">/* Head of the message queue */</span></div><div class="line">        lbmmon_transport_udp_rcv_node_t * mHead;</div><div class="line">        <span class="comment">/* Tail of the message queue */</span></div><div class="line">        lbmmon_transport_udp_rcv_node_t * mTail;</div><div class="line">        <span class="comment">/* Receiving thread */</span></div><div class="line"><span class="preprocessor">#ifdef _WIN32</span></div><div class="line">        HANDLE mThread;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        pthread_t mThread;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        <span class="comment">/* Flag to terminate thread */</span></div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> mTerminateThread;</div><div class="line">} lbmmon_transport_udp_rcv_t;</div><div class="line"></div><div class="line"><span class="preprocessor">#define DEFAULT_INTERFACE &quot;0.0.0.0&quot;</span></div><div class="line"><span class="preprocessor">#define DEFAULT_PORT &quot;2933&quot;</span></div><div class="line"><span class="preprocessor">#define DEFAULT_TTL &quot;16&quot;</span></div><div class="line"></div><div class="line"><span class="comment">/* Error codes */</span></div><div class="line"><span class="preprocessor">#define LBMMONTRUDP_ERR_INVALID_OPTION 1</span></div><div class="line"><span class="preprocessor">#define LBMMONTRUDP_ERR_SOCKET 2</span></div><div class="line"><span class="preprocessor">#define LBMMONTRUDP_ERR_SEND 3</span></div><div class="line"><span class="preprocessor">#define LBMMONTRUDP_ERR_THREAD 4</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> lock_receiver(lbmmon_transport_udp_rcv_t * Receiver);</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> unlock_receiver(lbmmon_transport_udp_rcv_t * Receiver);</div><div class="line"><span class="preprocessor">#ifdef _WIN32</span></div><div class="line"><span class="keyword">static</span> DWORD WINAPI receive_thread_proc(<span class="keywordtype">void</span> * Arg);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> * receive_thread_proc(<span class="keywordtype">void</span> * Arg);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">char</span> ErrorString[1024];</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *</div><div class="line">last_socket_error(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">        <span class="keyword">static</span> <span class="keywordtype">char</span> message[512];</div><div class="line"><span class="preprocessor">#ifdef _WIN32</span></div><div class="line">        snprintf(message, <span class="keyword">sizeof</span>(message), <span class="stringliteral">&quot;error %d&quot;</span>, WSAGetLastError());</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        snprintf(message,</div><div class="line">                         <span class="keyword">sizeof</span>(message),</div><div class="line">                         <span class="stringliteral">&quot;error %d, %s&quot;</span>,</div><div class="line">                         errno,</div><div class="line">                         strerror(errno));</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        <span class="keywordflow">return</span> (message);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> lbmmon_transport_udp_report_allocation_error(<span class="keywordtype">size_t</span> Size)</div><div class="line">{</div><div class="line">        snprintf(ErrorString, <span class="keyword">sizeof</span>(ErrorString), <span class="stringliteral">&quot;Unable to allocate %u bytes&quot;</span>, (<span class="keywordtype">unsigned</span>) Size);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structlbmmon__transport__func__t__stct.html">lbmmon_transport_func_t</a> *</div><div class="line">lbmmon_transport_udp_module(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">        <span class="keywordflow">return</span> (&amp;LBMMON_TRANSPORT_UDP);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">lbmmon_transport_udp_initsrc(<span class="keywordtype">void</span> * * TransportClientData, <span class="keyword">const</span> <span class="keywordtype">void</span> * TransportOptions)</div><div class="line">{</div><div class="line">        lbmmon_transport_udp_src_t * data;</div><div class="line">        <span class="keywordtype">int</span> rc;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span> * ptr = (<span class="keyword">const</span> <span class="keywordtype">char</span> *) TransportOptions;</div><div class="line">        <span class="keywordtype">char</span> key[512];</div><div class="line">        <span class="keywordtype">char</span> value[512];</div><div class="line">        <span class="keywordtype">char</span> address[512];</div><div class="line">        <span class="keywordtype">char</span> port[512];</div><div class="line">        <span class="keywordtype">char</span> interface[512];</div><div class="line">        <span class="keywordtype">char</span> mcgroup[512];</div><div class="line">        <span class="keywordtype">char</span> bcaddress[512];</div><div class="line">        <span class="keywordtype">char</span> ttl[512];</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> port_value;</div><div class="line">        <span class="keyword">struct </span>in_addr multicast_group;</div><div class="line">        <span class="keyword">struct </span>in_addr multicast_interface;</div><div class="line">        <span class="keyword">struct </span>in_addr broadcast_address;</div><div class="line">        <span class="keyword">struct </span>in_addr host_address;</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ttl_value = 0;</div><div class="line"></div><div class="line">        memset(ErrorString, 0, <span class="keyword">sizeof</span>(ErrorString));</div><div class="line">        data = malloc(<span class="keyword">sizeof</span>(lbmmon_transport_udp_src_t));</div><div class="line">        <span class="keywordflow">if</span> (data == NULL)</div><div class="line">        {</div><div class="line">                lbmmon_transport_udp_report_allocation_error(<span class="keyword">sizeof</span>(lbmmon_transport_udp_src_t));</div><div class="line">                <span class="keywordflow">return</span> (-1);</div><div class="line">        }</div><div class="line">        multicast_group.s_addr = 0;</div><div class="line">        multicast_interface.s_addr = 0;</div><div class="line">        broadcast_address.s_addr = 0;</div><div class="line">        host_address.s_addr = 0;</div><div class="line"></div><div class="line">        <span class="comment">/* Process any options */</span></div><div class="line">        memset(address, 0, <span class="keyword">sizeof</span>(address));</div><div class="line">        memset(port, 0, <span class="keyword">sizeof</span>(port));</div><div class="line">        strcpy(port, DEFAULT_PORT);</div><div class="line">        memset(interface, 0, <span class="keyword">sizeof</span>(interface));</div><div class="line">        strcpy(interface, DEFAULT_INTERFACE);</div><div class="line">        memset(mcgroup, 0, <span class="keyword">sizeof</span>(mcgroup));</div><div class="line">        memset(bcaddress, 0, <span class="keyword">sizeof</span>(bcaddress));</div><div class="line">        memset(ttl, 0, <span class="keyword">sizeof</span>(ttl));</div><div class="line">        strcpy(ttl, DEFAULT_TTL);</div><div class="line">        data-&gt;mMode = MODE_UNICAST;</div><div class="line">        <span class="keywordflow">while</span> ((ptr = <a class="code" href="lbmmon_8h.html#a92cdb7dc9ffbf2d68742d3762b974073">lbmmon_next_key_value_pair</a>(ptr, key, <span class="keyword">sizeof</span>(key), value, <span class="keyword">sizeof</span>(value))) != NULL)</div><div class="line">        {</div><div class="line">                <span class="keywordflow">if</span> (strcasecmp(key, <span class="stringliteral">&quot;address&quot;</span>) == 0)</div><div class="line">                {</div><div class="line">                        strncpy(address, value, <span class="keyword">sizeof</span>(address));</div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp(key, <span class="stringliteral">&quot;port&quot;</span>) == 0)</div><div class="line">                {</div><div class="line">                        strncpy(port, value, <span class="keyword">sizeof</span>(port));</div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp(key, <span class="stringliteral">&quot;interface&quot;</span>) == 0)</div><div class="line">                {</div><div class="line">                        strncpy(interface, value, <span class="keyword">sizeof</span>(interface));</div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp(key, <span class="stringliteral">&quot;mcgroup&quot;</span>) == 0)</div><div class="line">                {</div><div class="line">                        strncpy(mcgroup, value, <span class="keyword">sizeof</span>(mcgroup));</div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp(key, <span class="stringliteral">&quot;bcaddress&quot;</span>) == 0)</div><div class="line">                {</div><div class="line">                        strncpy(bcaddress, value, <span class="keyword">sizeof</span>(bcaddress));</div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp(key, <span class="stringliteral">&quot;ttl&quot;</span>) == 0)</div><div class="line">                {</div><div class="line">                        strncpy(ttl, value, <span class="keyword">sizeof</span>(ttl));</div><div class="line">                }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/*      Validate the options</span></div><div class="line"><span class="comment">                Note the following:</span></div><div class="line"><span class="comment">                - interface and ttl only apply to mcgroup</span></div><div class="line"><span class="comment">                - mcgroup (and thus multicast) takes precedence over bcaddress (and thus broadcast)</span></div><div class="line"><span class="comment">                - bcaddress takes precedence over address.</span></div><div class="line"><span class="comment">        */</span></div><div class="line">        port_value = strtoul(port, NULL, 0);</div><div class="line">        <span class="keywordflow">if</span> ((port_value == ULONG_MAX) &amp;&amp; (errno == ERANGE))</div><div class="line">        {</div><div class="line">                strncpy(ErrorString, <span class="stringliteral">&quot;Invalid port value&quot;</span>, <span class="keyword">sizeof</span>(ErrorString));</div><div class="line">                free(data);</div><div class="line">                <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (port_value &gt; USHRT_MAX)</div><div class="line">        {</div><div class="line">                strncpy(ErrorString, <span class="stringliteral">&quot;Invalid port value&quot;</span>, <span class="keyword">sizeof</span>(ErrorString));</div><div class="line">                free(data);</div><div class="line">                <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (mcgroup[0] != <span class="charliteral">&#39;\0&#39;</span>)</div><div class="line">        {</div><div class="line">                data-&gt;mMode = MODE_MULTICAST;</div><div class="line">                multicast_group.s_addr = inet_addr(mcgroup);</div><div class="line">                <span class="keywordflow">if</span> (multicast_group.s_addr == INADDR_NONE)</div><div class="line">                {</div><div class="line">                        strncpy(ErrorString, <span class="stringliteral">&quot;Invalid mcgroup value&quot;</span>, <span class="keyword">sizeof</span>(ErrorString));</div><div class="line">                        free(data);</div><div class="line">                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);</div><div class="line">                }</div><div class="line">                <span class="keywordflow">if</span> (!IN_MULTICAST(ntohl(multicast_group.s_addr)))</div><div class="line">                {</div><div class="line">                        strncpy(ErrorString, <span class="stringliteral">&quot;Invalid mcgroup value&quot;</span>, <span class="keyword">sizeof</span>(ErrorString));</div><div class="line">                        free(data);</div><div class="line">                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);</div><div class="line">                }</div><div class="line">                multicast_interface.s_addr = inet_addr(interface);</div><div class="line">                <span class="keywordflow">if</span> (multicast_interface.s_addr == INADDR_NONE)</div><div class="line">                {</div><div class="line">                        strncpy(ErrorString, <span class="stringliteral">&quot;Invalid interface value&quot;</span>, <span class="keyword">sizeof</span>(ErrorString));</div><div class="line">                        free(data);</div><div class="line">                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);</div><div class="line">                }</div><div class="line">                ttl_value = strtoul(ttl, NULL, 0);</div><div class="line">                <span class="keywordflow">if</span> ((ttl_value == ULONG_MAX) &amp;&amp; (errno == ERANGE))</div><div class="line">                {</div><div class="line">                        strncpy(ErrorString, <span class="stringliteral">&quot;Invalid ttl value&quot;</span>, <span class="keyword">sizeof</span>(ErrorString));</div><div class="line">                        free(data);</div><div class="line">                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);</div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ttl_value &gt; UCHAR_MAX)</div><div class="line">                {</div><div class="line">                        strncpy(ErrorString, <span class="stringliteral">&quot;Invalid ttl value&quot;</span>, <span class="keyword">sizeof</span>(ErrorString));</div><div class="line">                        free(data);</div><div class="line">                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);</div><div class="line">                }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bcaddress[0] != <span class="charliteral">&#39;\0&#39;</span>)</div><div class="line">        {</div><div class="line">                data-&gt;mMode = MODE_BROADCAST;</div><div class="line">                broadcast_address.s_addr = inet_addr(bcaddress);</div><div class="line">                <span class="keywordflow">if</span> (broadcast_address.s_addr == INADDR_NONE)</div><div class="line">                {</div><div class="line">                        strncpy(ErrorString, <span class="stringliteral">&quot;Invalid bcaddress value&quot;</span>, <span class="keyword">sizeof</span>(ErrorString));</div><div class="line">                        free(data);</div><div class="line">                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);</div><div class="line">                }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">                host_address.s_addr = inet_addr(address);</div><div class="line">                <span class="keywordflow">if</span> (host_address.s_addr == INADDR_NONE)</div><div class="line">                {</div><div class="line">                        strncpy(ErrorString, <span class="stringliteral">&quot;Invalid address value&quot;</span>, <span class="keyword">sizeof</span>(ErrorString));</div><div class="line">                        free(data);</div><div class="line">                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);</div><div class="line">                }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Create the socket */</span></div><div class="line">        data-&gt;mSocket = socket(PF_INET, SOCK_DGRAM, 0);</div><div class="line">        <span class="keywordflow">if</span> (data-&gt;mSocket == LBMMON_INVALID_HANDLE)</div><div class="line">        {</div><div class="line">                snprintf(ErrorString,</div><div class="line">                                 <span class="keyword">sizeof</span>(ErrorString),</div><div class="line">                                 <span class="stringliteral">&quot;socket() failed, %s&quot;</span>,</div><div class="line">                                 last_socket_error());</div><div class="line">                free(data);</div><div class="line">                <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_SOCKET);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* If broadcast mode, enable broadcast on the socket */</span></div><div class="line">        <span class="keywordflow">if</span> (data-&gt;mMode == MODE_BROADCAST)</div><div class="line">        {</div><div class="line">                <span class="keywordtype">int</span> option = 1;</div><div class="line">                socklen_t len = <span class="keyword">sizeof</span>(option);</div><div class="line">                rc = setsockopt(data-&gt;mSocket, SOL_SOCKET, SO_BROADCAST, (<span class="keywordtype">void</span> *) &amp;option, len);</div><div class="line">                <span class="keywordflow">if</span> (rc == LBMMON_SOCKET_ERROR)</div><div class="line">                {</div><div class="line">                        snprintf(ErrorString,</div><div class="line">                                         <span class="keyword">sizeof</span>(ErrorString),</div><div class="line">                                         <span class="stringliteral">&quot;setsockopt(...,SO_BROADCAST,...) failed, %s&quot;</span>,</div><div class="line">                                         last_socket_error());</div><div class="line"><span class="preprocessor">#ifdef _WIN32</span></div><div class="line">                        closesocket(data-&gt;mSocket);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">                        close(data-&gt;mSocket);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">                        free(data);</div><div class="line">                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_SOCKET);</div><div class="line">                }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* For multicast, set the outgoing interface and TTL. */</span></div><div class="line">        <span class="keywordflow">if</span> (data-&gt;mMode == MODE_MULTICAST)</div><div class="line">        {</div><div class="line">                <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> optval = (<span class="keywordtype">unsigned</span> char) ttl_value;</div><div class="line">                <span class="keyword">struct </span>in_addr ifc_addr;</div><div class="line">                rc = setsockopt(data-&gt;mSocket, IPPROTO_IP, IP_MULTICAST_TTL, (<span class="keywordtype">void</span> *) &amp;optval, <span class="keyword">sizeof</span>(optval));</div><div class="line">                <span class="keywordflow">if</span> (rc != LBMMON_SOCKET_ERROR)</div><div class="line">                {</div><div class="line">                        ifc_addr.s_addr = multicast_interface.s_addr;</div><div class="line">                        rc = setsockopt(data-&gt;mSocket, IPPROTO_IP, IP_MULTICAST_IF, (<span class="keywordtype">void</span> *) &amp;ifc_addr, <span class="keyword">sizeof</span>(ifc_addr));</div><div class="line">                        <span class="keywordflow">if</span> (rc == LBMMON_SOCKET_ERROR)</div><div class="line">                        {</div><div class="line">                                snprintf(ErrorString,</div><div class="line">                                                 <span class="keyword">sizeof</span>(ErrorString),</div><div class="line">                                                 <span class="stringliteral">&quot;setsockopt(...,IP_MULTICAST_IF,...) failed, %s&quot;</span>,</div><div class="line">                                                 last_socket_error());</div><div class="line">                        }</div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                {</div><div class="line">                        snprintf(ErrorString,</div><div class="line">                                         <span class="keyword">sizeof</span>(ErrorString),</div><div class="line">                                         <span class="stringliteral">&quot;setsockopt(...,IP_MULTICAST_TTL,...) failed, %s&quot;</span>,</div><div class="line">                                         last_socket_error());</div><div class="line">                }</div><div class="line">                <span class="keywordflow">if</span> (rc == LBMMON_SOCKET_ERROR)</div><div class="line">                {</div><div class="line"><span class="preprocessor">#ifdef _WIN32</span></div><div class="line">                        closesocket(data-&gt;mSocket);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">                        close(data-&gt;mSocket);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">                        free(data);</div><div class="line">                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_SOCKET);</div><div class="line">                }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Build the peer sockaddr_in. */</span></div><div class="line">        data-&gt;mPeer.sin_family = AF_INET;</div><div class="line">        data-&gt;mPeer.sin_port = htons((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>) port_value);</div><div class="line">        <span class="keywordflow">switch</span> (data-&gt;mMode)</div><div class="line">        {</div><div class="line">                <span class="keywordflow">case</span> MODE_UNICAST:</div><div class="line">                <span class="keywordflow">default</span>:</div><div class="line">                        data-&gt;mPeer.sin_addr.s_addr = host_address.s_addr;</div><div class="line">                        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">                <span class="keywordflow">case</span> MODE_BROADCAST:</div><div class="line">                        data-&gt;mPeer.sin_addr.s_addr = broadcast_address.s_addr;</div><div class="line">                        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">                <span class="keywordflow">case</span> MODE_MULTICAST:</div><div class="line">                        data-&gt;mPeer.sin_addr.s_addr = multicast_group.s_addr;</div><div class="line">                        <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Pass back the lbmmon_transport_udp_src_t created */</span></div><div class="line">        *TransportClientData = data;</div><div class="line">        <span class="keywordflow">return</span> (0);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">lbmmon_transport_udp_initrcv(<span class="keywordtype">void</span> * * TransportClientData, <span class="keyword">const</span> <span class="keywordtype">void</span> * TransportOptions)</div><div class="line">{</div><div class="line">        lbmmon_transport_udp_rcv_t * data;</div><div class="line">        <span class="keywordtype">int</span> rc;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span> * ptr = (<span class="keyword">const</span> <span class="keywordtype">char</span> *) TransportOptions;</div><div class="line">        <span class="keywordtype">char</span> key[512];</div><div class="line">        <span class="keywordtype">char</span> value[512];</div><div class="line">        <span class="keywordtype">char</span> port[512];</div><div class="line">        <span class="keywordtype">char</span> interface[512];</div><div class="line">        <span class="keywordtype">char</span> mcgroup[512];</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> port_value;</div><div class="line">        <span class="keyword">struct </span>in_addr multicast_group;</div><div class="line">        <span class="keyword">struct </span>in_addr multicast_interface;</div><div class="line"></div><div class="line">        memset(ErrorString, 0, <span class="keyword">sizeof</span>(ErrorString));</div><div class="line">        data = malloc(<span class="keyword">sizeof</span>(lbmmon_transport_udp_rcv_t));</div><div class="line">        <span class="keywordflow">if</span> (data == NULL)</div><div class="line">        {</div><div class="line">                lbmmon_transport_udp_report_allocation_error(<span class="keyword">sizeof</span>(lbmmon_transport_udp_rcv_t));</div><div class="line">                <span class="keywordflow">return</span> (-1);</div><div class="line">        }</div><div class="line">        multicast_group.s_addr = 0;</div><div class="line">        multicast_interface.s_addr = 0;</div><div class="line">        data-&gt;mHead = NULL;</div><div class="line">        data-&gt;mTail = NULL;</div><div class="line">        data-&gt;mTerminateThread = 0;</div><div class="line"></div><div class="line">        <span class="comment">/* Process any options */</span></div><div class="line">        memset(port, 0, <span class="keyword">sizeof</span>(port));</div><div class="line">        strcpy(port, DEFAULT_PORT);</div><div class="line">        memset(interface, 0, <span class="keyword">sizeof</span>(interface));</div><div class="line">        strcpy(interface, DEFAULT_INTERFACE);</div><div class="line">        memset(mcgroup, 0, <span class="keyword">sizeof</span>(mcgroup));</div><div class="line">        data-&gt;mMode = MODE_UNICAST;</div><div class="line">        <span class="keywordflow">while</span> ((ptr = <a class="code" href="lbmmon_8h.html#a92cdb7dc9ffbf2d68742d3762b974073">lbmmon_next_key_value_pair</a>(ptr, key, <span class="keyword">sizeof</span>(key), value, <span class="keyword">sizeof</span>(value))) != NULL)</div><div class="line">        {</div><div class="line">                <span class="keywordflow">if</span> (strcasecmp(key, <span class="stringliteral">&quot;port&quot;</span>) == 0)</div><div class="line">                {</div><div class="line">                        strncpy(port, value, <span class="keyword">sizeof</span>(port));</div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp(key, <span class="stringliteral">&quot;interface&quot;</span>) == 0)</div><div class="line">                {</div><div class="line">                        strncpy(interface, value, <span class="keyword">sizeof</span>(interface));</div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp(key, <span class="stringliteral">&quot;mcgroup&quot;</span>) == 0)</div><div class="line">                {</div><div class="line">                        strncpy(mcgroup, value, <span class="keyword">sizeof</span>(mcgroup));</div><div class="line">                }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/*      Validate the options</span></div><div class="line"><span class="comment">                Note the following:</span></div><div class="line"><span class="comment">                - interface only applies to mcgroup</span></div><div class="line"><span class="comment">                - mcgroup (and thus multicast) takes precedence over broadcast/unicast</span></div><div class="line"><span class="comment">        */</span></div><div class="line">        port_value = strtoul(port, NULL, 0);</div><div class="line">        <span class="keywordflow">if</span> ((port_value == ULONG_MAX) &amp;&amp; (errno == ERANGE))</div><div class="line">        {</div><div class="line">                strncpy(ErrorString, <span class="stringliteral">&quot;Invalid port value&quot;</span>, <span class="keyword">sizeof</span>(ErrorString));</div><div class="line">                free(data);</div><div class="line">                <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (port_value &gt; USHRT_MAX)</div><div class="line">        {</div><div class="line">                strncpy(ErrorString, <span class="stringliteral">&quot;Invalid port value&quot;</span>, <span class="keyword">sizeof</span>(ErrorString));</div><div class="line">                free(data);</div><div class="line">                <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (mcgroup[0] != <span class="charliteral">&#39;\0&#39;</span>)</div><div class="line">        {</div><div class="line">                data-&gt;mMode = MODE_MULTICAST;</div><div class="line">                multicast_group.s_addr = inet_addr(mcgroup);</div><div class="line">                <span class="keywordflow">if</span> (multicast_group.s_addr == INADDR_NONE)</div><div class="line">                {</div><div class="line">                        strncpy(ErrorString, <span class="stringliteral">&quot;Invalid mcgroup value&quot;</span>, <span class="keyword">sizeof</span>(ErrorString));</div><div class="line">                        free(data);</div><div class="line">                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);</div><div class="line">                }</div><div class="line">                <span class="keywordflow">if</span> (!IN_MULTICAST(ntohl(multicast_group.s_addr)))</div><div class="line">                {</div><div class="line">                        strncpy(ErrorString, <span class="stringliteral">&quot;Invalid mcgroup value&quot;</span>, <span class="keyword">sizeof</span>(ErrorString));</div><div class="line">                        free(data);</div><div class="line">                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);</div><div class="line">                }</div><div class="line">                multicast_interface.s_addr = inet_addr(interface);</div><div class="line">                <span class="keywordflow">if</span> (multicast_interface.s_addr == INADDR_NONE)</div><div class="line">                {</div><div class="line">                        strncpy(ErrorString, <span class="stringliteral">&quot;Invalid interface value&quot;</span>, <span class="keyword">sizeof</span>(ErrorString));</div><div class="line">                        free(data);</div><div class="line">                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);</div><div class="line">                }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Create the socket */</span></div><div class="line">        data-&gt;mSocket = socket(PF_INET, SOCK_DGRAM, 0);</div><div class="line">        <span class="keywordflow">if</span> (data-&gt;mSocket == LBMMON_INVALID_HANDLE)</div><div class="line">        {</div><div class="line">                snprintf(ErrorString,</div><div class="line">                                 <span class="keyword">sizeof</span>(ErrorString),</div><div class="line">                                 <span class="stringliteral">&quot;socket() failed, %s&quot;</span>,</div><div class="line">                                 last_socket_error());</div><div class="line">                free(data);</div><div class="line">                <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_SOCKET);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Build the interface sockaddr_in. */</span></div><div class="line">        memset(&amp;(data-&gt;mInterface), 0, <span class="keyword">sizeof</span>(data-&gt;mInterface));</div><div class="line">        data-&gt;mInterface.sin_family = AF_INET;</div><div class="line">        data-&gt;mInterface.sin_port = htons((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>) port_value);</div><div class="line">        data-&gt;mInterface.sin_addr.s_addr = INADDR_ANY;</div><div class="line"></div><div class="line">        <span class="comment">/* Bind the socket. */</span></div><div class="line">        rc = bind(data-&gt;mSocket, (<span class="keyword">struct</span> sockaddr *) &amp;(data-&gt;mInterface), <span class="keyword">sizeof</span>(data-&gt;mInterface));</div><div class="line">        <span class="keywordflow">if</span> (rc == LBMMON_SOCKET_ERROR)</div><div class="line">        {</div><div class="line">                snprintf(ErrorString,</div><div class="line">                                 <span class="keyword">sizeof</span>(ErrorString),</div><div class="line">                                 <span class="stringliteral">&quot;bind() failed, %s&quot;</span>,</div><div class="line">                                 last_socket_error());</div><div class="line"><span class="preprocessor">#ifdef _WIN32</span></div><div class="line">                        closesocket(data-&gt;mSocket);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">                        close(data-&gt;mSocket);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_SOCKET);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* For multicast, join the group. */</span></div><div class="line">        <span class="keywordflow">if</span> (data-&gt;mMode == MODE_MULTICAST)</div><div class="line">        {</div><div class="line">                data-&gt;mMulticastMembership.imr_interface.s_addr = multicast_interface.s_addr;</div><div class="line">                data-&gt;mMulticastMembership.imr_multiaddr.s_addr = multicast_group.s_addr;</div><div class="line">                rc = setsockopt(data-&gt;mSocket, IPPROTO_IP, IP_ADD_MEMBERSHIP, (<span class="keywordtype">void</span> *) &amp;(data-&gt;mMulticastMembership), <span class="keyword">sizeof</span>(data-&gt;mMulticastMembership));</div><div class="line">                <span class="keywordflow">if</span> (rc == LBMMON_SOCKET_ERROR)</div><div class="line">                {</div><div class="line">                        snprintf(ErrorString,</div><div class="line">                                         <span class="keyword">sizeof</span>(ErrorString),</div><div class="line">                                         <span class="stringliteral">&quot;setsockopt(...,IP_ADD_MEMBERSHIP,...) failed, %s&quot;</span>,</div><div class="line">                                         last_socket_error());</div><div class="line"><span class="preprocessor">#ifdef _WIN32</span></div><div class="line">                        closesocket(data-&gt;mSocket);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">                        close(data-&gt;mSocket);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">                        free(data);</div><div class="line">                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_SOCKET);</div><div class="line">                }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Build the peer sockaddr_in. */</span></div><div class="line">        data-&gt;mPeer.sin_family = AF_INET;</div><div class="line">        data-&gt;mPeer.sin_port = htons((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>) port_value);</div><div class="line">        data-&gt;mPeer.sin_addr.s_addr = INADDR_ANY;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef _WIN32</span></div><div class="line">        InitializeCriticalSection(&amp;(data-&gt;mLock));</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        pthread_mutex_init(&amp;(data-&gt;mLock), NULL);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">        <span class="comment">/* Start the receive thread */</span></div><div class="line"><span class="preprocessor">#ifdef _WIN32</span></div><div class="line">        data-&gt;mThread = CreateThread(NULL, 0, receive_thread_proc, data, 0, NULL);</div><div class="line">        <span class="keywordflow">if</span> (data-&gt;mThread == NULL)</div><div class="line">        {</div><div class="line">                snprintf(ErrorString,</div><div class="line">                                 <span class="keyword">sizeof</span>(ErrorString),</div><div class="line">                                 <span class="stringliteral">&quot;CreateThread() failed, error %d&quot;</span>,</div><div class="line">                                 GetLastError());</div><div class="line">                closesocket(data-&gt;mSocket);</div><div class="line">                free(data);</div><div class="line">                <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_THREAD);</div><div class="line">        }</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="preprocessor">#ifdef __VOS__</span></div><div class="line">        {</div><div class="line">                pthread_attr_t pth_attr;</div><div class="line">                pthread_attr_init (&amp;pth_attr);</div><div class="line">                pthread_attr_setschedpolicy (&amp;pth_attr, SCHED_RR);</div><div class="line">                rc = pthread_create(&amp;(data-&gt;mThread), &amp;pth_attr, receive_thread_proc, data);</div><div class="line">        }</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        rc = pthread_create(&amp;(data-&gt;mThread), NULL, receive_thread_proc, data);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        <span class="keywordflow">if</span> (rc != 0)</div><div class="line">        {</div><div class="line">                snprintf(ErrorString,</div><div class="line">                                 <span class="keyword">sizeof</span>(ErrorString),</div><div class="line">                                 <span class="stringliteral">&quot;pthread_create() failed, error %d, %s&quot;</span>,</div><div class="line">                                 rc,</div><div class="line">                                 strerror(rc));</div><div class="line">                close(data-&gt;mSocket);</div><div class="line">                free(data);</div><div class="line">                <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_THREAD);</div><div class="line">        }</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">        <span class="comment">/* Pass back the lbmmon_transport_udp_rcv_t created */</span></div><div class="line">        *TransportClientData = data;</div><div class="line">        <span class="keywordflow">return</span> (0);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef _WIN32</span></div><div class="line">DWORD WINAPI</div><div class="line">receive_thread_proc(<span class="keywordtype">void</span> * Arg)</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="keywordtype">void</span> *</div><div class="line">receive_thread_proc(<span class="keywordtype">void</span> * Arg)</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">{</div><div class="line">        lbmmon_transport_udp_rcv_t * rcv = (lbmmon_transport_udp_rcv_t *) Arg;</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buffer[8192];</div><div class="line">        <span class="keyword">struct </span>timeval timeout;</div><div class="line">        fd_set readfds;</div><div class="line">        <span class="keywordtype">int</span> rc;</div><div class="line">        ssize_t bytes_read;</div><div class="line">        lbmmon_transport_udp_rcv_node_t * node;</div><div class="line"></div><div class="line">        <span class="keywordflow">while</span> (rcv-&gt;mTerminateThread == 0)</div><div class="line">        {</div><div class="line">                FD_ZERO(&amp;readfds);</div><div class="line">                FD_SET(rcv-&gt;mSocket, &amp;readfds);</div><div class="line">                timeout.tv_sec = 0;</div><div class="line">                timeout.tv_usec = 500000;</div><div class="line">                rc = select(rcv-&gt;mSocket + 1, &amp;readfds, NULL, NULL, &amp;timeout);</div><div class="line">                <span class="keywordflow">if</span> (rc &lt;= 0)</div><div class="line">                {</div><div class="line">                        <span class="keywordflow">continue</span>;</div><div class="line">                }</div><div class="line">                bytes_read = recvfrom(rcv-&gt;mSocket, buffer, <span class="keyword">sizeof</span>(buffer), 0, NULL, NULL);</div><div class="line">                <span class="keywordflow">if</span> (bytes_read == LBMMON_SOCKET_ERROR)</div><div class="line">                {</div><div class="line">                        <span class="keywordflow">continue</span>;</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="comment">/* A data message. We want to enqueue it for processing. */</span></div><div class="line">                lock_receiver(rcv);</div><div class="line">                node = malloc(<span class="keyword">sizeof</span>(lbmmon_transport_udp_rcv_node_t));</div><div class="line">                <span class="keywordflow">if</span> (node == NULL)</div><div class="line">                {</div><div class="line">                        lbmmon_transport_udp_report_allocation_error(<span class="keyword">sizeof</span>(lbmmon_transport_udp_rcv_node_t));</div><div class="line">                        <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line">                node-&gt;mMessage = malloc((<span class="keywordtype">size_t</span>) bytes_read);</div><div class="line">                <span class="keywordflow">if</span> (node-&gt;mMessage == NULL)</div><div class="line">                {</div><div class="line">                        lbmmon_transport_udp_report_allocation_error(bytes_read);</div><div class="line">                        <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line">                memcpy(node-&gt;mMessage, buffer, (<span class="keywordtype">size_t</span>) bytes_read);</div><div class="line">                node-&gt;mMessageLength = (size_t) bytes_read;</div><div class="line">                node-&gt;mUsedBytes = 0;   <span class="comment">/* No data returned as yet */</span></div><div class="line"></div><div class="line">                <span class="comment">/* Link the message onto the queue */</span></div><div class="line">                node-&gt;mNext = NULL;</div><div class="line">                <span class="keywordflow">if</span> (rcv-&gt;mTail != NULL)</div><div class="line">                {</div><div class="line">                        rcv-&gt;mTail-&gt;mNext = node;</div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                {</div><div class="line">                        rcv-&gt;mHead = node;</div><div class="line">                }</div><div class="line">                rcv-&gt;mTail = node;</div><div class="line">                unlock_receiver(rcv);</div><div class="line">        }</div><div class="line"><span class="preprocessor">#ifdef _WIN32</span></div><div class="line">        <span class="keywordflow">return</span> (0);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        <span class="keywordflow">return</span> (NULL);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">lbmmon_transport_udp_send(<span class="keyword">const</span> <span class="keywordtype">char</span> * Data, <span class="keywordtype">size_t</span> Length, <span class="keywordtype">void</span> * TransportClientData)</div><div class="line">{</div><div class="line">        lbmmon_transport_udp_src_t * src;</div><div class="line">        <span class="keywordtype">int</span> rc;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((Data == NULL) || (TransportClientData == NULL))</div><div class="line">        {</div><div class="line">                <span class="keywordflow">return</span> (-1);</div><div class="line">        }</div><div class="line">        src = (lbmmon_transport_udp_src_t *) TransportClientData;</div><div class="line">        rc = sendto(src-&gt;mSocket, Data, Length, 0, (<span class="keyword">struct</span> sockaddr *) &amp;(src-&gt;mPeer), <span class="keyword">sizeof</span>(src-&gt;mPeer));</div><div class="line">        <span class="keywordflow">if</span> (rc == LBMMON_SOCKET_ERROR)</div><div class="line">        {</div><div class="line">                snprintf(ErrorString,</div><div class="line">                                 <span class="keyword">sizeof</span>(ErrorString),</div><div class="line">                                 <span class="stringliteral">&quot;sendto() failed, %s&quot;</span>,</div><div class="line">                                 last_socket_error());</div><div class="line">                <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_SEND);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> (0);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">lbmmon_transport_udp_receive(<span class="keywordtype">char</span> * Data, <span class="keywordtype">size_t</span> * Length, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> TimeoutMS, <span class="keywordtype">void</span> * TransportClientData)</div><div class="line">{</div><div class="line">        lbmmon_transport_udp_rcv_t * rcv = (lbmmon_transport_udp_rcv_t *) TransportClientData;</div><div class="line">        lbmmon_transport_udp_rcv_node_t * node;</div><div class="line">        <span class="keywordtype">int</span> rc = 0;</div><div class="line">        <span class="keywordtype">size_t</span> length_remaining;</div><div class="line"><span class="preprocessor">#if defined(_WIN32)</span></div><div class="line"><span class="preprocessor">#elif defined(__TANDEM)</span></div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sleep_sec;</div><div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sleep_usec;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        <span class="keyword">struct </span>timespec ivl;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((Data == NULL) || (Length == NULL) || (TransportClientData == NULL))</div><div class="line">        {</div><div class="line">                <span class="keywordflow">return</span> (-1);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (*Length == 0)</div><div class="line">        {</div><div class="line">                <span class="keywordflow">return</span> (0);</div><div class="line">        }</div><div class="line">        lock_receiver(rcv);</div><div class="line">        <span class="keywordflow">if</span> (rcv-&gt;mHead != NULL)</div><div class="line">        {</div><div class="line">                <span class="comment">/* Queue is non-empty. Pull the first message from the queue. */</span></div><div class="line">                node = rcv-&gt;mHead;</div><div class="line">                length_remaining = node-&gt;mMessageLength - node-&gt;mUsedBytes;</div><div class="line">                <span class="keywordflow">if</span> (*Length &gt;= length_remaining)</div><div class="line">                {</div><div class="line">                        <span class="comment">/* We can transfer the rest of the message */</span></div><div class="line">                        memcpy(Data, node-&gt;mMessage + node-&gt;mUsedBytes, length_remaining);</div><div class="line">                        *Length = length_remaining;</div><div class="line">                        rc = 0;</div><div class="line">                        <span class="comment">/* We&#39;re done with the message, so free it. */</span></div><div class="line">                        free(node-&gt;mMessage);</div><div class="line">                        node-&gt;mMessage = NULL;</div><div class="line">                        <span class="comment">/* Unlink the node from the queue */</span></div><div class="line">                        rcv-&gt;mHead = node-&gt;mNext;</div><div class="line">                        <span class="keywordflow">if</span> (rcv-&gt;mHead == NULL)</div><div class="line">                        {</div><div class="line">                                rcv-&gt;mTail = NULL;</div><div class="line">                        }</div><div class="line">                        free(node);</div><div class="line">                }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                {</div><div class="line">                        <span class="comment">/* MSGDESC: The monitoring message received is larger than the maximum allowed size given.</span></div><div class="line"><span class="comment">                         * MSGRES: This is a hard coded maximum. */</span></div><div class="line">                        <a class="code" href="lbm_8h.html#aaa36f4dcd32603a33c0a2c129dd2c3aa">lbm_logf</a>(<a class="code" href="lbm_8h.html#a5924551ebcb0e0cc96ddacb76c60de24">LBM_LOG_ERR</a>, <span class="stringliteral">&quot;Core-8034-2: [LBMMON] Dropping monitoring message that is larger than the maximum allowed size of %d (size=%d)&quot;</span>,</div><div class="line">                                                        *Length, node-&gt;mMessageLength);</div><div class="line">                        <span class="comment">/* We&#39;re done with the message, so free it. */</span></div><div class="line">                        free(node-&gt;mMessage);</div><div class="line">                        node-&gt;mMessage = NULL;</div><div class="line">                        <span class="comment">/* Unlink the node from the queue */</span></div><div class="line">                        rcv-&gt;mHead = node-&gt;mNext;</div><div class="line">                        <span class="keywordflow">if</span> (rcv-&gt;mHead == NULL)</div><div class="line">                        {</div><div class="line">                                rcv-&gt;mTail = NULL;</div><div class="line">                        }</div><div class="line">                        free(node);</div><div class="line">                        rc = 1; <span class="comment">/* Positive number prevents caller from logging message too */</span></div><div class="line">                }</div><div class="line">                unlock_receiver(rcv);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">                unlock_receiver(rcv);</div><div class="line">                <span class="comment">/* Sleep for wait time */</span></div><div class="line"><span class="preprocessor">#define NANOSECONDS_PER_SECOND 1000000000</span></div><div class="line"><span class="preprocessor">#define MICROSECONDS_PER_SECOND 1000000</span></div><div class="line"><span class="preprocessor">#define MILLISECONDS_PER_SECOND 1000</span></div><div class="line"><span class="preprocessor">#define NANOSECONDS_PER_MILLISECOND (NANOSECONDS_PER_SECOND / MILLISECONDS_PER_SECOND)</span></div><div class="line"><span class="preprocessor">#define MICROSECONDS_PER_MILLISECOND (MICROSECONDS_PER_SECOND / MILLISECONDS_PER_SECOND)</span></div><div class="line"><span class="preprocessor">#if defined(_WIN32)</span></div><div class="line">                Sleep(TimeoutMS);</div><div class="line"><span class="preprocessor">#elif defined(__TANDEM)</span></div><div class="line">                sleep_sec = TimeoutMS / MILLISECONDS_PER_SECOND;</div><div class="line">                sleep_usec = (TimeoutMS % MILLISECONDS_PER_SECOND) * MICROSECONDS_PER_MILLISECOND;</div><div class="line">                <span class="keywordflow">if</span> (sleep_usec &gt; 0)</div><div class="line">                {</div><div class="line">                        usleep(sleep_usec);</div><div class="line">                }</div><div class="line">                <span class="keywordflow">if</span> (sleep_sec &gt; 0)</div><div class="line">                {</div><div class="line">                        sleep(sleep_sec);</div><div class="line">                }</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">                ivl.tv_sec = TimeoutMS / MILLISECONDS_PER_SECOND;</div><div class="line">                ivl.tv_nsec = (TimeoutMS % MILLISECONDS_PER_SECOND) * NANOSECONDS_PER_MILLISECOND;</div><div class="line">                nanosleep(&amp;ivl, NULL);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">                rc = 1;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> (rc);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">lbmmon_transport_udp_src_finish(<span class="keywordtype">void</span> * TransportClientData)</div><div class="line">{</div><div class="line">        lbmmon_transport_udp_src_t * src;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (TransportClientData == NULL)</div><div class="line">        {</div><div class="line">                strncpy(ErrorString, <span class="stringliteral">&quot;Invalid parameter&quot;</span>, <span class="keyword">sizeof</span>(ErrorString));</div><div class="line">                <span class="keywordflow">return</span> (-1);</div><div class="line">        }</div><div class="line">        src = (lbmmon_transport_udp_src_t *) TransportClientData;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef _WIN32</span></div><div class="line">        closesocket(src-&gt;mSocket);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        close(src-&gt;mSocket);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        <span class="comment">/* Clean up our data */</span></div><div class="line">        free(TransportClientData);</div><div class="line">        <span class="keywordflow">return</span> (0);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">lbmmon_transport_udp_rcv_finish(<span class="keywordtype">void</span> * TransportClientData)</div><div class="line">{</div><div class="line">        lbmmon_transport_udp_rcv_t * rcv = (lbmmon_transport_udp_rcv_t *) TransportClientData;</div><div class="line">        lbmmon_transport_udp_rcv_node_t * node;</div><div class="line">        lbmmon_transport_udp_rcv_node_t * next;</div><div class="line"></div><div class="line">        <span class="comment">/* Stop the thread to prevent any more incoming messages */</span></div><div class="line">        rcv-&gt;mTerminateThread = 1;</div><div class="line"></div><div class="line">        <span class="comment">/* Lock the receiver */</span></div><div class="line">        lock_receiver(rcv);</div><div class="line"></div><div class="line">        <span class="comment">/* Clean out the queue */</span></div><div class="line">        node = rcv-&gt;mHead;</div><div class="line">        <span class="keywordflow">while</span> (node != NULL)</div><div class="line">        {</div><div class="line">                <span class="comment">/* Let LBM know we&#39;re done with the message */</span></div><div class="line">                free(node-&gt;mMessage);</div><div class="line">                next = node-&gt;mNext;</div><div class="line">                free(node);</div><div class="line">                node = next;</div><div class="line">        }</div><div class="line"></div><div class="line">        unlock_receiver(rcv);</div><div class="line"></div><div class="line">        <span class="comment">/* If multicast, drop membership. */</span></div><div class="line">        <span class="keywordflow">if</span> (rcv-&gt;mMode == MODE_MULTICAST)</div><div class="line">        {</div><div class="line">                (void) setsockopt(rcv-&gt;mSocket, IPPROTO_IP, IP_DROP_MEMBERSHIP, (<span class="keywordtype">void</span> *) &amp;(rcv-&gt;mMulticastMembership), <span class="keyword">sizeof</span>(rcv-&gt;mMulticastMembership));</div><div class="line">        }</div><div class="line"><span class="preprocessor">#ifdef _WIN32</span></div><div class="line">        closesocket(rcv-&gt;mSocket);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        close(rcv-&gt;mSocket);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">#ifdef _WIN32</span></div><div class="line">        DeleteCriticalSection(&amp;(rcv-&gt;mLock));</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        pthread_mutex_destroy(&amp;(rcv-&gt;mLock));</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">        free(TransportClientData);</div><div class="line">        <span class="keywordflow">return</span> (0);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">lock_receiver(lbmmon_transport_udp_rcv_t * Receiver)</div><div class="line">{</div><div class="line"><span class="preprocessor">#ifdef _WIN32</span></div><div class="line">        EnterCriticalSection(&amp;(Receiver-&gt;mLock));</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        pthread_mutex_lock(&amp;(Receiver-&gt;mLock));</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">unlock_receiver(lbmmon_transport_udp_rcv_t * Receiver)</div><div class="line">{</div><div class="line"><span class="preprocessor">#ifdef _WIN32</span></div><div class="line">        LeaveCriticalSection(&amp;(Receiver-&gt;mLock));</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        pthread_mutex_unlock(&amp;(Receiver-&gt;mLock));</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *</div><div class="line">lbmmon_transport_udp_errmsg(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">        <span class="keywordflow">return</span> (ErrorString);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="lbmmon_examples.html">LBMMON Example source code</a></li><li class="navelem"><a class="el" href="lbmmon_udp_transport.html">LBMMON UDP transport module</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
