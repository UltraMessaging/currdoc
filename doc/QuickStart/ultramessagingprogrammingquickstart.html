<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Quick Start Guide: Ultra Messaging Programming Quick Start</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen_manual.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Quick Start Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('ultramessagingprogrammingquickstart.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Ultra Messaging Programming Quick Start </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The C programs below contain the minimum code and supporting material. Their purpose is to verify that the user's build and run-time environments are set up correctly. They also give a basic introduction to the Ultra Messaging API.</p>
<p>We also have equivalent Java and C# programs available in source form. See <a href="../java_example/MinSrc.java">MinSrc.java</a> and <a href="../java_example/MinRcv.java">MinRcv.java</a> or <a href="../dotnet_example/MinSrc.cs">MinSrc.cs</a> and <a href="../dotnet_example/MinRcv.cs">MinRcv.cs</a>. We also have an example of how application callbacks are coded in C++ programs. See <a href="../example/minrcv.cpp">minrcv.cpp</a>.</p>
<p>(Most browsers let you right-click on a link and use the "save link target" function, or some variation.)</p>
<p>Note that these programs do not allow the user to override any of the default configuration values. As a result, operation is fixed according to the normal LBM defaults; for example TCP is the transport protocol, topic resolution is performed using multicast, etc. See the <a href="../Config/index.html">Ultra Messaging Configuration Guide</a>.</p>
<p>The Source Code Examples tab on the left panel provides a much richer set of source files that use a wide variety of features. However, those programs double as performance testing tools, so they tend to be more complex than just demonstrating the features. We recommend to first build and run these minimal examples.</p>
<p>This source code example is provided by Informatica for educational and evaluation purposes only.</p>
<p>Error handling in these programs is primitive. A production program would want to have better error handling, but for the purposes of a minimal example, it would just be a distraction. Also, a production program would want to support a configuration file to override default values on options.</p>
<p><br />
 </p>
<h1><a class="anchor" id="buildingnoteswindows"></a>
Building Notes: Windows</h1>
<p>When building on Windows, the following notes are applicable.</p>
<ul>
<li>
<p class="startli">Make sure the preprocessor variable "WIN32" is defined.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Add the '<code>...\include\lbm</code>' (under the package install directory) as an additional include directory.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Add lbm.lib and wsock32.lib as Object/library modules.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Add the '<code>...\lib</code>' as an additional library path.</p>
<p class="endli"></p>
</li>
<li>
The install procedure should already have added the LBM bin directory to the Windows PATH. This is necessary so that <code>lbm.dll</code> can be found when a program is run. </li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="buildingnotesunix"></a>
Building Notes: Unix</h1>
<p>When building on Unix, the following notes are applicable.</p>
<ul>
<li>
<p class="startli">Sample build command: </p><pre class="fragment">cc -I$HOME/lbm/&lt;VERS&gt;/&lt;PLATFORM&gt;/include
   -L$HOME/lbm/&lt;VERS&gt;/&lt;PLATFORM&gt;/lib -llbm -lm -o min_src min_src.c
</pre><p> (This should be all one line.)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The appropriate library search path should be updated to include the Ultra Messaging <code>lib/</code> directory. For example, on Linux:</p>
<pre class="fragment">LD_LIBRARY_PATH="$HOME/lbm/&lt;VERS&gt;/&lt;PLATFORM&gt;/lib:$LD_LIBRARY_PATH"
export LD_LIBRARY_PATH
</pre><p class="endli">(For other flavors of Unix, see <a href="http://bhami.com/rosetta.html">http://bhami.com/rosetta.html</a>.) Alternatively, the shared library can be copied from the LBM <code>lib/</code> directory to a directory which is already in the library search path. </p>
</li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="minimalultramessagingsourceimplementation"></a>
Minimal Ultra Messaging Source Implementation</h1>
<p>This is a source code listing of a minimal source (sender) program. Examples also include equivalent Java and C# programs available in source form. See <a href="../java_example/MinSrc.java">MinSrc.java</a> and <a href="../dotnet_example/MinSrc.cs">MinSrc.cs</a>.</p>
<pre class="fragment">/*
"minsrc.c: minimal application that sends to a given topic.
 *
 * Copyright (c) 2005-2018 Informatica Corporation. All Rights Reserved.
 * Permission is granted to licensees to use
 * or alter this software for any purpose, including commercial applications,
 * according to the terms laid out in the Software License Agreement.
 *
 * This source code example is provided by Informatica for educational
 * and evaluation purposes only.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND INFORMATICA DISCLAIMS ALL WARRANTIES
 * EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY IMPLIED WARRANTIES OF
 * NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
 * PURPOSE.  INFORMATICA DOES NOT WARRANT THAT USE OF THE SOFTWARE WILL BE
 * UNINTERRUPTED OR ERROR-FREE.  INFORMATICA SHALL NOT, UNDER ANY CIRCUMSTANCES, BE
 * LIABLE TO LICENSEE FOR LOST PROFITS, CONSEQUENTIAL, INCIDENTAL, SPECIAL OR
 * INDIRECT DAMAGES ARISING OUT OF OR RELATED TO THIS AGREEMENT OR THE
 * TRANSACTIONS CONTEMPLATED HEREUNDER, EVEN IF INFORMATICA HAS BEEN APPRISED OF
 * THE LIKELIHOOD OF SUCH DAMAGES.
 */

/* Explanatory notes referenced in this file are in the Quick Start guide. */

#include &lt;stdio.h&gt;

#if defined(_MSC_VER)
/* Windows-only includes */
#include &lt;winsock2.h&gt;
#define SLEEP(s) Sleep((s)*1000)
#else
/* Unix-only includes */
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#define SLEEP(s) sleep(s)
#endif

#include &lt;lbm/lbm.h&gt;

main()
{
  lbm_context_t *ctx;    /* pointer to context object */
  lbm_topic_t *topic;    /* pointer to topic object */
  lbm_src_t *src;        /* pointer to source (sender) object */
  int err;               /* return status of lbm functions (true=error) */

#if defined(_MSC_VER)
  /* windows-specific code */
  WSADATA wsadata;
  int wsStat = WSAStartup(MAKEWORD(2,2), &amp;wsadata);
  if (wsStat != 0) {
    printf("line %d: wsStat=%d\n",__LINE__,wsStat); exit(1);
  }
#endif

  err = lbm_context_create(&amp;ctx, NULL, NULL, NULL);  /* See Note #1 */
  if (err) {
    printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);
  }

  err = lbm_src_topic_alloc(&amp;topic, ctx, "Greeting", NULL);  /* See Note #2 */
  if (err) {
    printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);
  }

  err = lbm_src_create(&amp;src, ctx, topic, NULL, NULL, NULL);  /* See Note #3 */
  if (err) {
    printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);
  }

  SLEEP(1);  /* See Note #4 */

  err = lbm_src_send(src, "Hello!", 6, LBM_MSG_FLUSH | LBM_SRC_BLOCK);  /* See Note #5 */
  if (err) {
    printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);
  }

  SLEEP(2);  /* See Note #6 */

  /* Finished all sending to this topic, delete the source object. */

  err = lbm_src_delete(src);

  /* Do not need to delete the topic object - LBM keeps track of topic
   * objects and deletes them as-needed.  */

  /* Finished with all LBM functions, delete the context object. */
  err = lbm_context_delete(ctx);

#if defined(_MSC_VER)
  WSACleanup();
#endif
}  /* main */</pre><p>Notes:</p>
<ol>
<li>
<p class="startli">Create a context object. A context is an environment in which LBM functions. Note that the first parameter is a pointer to a pointer variable; <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/QuickStart/api.tag:../API/" href="../API/lbm_8h.html#a8058947690bd0995bc2c59d4a61b462f">lbm_context_create()</a> writes the pointer to the context object into "ctx". Also, by passing NULL to the context attribute parameter, the default option values are used. For most applications only a single context is required regardless of how many sources and receivers are created.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Allocate a topic object. A topic object is little more than a string (the topic name). During operation, LBM keeps some state information in the topic object as well. The topic is bound to the containing context, and will also be bound to a source object. Note that the first parameter is a pointer to a pointer variable; <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/QuickStart/api.tag:../API/" href="../API/lbm_8h.html#a1ba60407fa2bde0997aab6d5a5d2da1a">lbm_src_topic_alloc()</a> writes the pointer to the topic object into "topic". Also, by passing NULL to the source topic attribute, the default option values are used. The string "Greeting" is the topic string.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Create the source object. A source object is used to send messages. It must be bound to a topic. Note that the first parameter is a pointer to a pointer variable; <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/QuickStart/api.tag:../API/" href="../API/lbm_8h.html#ab8dd76271bf9df7a5f88476d431f523e">lbm_src_create()</a> writes the pointer to the source object to into "src". Use of the third and fourth parameters is optional but recommended in a production program - some source events can be important to the application. The last parameter is an optional event queue (not used in this example).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Need to wait for receivers to find us before first send. There are other ways to accomplish this, but sleep is easy. See <a href="https://kb.informatica.com/faq/5/Pages/80061.aspx">Avoiding or Minimizing Delay Before Sending</a> for details.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Send a message to the "Greeting" topic. The flags make sure the call to <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/QuickStart/api.tag:../API/" href="../API/lbm_8h.html#a91f4b9cb04fe1323ec56833211cc5cb7">lbm_src_send()</a> doesn't return until the message is sent. Note that while this ensures low latency, flushing every message carries a heavy efficiency cost. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/QuickStart/design.tag:../Design/" href="../Design/architecture.html#intelligentbatching">Intelligent Batching</a> for more information.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">For some transport types (mostly UDP-based), a short delay before deleting the source is advisable. Even though the message is sent, there may have been packet loss, and some transports need a bit of time to request re-transmission. Also, if the above <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/QuickStart/api.tag:../API/" href="../API/lbm_8h.html#a91f4b9cb04fe1323ec56833211cc5cb7">lbm_src_send()</a> call didn't include the flush, some time might also be needed to empty the batching buffer.</p>
<p class="endli"><br />
 </p>
</li>
</ol>
<h1><a class="anchor" id="minimalultramessagingreceiverimplementation"></a>
Minimal Ultra Messaging Receiver Implementation</h1>
<p>This is a source code listing of a minimal receiver program. Examples also include equivalent Java, C#, and C++ programs available in source form. See <a href="../java_example/MinRcv.java">MinRcv.java</a>, <a href="../dotnet_example/MinRcv.cs">MinRcv.cs</a>, and <a href="../example/minrcv.cpp">minrcv.cpp</a>.</p>
<pre class="fragment">/*
"minrcv.c: minimal application that receives messages from a given topic.
 *
 * Copyright (c) 2005-2018 Informatica Corporation. All Rights Reserved.
 * Permission is granted to licensees to use
 * or alter this software for any purpose, including commercial applications,
 * according to the terms laid out in the Software License Agreement.
 *
 * This source code example is provided by Informatica for educational
 * and evaluation purposes only.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND INFORMATICA DISCLAIMS ALL WARRANTIES
 * EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY IMPLIED WARRANTIES OF
 * NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
 * PURPOSE.  INFORMATICA DOES NOT WARRANT THAT USE OF THE SOFTWARE WILL BE
 * UNINTERRUPTED OR ERROR-FREE.  INFORMATICA SHALL NOT, UNDER ANY CIRCUMSTANCES, BE
 * LIABLE TO LICENSEE FOR LOST PROFITS, CONSEQUENTIAL, INCIDENTAL, SPECIAL OR
 * INDIRECT DAMAGES ARISING OUT OF OR RELATED TO THIS AGREEMENT OR THE
 * TRANSACTIONS CONTEMPLATED HEREUNDER, EVEN IF INFORMATICA HAS BEEN APPRISED OF
 * THE LIKELIHOOD OF SUCH DAMAGES.
 */

/* Explanatory notes referenced in this file are in the Quick Start guide. */

#include &lt;stdio.h&gt;

#if defined(_MSC_VER)
/* Windows-only includes */
#include &lt;winsock2.h&gt;
#define SLEEP(s) Sleep((s)*1000)
#else
/* Unix-only includes */
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#define SLEEP(s) sleep(s)
#endif

#include &lt;lbm/lbm.h&gt;

/*
 * A global variable is used to communicate from the receiver callback to
 * the main application thread.
 */
int msgs_rcvd = 0;

int app_rcv_callback(lbm_rcv_t *rcv, lbm_msg_t *msg, void *clientd)  /* See Note #1 */
{
  /* There are several different events that can cause the receiver callback
   * to be called.  Decode the event that caused this.  */
  switch (msg-&gt;type)
  {
  case LBM_MSG_DATA:    /* a received message */
    printf("Received %d bytes on topic %s: '%.*s'\n",  /* See note #2 */
           msg-&gt;len, msg-&gt;topic_name, msg-&gt;len, msg-&gt;data);

    /* Tell main thread that we've received our message. */
    ++ msgs_rcvd;
    break;

  case LBM_MSG_BOS:
    printf("[%s][%s], Beginning of Transport Session\n", msg-&gt;topic_name, msg-&gt;source);
    break;

  case LBM_MSG_EOS:
    printf("[%s][%s], End of Transport Session\n", msg-&gt;topic_name, msg-&gt;source);
    break;

  default:    /* unexpected receiver event */
    printf("Received lbm_msg_t type %x [%s][%s]\n", msg-&gt;type, msg-&gt;topic_name, msg-&gt;source);
    break;
  }  /* switch msg-&gt;type */

  return 0;
}  /* app_rcv_callback */


main()
{
  lbm_context_t *ctx;    /* pointer to context object */
  lbm_topic_t *topic;    /* pointer to topic object */
  lbm_rcv_t *rcv;        /* pointer to receiver object */
  int err;               /* return status of lbm functions (non-zero=error) */

#if defined(_MSC_VER)
  /* windows-specific code */
  WSADATA wsadata;
  int wsStat = WSAStartup(MAKEWORD(2,2), &amp;wsadata);
  if (wsStat != 0) {
    printf("line %d: wsStat=%d\n",__LINE__,wsStat); exit(1);
  }
#endif

  err = lbm_context_create(&amp;ctx, NULL, NULL, NULL);  /* See note #3 */
  if (err) {
    printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);
  }

  err = lbm_rcv_topic_lookup(&amp;topic, ctx, "Greeting", NULL);  /* See note #4 */
  if (err) {
    printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);
  }

  err = lbm_rcv_create(&amp;rcv, ctx, topic, app_rcv_callback, NULL, NULL);  /* See note #5 */
  if (err) {
    printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);
  }

  while (msgs_rcvd == 0) {
    SLEEP(1);
  }

  /* Finished all receiving from this topic, delete the receiver object. */
  err = lbm_rcv_delete(rcv);
  if (err) {
    printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);
  }

  /* Do not need to delete the topic object - LBM keeps track of topic
   * objects and deletes them as-needed.  */

  /* Finished with all LBM functions, delete the context object. */
  err = lbm_context_delete(ctx);
  if (err) {
    printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);
  }

#if defined(_MSC_VER)
  WSACleanup();
#endif
}  /* main */</pre><p>Notes:</p>
<ol>
<li>
<p class="startli">LBM passes received messages to the application by means of a callback. I.e. the LBM context thread reads the network socket, performs its higher-level protocol functions, and then calls an application-level function that was set up during initialization. This callback function has some severe limitations placed upon it. It must execute very quickly; any potentially blocking calls it might make will interfere with the proper execution of the LBM context thread. One common desire is for the receive function to send an LBM message (via <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/QuickStart/api.tag:../API/" href="../API/lbm_8h.html#a91f4b9cb04fe1323ec56833211cc5cb7">lbm_src_send()</a>), however this has the potential to produce a deadlock condition. If it is desired for the receive callback function to call LBM or other potentially blocking functions, it is strongly advised to make use of an event queue, which causes the callback to be executed from an application thread. See the example tool <a href="../example/lbmrcvq.c">lbmrcvq.c</a> for an example of using a receiver event queue.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Note - printf can block, which is normally a bad idea for a callback (unless an event queue is being used). However, for this minimal application, only one message is expected.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Create a context object. A context is an environment in which LBM functions. Note that the first parameter is a pointer to a pointer variable; <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/QuickStart/api.tag:../API/" href="../API/lbm_8h.html#a8058947690bd0995bc2c59d4a61b462f">lbm_context_create()</a> writes the pointer to the context object into "ctx". Also, by passing NULL to the context attribute parameter, the default option values are used. For most applications only a single context is required regardless of how many sources and receivers are created.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Lookup a topic object. A topic object is little more than a string (the topic name). During operation, LBM keeps some state information in the topic object as well. The topic is bound to the containing context, and will also be bound to a receiver object. Note that the first parameter is a pointer to a pointer variable; <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/QuickStart/api.tag:../API/" href="../API/lbm_8h.html#a3de8a6a659896f76475c453683db4e18">lbm_rcv_topic_lookup()</a> writes the pointer to the topic object into "topic". Also, by passing NULL to the source topic attribute, the default option values are used. The string "Greeting" is the topic string.</p>
<p class="endli"></p>
</li>
<li>
Create the receiver object and bind it to a topic. Note that the first parameter is a pointer to a pointer variable; <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/QuickStart/api.tag:../API/" href="../API/lbm_8h.html#aa7491c50fefbc2b70f8035fce7ac1477">lbm_rcv_create()</a> writes the pointer to the source object to into "rcv". The second and third parameters are the function and application data pointers. When a message is received, the function is called with the data pointer passed in as its last parameter. The last parameter is an optional event queue (not used in this example). </li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
</body>
</html>
