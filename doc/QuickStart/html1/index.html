<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Quick Start Guide: Quick Start Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen_manual.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Quick Start Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title"></div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<img src="infa_logo.png" width="400" height="138" alt="Informatica"/><br/><br/>
<big><b>Ultra Messaging</b></big> <small>(Version 6.11.1)</small><br/>
<br/><br/><br/>
<center class="mytitle">Quick Start Guide</center>
<center>Copyright (C) 2004-2018, Informatica Corporation.  All Rights Reserved.</center>
<br/><br/><br/>
[&nbsp;<a href="../index.html">Multi-page HTML</a>&nbsp;]&nbsp;&nbsp;|&nbsp;&nbsp;[&nbsp;<a href="../QuickStart_Guide=en.pdf">PDF</a>&nbsp;]
<br/><br/>
 </p>
<h1><a class="anchor" id="firstsect"></a>
Introduction</h1>
<p>This document provides step-by-step instructions on how to rapidly get started using Ultra Messaging high performance message streaming. It gets you started using our pre-compiled evaluation binaries to test performance, and then walks you through the steps of writing minimal source (publisher) and receiver (subscriber) applications.</p>
<dl class="section attention"><dt>Attention</dt><dd><b>See the <a href="../../DocIntro=en.pdf">Documentation Introduction</a> for important information on copyright, patents, information resources (including Knowledge Base, and How To articles), Marketplace, Support, and other information about Informatica and its products.</b></dd></dl>
<p>See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/QuickStart/design.tag:../../Design/" href="../../Design/umglossary.html">UM Glossary</a> for Ultra Messaging terminology, abbreviations, and acronyms.</p>
<p><br />
 </p>
<h1><a class="anchor" id="ultramessagingbinaryquickstart"></a>
Ultra Messaging Binary Quick Start</h1>
<p>Ultra Messaging software consists of the documentation package and one or more binary packages. These instructions help get you started evaluating Ultra Messaging quickly. You can run pre-compiled commands from an Ultra Messaging binary distribution to get some quick performance numbers in your environment. A subsequent section guides you through creation of simple programs for local compilation.</p>
<p>A binary package consists of:</p>
<ul>
<li>
<p class="startli">Binary versions of source code examples, in the bin directory.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Header files, in the include directory.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Link libraries, in the lib directory.</p>
<p class="endli"></p>
</li>
<li>
Shared libraries, in the lib directory on Unix for .so files or the bin directory on Windows for .dll files. </li>
</ul>
<p>The Ultra Messaging code and documentation are copyrighted and confidential information owned by Informatica and are covered under the terms of our Software License Agreement or Non-Disclosure Agreement as appropriate. Use of this code and documentation without a valid Non-Disclosure Agreement or Software License Agreement with Informatica Corporation is strictly prohibited. If this code and documentation is being supplied under the terms of a Non Disclosure Agreement, all copies, in any form, must be returned or destroyed at the end of the evaluation period or as requested by Informatica.</p>
<p><br />
 </p>
<h2><a class="anchor" id="binaryquickstartonmicrosoftwindows"></a>
Binary Quick Start on Microsoft Windows</h2>
<p>The following steps assume that the windows package is installed on all test machines in the standard place:</p>
<p><code>C:\Program Files\Informatica\</code><em>rel-id</em><code>\</code><em>platform-id</em></p>
<p>where <em>rel-id</em> is the release identifier and <em>platform-id</em> describes the ABI (Application Binary Interface). For example:</p>
<p><code>C:\Program Files\Informatica\UMQ_6.0\Win2k-x86_64</code></p>
<p>where <b>rel-id</b> is the release identifier. It is also assumed that the <code>\bin</code> directory is included in the windows PATH environment variable. This is needed so that the <code>.EXE</code> and <code>.DLL</code> files can be found.</p>
<ol>
<li>
<p class="startli">Open a command prompt window on the machine you want to use for receiving messages and enter the command lbmrcv topic to start a receiver. Note that topic can be any string. You should see output that looks something like this:</p>
<pre class="fragment">1.006 secs.   0.0 Kmsgs/sec.   0.0 Kbps
1.019 secs.   0.0 Kmsgs/sec.   0.0 Kbps
1.010 secs.   0.0 Kmsgs/sec.   0.0 Kbps
</pre><p>A new line will be printed about once per second showing the elapsed time, messages received, and data received. As long as there are no sources yet running on topic, the number of messages received will continue to be zero.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Open a command prompt window on the machine you want to use for sending messages and enter the command lbmsrc topic to start sending messages. The receiver will automatically discover the source, at which time its output will change to something like this:</p>
<pre class="fragment">1.010 secs. 451.9 Kmsgs/sec.  90.4 Mbps
1.010 secs. 451.4 Kmsgs/sec.  90.3 Mbps
1.010 secs. 445.1 Kmsgs/sec.  89.0 Mbps
</pre><p class="endli"></p>
</li>
<li>
<p class="startli">With no options given, the source will send 10,000,000 small (25 byte) messages. If you would like to test different size packets or number of packets sent, you can set options. Enter lbmsrc -h at the command line, you will get a list of options you can control.</p>
<p class="endli"></p>
</li>
<li>
Press <code>Ctrl-C</code> to kill the source or receiver. </li>
</ol>
<p><br />
 </p>
<h2><a class="anchor" id="binaryquickstartonunix"></a>
Binary Quick Start on Unix</h2>
<p>The following steps assume that the Unix package is installed on all test machines under a normal user account:</p>
<p><code>/home/</code><em>user-id</em><code>/lbmeval/</code><em>rel-id</em><code>/</code><em>platform-id</em></p>
<p>where <em>rel-id</em> is the release identifier and <em>platform-id</em> describes the ABI (Application Binary Interface). For example:</p>
<p><code>/home/jsmith/UMQ_6.0/Linux-glibc-2.5-x86_64</code></p>
<p>It is also assumed that the <code>/bin</code> directory is included in the PATH environment variable and the /lib directory is in the appropriate loader library search path environment variable (e.g. LD_LIBRARY_PATH for Linux; see <a href="http://bhami.com/rosetta.html">http://bhami.com/rosetta.html</a> for equivalences in other flavors of Unix).</p>
<ol>
<li>
<p class="startli">Open a command prompt window on the machine you want to use for receiving messages and enter the command lbmrcv topic to start a receiver. Note that topic can be any string. You should see output that looks something like this:</p>
<pre class="fragment">1.006 secs.   0.0 Kmsgs/sec.   0.0 Kbps
1.019 secs.   0.0 Kmsgs/sec.   0.0 Kbps
1.010 secs.   0.0 Kmsgs/sec.   0.0 Kbps
</pre><p>A new line will be printed about once per second showing the elapsed time, messages received, and data received. As long as there are no sources yet running on topic, the number of messages received will continue to be zero.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Open a command prompt window on the machine you want to use for sending messages and enter the command lbmsrc topic to start sending messages. The receiver will automatically discover the source, at which time its output will change to something like this:</p>
<pre class="fragment">1.010 secs. 451.9 Kmsgs/sec.  90.4 Mbps
1.010 secs. 451.4 Kmsgs/sec.  90.3 Mbps
1.010 secs. 445.1 Kmsgs/sec.  89.0 Mbps
</pre><p class="endli"></p>
</li>
<li>
<p class="startli">With no options given, the source will send 10,000,000 small (25 byte) messages. If you would like to test different size packets or number of packets sent, you can set options. Enter lbmsrc -h at the command line, you will get a list of options you can control.</p>
<p class="endli"></p>
</li>
<li>
Press Ctrl-C to kill the source or receiver. </li>
</ol>
<p><br />
 </p>
<h2><a class="anchor" id="binaryevaluationnotes"></a>
Binary Evaluation Notes</h2>
<ol>
<li>
<p class="startli">There are many other example programs available. See:</p>
<ul>
<li>
<a href="../../example/index.html">C examples</a> </li>
<li>
<a href="../../java_example/index.html">Java examples</a> </li>
<li>
<a href="../../dotnet_example/index.html">.NET examples</a> </li>
</ul>
<p class="endli"></p>
</li>
<li>
<p class="startli">For general information on measuring performance, see <a href="https://kb.informatica.com/faq/5/Pages/80055.aspx">LBM Reference Performance Tests</a> and <a href="https://kb.informatica.com/whitepapers/4/Pages/1/304989.aspx">UMP Performance Testing Sample Applications</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">For information on testing the LBT-RM (multicast) transport, see the following UM Knowledgebase articles:</p>
<ul>
<li>
<a href="https://kb.informatica.com/faq/5/Pages/80071.aspx">Testing with LBT-RM</a> </li>
<li>
<a href="https://kb.informatica.com/faq/5/Pages/80072.aspx">Interpreting LBT-RM Source Statistics</a> </li>
<li>
<a href="https://kb.informatica.com/faq/5/Pages/80074.aspx">Tuning LBT-RM Questions</a> </li>
</ul>
<p class="endli"></p>
</li>
<li>
<p class="startli">Microsoft has batching issues in its networking stack, so the performance results can vary. We have a work around if this is an issue for you.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The Linux version was compiled on Fedora Core 1.</p>
<p class="endli"></p>
</li>
<li>
The Windows version was compiled on Windows XP with Microsoft Visual C++ version 7. </li>
</ol>
<p><br />
 </p>
<h1><a class="anchor" id="ultramessagingprogrammingquickstart"></a>
Ultra Messaging Programming Quick Start</h1>
<p>The C programs below contain the minimum code and supporting material. Their purpose is to verify that the user's build and run-time environments are set up correctly. They also give a basic introduction to the Ultra Messaging API.</p>
<p>We also have equivalent Java and C# programs available in source form. See <a href="../../java_example/MinSrc.java">MinSrc.java</a> and <a href="../../java_example/MinRcv.java">MinRcv.java</a> or <a href="../../dotnet_example/MinSrc.cs">MinSrc.cs</a> and <a href="../../dotnet_example/MinRcv.cs">MinRcv.cs</a>. We also have an example of how application callbacks are coded in C++ programs. See <a href="../../example/minrcv.cpp">minrcv.cpp</a>.</p>
<p>(Most browsers let you right-click on a link and use the "save link target" function, or some variation.)</p>
<p>Note that these programs do not allow the user to override any of the default configuration values. As a result, operation is fixed according to the normal LBM defaults; for example TCP is the transport protocol, topic resolution is performed using multicast, etc. See the <a href="../../Config/index.html">Ultra Messaging Configuration Guide</a>.</p>
<p>The Source Code Examples tab on the left panel provides a much richer set of source files that use a wide variety of features. However, those programs double as performance testing tools, so they tend to be more complex than just demonstrating the features. We recommend to first build and run these minimal examples.</p>
<p>This source code example is provided by Informatica for educational and evaluation purposes only.</p>
<p>Error handling in these programs is primitive. A production program would want to have better error handling, but for the purposes of a minimal example, it would just be a distraction. Also, a production program would want to support a configuration file to override default values on options.</p>
<p><br />
 </p>
<h2><a class="anchor" id="buildingnoteswindows"></a>
Building Notes: Windows</h2>
<p>When building on Windows, the following notes are applicable.</p>
<ul>
<li>
<p class="startli">Make sure the preprocessor variable "WIN32" is defined.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Add the '<code>...\include\lbm</code>' (under the package install directory) as an additional include directory.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Add lbm.lib and wsock32.lib as Object/library modules.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Add the '<code>...\lib</code>' as an additional library path.</p>
<p class="endli"></p>
</li>
<li>
The install procedure should already have added the LBM bin directory to the Windows PATH. This is necessary so that <code>lbm.dll</code> can be found when a program is run. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="buildingnotesunix"></a>
Building Notes: Unix</h2>
<p>When building on Unix, the following notes are applicable.</p>
<ul>
<li>
<p class="startli">Sample build command: </p><pre class="fragment">cc -I$HOME/lbm/&lt;VERS&gt;/&lt;PLATFORM&gt;/include
   -L$HOME/lbm/&lt;VERS&gt;/&lt;PLATFORM&gt;/lib -llbm -lm -o min_src min_src.c
</pre><p> (This should be all one line.)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The appropriate library search path should be updated to include the Ultra Messaging <code>lib/</code> directory. For example, on Linux:</p>
<pre class="fragment">LD_LIBRARY_PATH="$HOME/lbm/&lt;VERS&gt;/&lt;PLATFORM&gt;/lib:$LD_LIBRARY_PATH"
export LD_LIBRARY_PATH
</pre><p class="endli">(For other flavors of Unix, see <a href="http://bhami.com/rosetta.html">http://bhami.com/rosetta.html</a>.) Alternatively, the shared library can be copied from the LBM <code>lib/</code> directory to a directory which is already in the library search path. </p>
</li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="minimalultramessagingsourceimplementation"></a>
Minimal Ultra Messaging Source Implementation</h2>
<p>This is a source code listing of a minimal source (sender) program. Examples also include equivalent Java and C# programs available in source form. See <a href="../../java_example/MinSrc.java">MinSrc.java</a> and <a href="../../dotnet_example/MinSrc.cs">MinSrc.cs</a>.</p>
<pre class="fragment">/*
"minsrc.c: minimal application that sends to a given topic.
 *
 * Copyright (c) 2005-2018 Informatica Corporation. All Rights Reserved.
 * Permission is granted to licensees to use
 * or alter this software for any purpose, including commercial applications,
 * according to the terms laid out in the Software License Agreement.
 *
 * This source code example is provided by Informatica for educational
 * and evaluation purposes only.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND INFORMATICA DISCLAIMS ALL WARRANTIES
 * EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY IMPLIED WARRANTIES OF
 * NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
 * PURPOSE.  INFORMATICA DOES NOT WARRANT THAT USE OF THE SOFTWARE WILL BE
 * UNINTERRUPTED OR ERROR-FREE.  INFORMATICA SHALL NOT, UNDER ANY CIRCUMSTANCES, BE
 * LIABLE TO LICENSEE FOR LOST PROFITS, CONSEQUENTIAL, INCIDENTAL, SPECIAL OR
 * INDIRECT DAMAGES ARISING OUT OF OR RELATED TO THIS AGREEMENT OR THE
 * TRANSACTIONS CONTEMPLATED HEREUNDER, EVEN IF INFORMATICA HAS BEEN APPRISED OF
 * THE LIKELIHOOD OF SUCH DAMAGES.
 */

/* Explanatory notes referenced in this file are in the Quick Start guide. */

#include &lt;stdio.h&gt;

#if defined(_MSC_VER)
/* Windows-only includes */
#include &lt;winsock2.h&gt;
#define SLEEP(s) Sleep((s)*1000)
#else
/* Unix-only includes */
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#define SLEEP(s) sleep(s)
#endif

#include &lt;lbm/lbm.h&gt;

main()
{
  lbm_context_t *ctx;    /* pointer to context object */
  lbm_topic_t *topic;    /* pointer to topic object */
  lbm_src_t *src;        /* pointer to source (sender) object */
  int err;               /* return status of lbm functions (true=error) */

#if defined(_MSC_VER)
  /* windows-specific code */
  WSADATA wsadata;
  int wsStat = WSAStartup(MAKEWORD(2,2), &amp;wsadata);
  if (wsStat != 0) {
    printf("line %d: wsStat=%d\n",__LINE__,wsStat); exit(1);
  }
#endif

  err = lbm_context_create(&amp;ctx, NULL, NULL, NULL);  /* See Note #1 */
  if (err) {
    printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);
  }

  err = lbm_src_topic_alloc(&amp;topic, ctx, "Greeting", NULL);  /* See Note #2 */
  if (err) {
    printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);
  }

  err = lbm_src_create(&amp;src, ctx, topic, NULL, NULL, NULL);  /* See Note #3 */
  if (err) {
    printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);
  }

  SLEEP(1);  /* See Note #4 */

  err = lbm_src_send(src, "Hello!", 6, LBM_MSG_FLUSH | LBM_SRC_BLOCK);  /* See Note #5 */
  if (err) {
    printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);
  }

  SLEEP(2);  /* See Note #6 */

  /* Finished all sending to this topic, delete the source object. */

  err = lbm_src_delete(src);

  /* Do not need to delete the topic object - LBM keeps track of topic
   * objects and deletes them as-needed.  */

  /* Finished with all LBM functions, delete the context object. */
  err = lbm_context_delete(ctx);

#if defined(_MSC_VER)
  WSACleanup();
#endif
}  /* main */</pre><p>Notes:</p>
<ol>
<li>
<p class="startli">Create a context object. A context is an environment in which LBM functions. Note that the first parameter is a pointer to a pointer variable; <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/QuickStart/api.tag:../../API/" href="../../API/lbm_8h.html#a8058947690bd0995bc2c59d4a61b462f">lbm_context_create()</a> writes the pointer to the context object into "ctx". Also, by passing NULL to the context attribute parameter, the default option values are used. For most applications only a single context is required regardless of how many sources and receivers are created.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Allocate a topic object. A topic object is little more than a string (the topic name). During operation, LBM keeps some state information in the topic object as well. The topic is bound to the containing context, and will also be bound to a source object. Note that the first parameter is a pointer to a pointer variable; <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/QuickStart/api.tag:../../API/" href="../../API/lbm_8h.html#a1ba60407fa2bde0997aab6d5a5d2da1a">lbm_src_topic_alloc()</a> writes the pointer to the topic object into "topic". Also, by passing NULL to the source topic attribute, the default option values are used. The string "Greeting" is the topic string.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Create the source object. A source object is used to send messages. It must be bound to a topic. Note that the first parameter is a pointer to a pointer variable; <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/QuickStart/api.tag:../../API/" href="../../API/lbm_8h.html#ab8dd76271bf9df7a5f88476d431f523e">lbm_src_create()</a> writes the pointer to the source object to into "src". Use of the third and fourth parameters is optional but recommended in a production program - some source events can be important to the application. The last parameter is an optional event queue (not used in this example).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Need to wait for receivers to find us before first send. There are other ways to accomplish this, but sleep is easy. See <a href="https://kb.informatica.com/faq/5/Pages/80061.aspx">Avoiding or Minimizing Delay Before Sending</a> for details.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Send a message to the "Greeting" topic. The flags make sure the call to <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/QuickStart/api.tag:../../API/" href="../../API/lbm_8h.html#a91f4b9cb04fe1323ec56833211cc5cb7">lbm_src_send()</a> doesn't return until the message is sent. Note that while this ensures low latency, flushing every message carries a heavy efficiency cost. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/QuickStart/design.tag:../../Design/" href="../../Design/architecture.html#intelligentbatching">Intelligent Batching</a> for more information.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">For some transport types (mostly UDP-based), a short delay before deleting the source is advisable. Even though the message is sent, there may have been packet loss, and some transports need a bit of time to request re-transmission. Also, if the above <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/QuickStart/api.tag:../../API/" href="../../API/lbm_8h.html#a91f4b9cb04fe1323ec56833211cc5cb7">lbm_src_send()</a> call didn't include the flush, some time might also be needed to empty the batching buffer.</p>
<p class="endli"><br />
 </p>
</li>
</ol>
<h2><a class="anchor" id="minimalultramessagingreceiverimplementation"></a>
Minimal Ultra Messaging Receiver Implementation</h2>
<p>This is a source code listing of a minimal receiver program. Examples also include equivalent Java, C#, and C++ programs available in source form. See <a href="../../java_example/MinRcv.java">MinRcv.java</a>, <a href="../../dotnet_example/MinRcv.cs">MinRcv.cs</a>, and <a href="../../example/minrcv.cpp">minrcv.cpp</a>.</p>
<pre class="fragment">/*
"minrcv.c: minimal application that receives messages from a given topic.
 *
 * Copyright (c) 2005-2018 Informatica Corporation. All Rights Reserved.
 * Permission is granted to licensees to use
 * or alter this software for any purpose, including commercial applications,
 * according to the terms laid out in the Software License Agreement.
 *
 * This source code example is provided by Informatica for educational
 * and evaluation purposes only.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND INFORMATICA DISCLAIMS ALL WARRANTIES
 * EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY IMPLIED WARRANTIES OF
 * NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
 * PURPOSE.  INFORMATICA DOES NOT WARRANT THAT USE OF THE SOFTWARE WILL BE
 * UNINTERRUPTED OR ERROR-FREE.  INFORMATICA SHALL NOT, UNDER ANY CIRCUMSTANCES, BE
 * LIABLE TO LICENSEE FOR LOST PROFITS, CONSEQUENTIAL, INCIDENTAL, SPECIAL OR
 * INDIRECT DAMAGES ARISING OUT OF OR RELATED TO THIS AGREEMENT OR THE
 * TRANSACTIONS CONTEMPLATED HEREUNDER, EVEN IF INFORMATICA HAS BEEN APPRISED OF
 * THE LIKELIHOOD OF SUCH DAMAGES.
 */

/* Explanatory notes referenced in this file are in the Quick Start guide. */

#include &lt;stdio.h&gt;

#if defined(_MSC_VER)
/* Windows-only includes */
#include &lt;winsock2.h&gt;
#define SLEEP(s) Sleep((s)*1000)
#else
/* Unix-only includes */
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#define SLEEP(s) sleep(s)
#endif

#include &lt;lbm/lbm.h&gt;

/*
 * A global variable is used to communicate from the receiver callback to
 * the main application thread.
 */
int msgs_rcvd = 0;

int app_rcv_callback(lbm_rcv_t *rcv, lbm_msg_t *msg, void *clientd)  /* See Note #1 */
{
  /* There are several different events that can cause the receiver callback
   * to be called.  Decode the event that caused this.  */
  switch (msg-&gt;type)
  {
  case LBM_MSG_DATA:    /* a received message */
    printf("Received %d bytes on topic %s: '%.*s'\n",  /* See note #2 */
           msg-&gt;len, msg-&gt;topic_name, msg-&gt;len, msg-&gt;data);

    /* Tell main thread that we've received our message. */
    ++ msgs_rcvd;
    break;

  case LBM_MSG_BOS:
    printf("[%s][%s], Beginning of Transport Session\n", msg-&gt;topic_name, msg-&gt;source);
    break;

  case LBM_MSG_EOS:
    printf("[%s][%s], End of Transport Session\n", msg-&gt;topic_name, msg-&gt;source);
    break;

  default:    /* unexpected receiver event */
    printf("Received lbm_msg_t type %x [%s][%s]\n", msg-&gt;type, msg-&gt;topic_name, msg-&gt;source);
    break;
  }  /* switch msg-&gt;type */

  return 0;
}  /* app_rcv_callback */


main()
{
  lbm_context_t *ctx;    /* pointer to context object */
  lbm_topic_t *topic;    /* pointer to topic object */
  lbm_rcv_t *rcv;        /* pointer to receiver object */
  int err;               /* return status of lbm functions (non-zero=error) */

#if defined(_MSC_VER)
  /* windows-specific code */
  WSADATA wsadata;
  int wsStat = WSAStartup(MAKEWORD(2,2), &amp;wsadata);
  if (wsStat != 0) {
    printf("line %d: wsStat=%d\n",__LINE__,wsStat); exit(1);
  }
#endif

  err = lbm_context_create(&amp;ctx, NULL, NULL, NULL);  /* See note #3 */
  if (err) {
    printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);
  }

  err = lbm_rcv_topic_lookup(&amp;topic, ctx, "Greeting", NULL);  /* See note #4 */
  if (err) {
    printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);
  }

  err = lbm_rcv_create(&amp;rcv, ctx, topic, app_rcv_callback, NULL, NULL);  /* See note #5 */
  if (err) {
    printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);
  }

  while (msgs_rcvd == 0) {
    SLEEP(1);
  }

  /* Finished all receiving from this topic, delete the receiver object. */
  err = lbm_rcv_delete(rcv);
  if (err) {
    printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);
  }

  /* Do not need to delete the topic object - LBM keeps track of topic
   * objects and deletes them as-needed.  */

  /* Finished with all LBM functions, delete the context object. */
  err = lbm_context_delete(ctx);
  if (err) {
    printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);
  }

#if defined(_MSC_VER)
  WSACleanup();
#endif
}  /* main */</pre><p>Notes:</p>
<ol>
<li>
<p class="startli">LBM passes received messages to the application by means of a callback. I.e. the LBM context thread reads the network socket, performs its higher-level protocol functions, and then calls an application-level function that was set up during initialization. This callback function has some severe limitations placed upon it. It must execute very quickly; any potentially blocking calls it might make will interfere with the proper execution of the LBM context thread. One common desire is for the receive function to send an LBM message (via <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/QuickStart/api.tag:../../API/" href="../../API/lbm_8h.html#a91f4b9cb04fe1323ec56833211cc5cb7">lbm_src_send()</a>), however this has the potential to produce a deadlock condition. If it is desired for the receive callback function to call LBM or other potentially blocking functions, it is strongly advised to make use of an event queue, which causes the callback to be executed from an application thread. See the example tool <a href="../../example/lbmrcvq.c">lbmrcvq.c</a> for an example of using a receiver event queue.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Note - printf can block, which is normally a bad idea for a callback (unless an event queue is being used). However, for this minimal application, only one message is expected.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Create a context object. A context is an environment in which LBM functions. Note that the first parameter is a pointer to a pointer variable; <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/QuickStart/api.tag:../../API/" href="../../API/lbm_8h.html#a8058947690bd0995bc2c59d4a61b462f">lbm_context_create()</a> writes the pointer to the context object into "ctx". Also, by passing NULL to the context attribute parameter, the default option values are used. For most applications only a single context is required regardless of how many sources and receivers are created.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Lookup a topic object. A topic object is little more than a string (the topic name). During operation, LBM keeps some state information in the topic object as well. The topic is bound to the containing context, and will also be bound to a receiver object. Note that the first parameter is a pointer to a pointer variable; <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/QuickStart/api.tag:../../API/" href="../../API/lbm_8h.html#a3de8a6a659896f76475c453683db4e18">lbm_rcv_topic_lookup()</a> writes the pointer to the topic object into "topic". Also, by passing NULL to the source topic attribute, the default option values are used. The string "Greeting" is the topic string.</p>
<p class="endli"></p>
</li>
<li>
Create the receiver object and bind it to a topic. Note that the first parameter is a pointer to a pointer variable; <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/QuickStart/api.tag:../../API/" href="../../API/lbm_8h.html#aa7491c50fefbc2b70f8035fce7ac1477">lbm_rcv_create()</a> writes the pointer to the source object to into "rcv". The second and third parameters are the function and application data pointers. When a message is received, the function is called with the data pointer passed in as its last parameter. The last parameter is an optional event queue (not used in this example). </li>
</ol>
<p><br />
 </p>
<h1><a class="anchor" id="unicastonlyoperation"></a>
Unicast-Only Operation</h1>
<p>One of Ultra Messaging's great strengths is its use of the network hardware and protocols to achieve very high performance and scalability. By default, Ultra Messaging uses multicast for topic resolution so that data sources and receivers can find each other.</p>
<p>In general, we recommend the use of multicast whenever possible because it provides the best performance and scalability. However, we recognize that it is not always possible to provide multicast connectivity between the machines. For those cases, we support unicast-only operation.</p>
<p>There are two parts to unicast-only operation. One is to use a unicast form of transport. Ultra Messaging uses TCP by default for transport, but LBT-RU is also available and has some performance advantages. For initial "quick start" testing, we recommend not changing the default TCP.</p>
<p>The second part of unicast-only operation is to use the lbmrd (UM Resolver Daemon) for topic resolution. (NOTE: this does not route message data through a daemon. This is a helper process that lets data sources and receivers find each other.) To enable unicast topic resolution, do the following:</p>
<ol>
<li>
<p class="startli">Choose one machine to host the resolver daemon and enter the lbmrd command (use lbmrd -h for full instructions).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Create a Ultra Messaging configuration file containing: <br />
<code>context resolver_unicast_daemon [Iface[:Src_Port]-&gt;]IP:Dest_Port</code> where:</p>
<ul>
<li>
<p class="startli">Iface is the interface to use (previously set via resolver_unicast_interface).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Src_Port is the source port to use (previously resolver_unicast_port).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">IP is the resolver daemon's IP address (previously resolver_unicast_address).</p>
<p class="endli"></p>
</li>
<li>
Dest_Port is the resolver daemon's UDP port (previously resolver_unicast_destination_port). </li>
</ul>
<p>For more information, see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/QuickStart/config.tag:../../Config/" href="../../Config/grpunicastresolvernetwork.html#resolverunicastdaemoncontext">resolver_unicast_daemon (context)</a>.</p>
<p class="endli"></p>
</li>
<li>
Run the test applications with the option -c filename where filename is the configuration file created in step 2. </li>
</ol>
<p>Due to the fact that the minimal source programs presented in this document (minsrc.c and minrcv.c) do not allow the use of a configuration file, it is not possible to configure them for unicast-only operation. If multicast operation is not possible on your network, then please use the binary test programs (described in Ultra Messaging Binary Quick Start) which which do allow unicast-only configuration.</p>
<p><br />
 </p>
<h1><a class="anchor" id="startingultramessagingdaemons"></a>
Starting Ultra Messaging Daemons</h1>
<p><br />
 </p>
<h2><a class="anchor" id="startingultramessagingdynamicroutingoption"></a>
Starting Ultra Messaging Dynamic Routing Option</h2>
<p>The UM Router bridges disjoint topic resolution domains by forwarding multicast and/or unicast topic resolution traffic. Before installing and starting a UM Router daemon (tnwgd) clear objectives and proper planning are very important. Approach this planning with the consideration that a UM Router condenses your network into a single process. You must be clear about the traffic you expect to forward through a UM Router. The following highlights some other specifics.</p>
<ul>
<li>
<p class="startli">Know your Topic Resolution Domains. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/QuickStart/gateway.tag:../../Gateway/" href="../../Gateway/droarchitecture.html#topicresolutiondomains">Topic Resolution Domains</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Consider the size and quality of network paths into and out of your UM Routers. For example, UM Routers cannot efficiently forward messages from a 1GB path to a 100MB path.</p>
<p class="endli"></p>
</li>
<li>
Fully examine any use of Late Join, taking care to configure retransmission options correctly. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="startingummdaemon"></a>
Starting UMM Daemon</h2>
<p>The UMM Daemon manages UM XML configuration information defined in the GUI as well as user and license information. It serves license and configuration information to UM applications. The UMM Daemon requires either a MySQL or Oracle database installation. Informatica does not supply MySQL or Oracle nor any licensing to use them. For additional information about the steps in this process, see the <a href="../../UMM/index.html">Ultra Messaging Manager Guide</a>.</p>
<ol>
<li>
<p class="startli">Install MySQL or Oracle according to the user documentation.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Create a database. (You provide the UMM Daemon with the database name, username and password at start up. This user name and password should be kept secure.)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Log into the database.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">From the database's command line or home page, execute the /UMM/install_tables_oracle.sql or source /UMM/install_tables_mysql.sql script. (This script installs the tables required by UMM.)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">From the database's command line or home page, load /UMM/oracle_templates.txt or /UMM/mysql_templates.txt. (This script loads the example configuration templates for low latency and high throughput. These templates appear in the UMM GUI under Templates in the object tree in the left pane.</p>
<ul>
<li>
<p class="startli">For Oracle, load /UMM/oracle_templates.txt.</p>
<p class="endli"></p>
</li>
<li>
For MySQL, run `LOAD DATA INFILE 'mysql_templates.txt' INTO TABLE TEMPLATE;`. </li>
</ul>
<p class="endli"></p>
</li>
<li>
<p class="startli">Modify the /UMM/umm.properties to indicate the database username, password and driver to reflect your configuration database.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Edit the ummd.bat or ummd.sh file that starts UMM Daemon. The appropriate driver jar file name must be added to the classpath. Specify your certificate file or Java keystore information if using SSL certificates. The ummd.bat or ummd.sh provided with installation appears below. <br />
<code>java -cp .;mysql-connector-java-5.0.8-bin.jar;UMMD_1.6.0_02.jar -Xms512m -Xmx1024m umm.ummd.Server</code></p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Start the UMM Daemon with /UMM/ummd.bat or /UMM/ummd.sh.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Edit the umm.bat or umm.sh file that starts the UMM GUI. The appropriate driver jar file name must be added to the classpath. The umm.bat or umm.sh provided with installation appears below. <br />
<code>java -cp .;mysql-connector-java-5.0.8-bin.jar;UMM_1.jar; -Xms256m -Xmx1024m umm.gui.MainFrame</code></p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Start the UMM GUI with /UMM/umm.bat or /UMM/umm.sh.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Log into the UMM GUI with username, default and password default. Either change the default user's password or create new administrative user and delete the default user. See the <a href="../../UMM/index.html">Ultra Messaging Manager Guide</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">To enable your UM applications to be served configuration information by UMM Daemon, set the following environment variable for every application/user combination. <br />
<code>export LBM_UMM_INFO=</code><em>application_name</em><code>:</code><em>user_name</em><code>:</code><em>password</em><code>@</code><em>ip</em><code>:</code><em>port</em></p>
<p class="endli">For example: <br />
<code>export LBM_UMM_INFO=lbmrcv:lbmrcv:default:default@10.29.3.95:21273</code> </p>
</li>
</ol>
<p><br />
 </p>
<h2><a class="anchor" id="persistentstoredaemon"></a>
Persistent Store Daemon</h2>
<p>The daemon, umestored, provides persistent store services. To start umestored, perform the following steps:</p>
<ol>
<li>
<p class="startli">Create the cache and state directories. <br />
<code>$ mkdir umestored-cache ; mkdir umestored-state</code></p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Create a simple umestored XML configuration file or use a sample configuration, ume-example-config.xml or q-example-config.xml. See the <a href="../../UME/index.html">Ultra Messaging Guide for Persistence</a>.</p>
<p class="endli"></p>
</li>
<li>
Start the daemon. <br />
<code>$ umestored config.xml</code> </li>
</ol>
<p>See also <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.11.1_RC1/doc/QuickStart/ume.tag:../../UME/" href="../../UME/persistencemanpages.html#umestoredmanpage">umestored Man Page</a>.</p>
<p><br />
 </p>
<h1><a class="anchor" id="nextsteps"></a>
Next Steps</h1>
<p>The <a href="../../Design/index.html">Ultra Messaging Concepts Guide</a> introduces the important fundamental concepts you will need to design and code your applications.</p>
<p>See <a href="../../example/index.html">C example</a> programs for descriptions and source files for the binary tools used for evaluation and performance measurements. They can be a valuable resource for seeing how various features can be implemented. Also available are <a href="../../java_example/index.html">Java</a> and <a href="../../dotnet_example/index.html">.NET</a> example programs.</p>
<p>The <a href="../../UME/index.html">Ultra Messaging Guide for Persistence</a> contains concepts, tutorials and configuration information for UMP, along with discussions about designing persistent applications. It also contains detailed configuration information for the umestored daemon.</p>
<p>The <a href="../../UMQ/index.html">Ultra Messaging Guide for Queuing</a> contains concepts, tutorials and configuration information for UMQ, along with discussions about designing queuing applications.</p>
<p>The <a href="../../API/index.html">C API</a>, <a href="../../JavaAPI/index.html">Java API</a>, <a href="../../DotNetAPI/index.html">.NET API</a> documentation provide reference guides for the Ultra Messaging libraries. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
</body>
</html>
