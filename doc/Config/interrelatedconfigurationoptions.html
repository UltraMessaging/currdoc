<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Configuration Guide: Interrelated Configuration Options</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen_manual.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Configuration Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('interrelatedconfigurationoptions.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Interrelated Configuration Options </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Some Ultra Messaging configuration options are related in ways that might not be immediately apparent. Changing the value for one option without adjusting its related option can cause problems such as NAK storms, tail loss, etc. This section identifies these relationships and recommends a best practice for setting the interrelated options.</p>
<p>The following sections discuss configuration option relationships.</p>
<p><br />
 </p>
<h1><a class="anchor" id="preventingnakstormswithnakintervals"></a>
Preventing NAK Storms with NAK Intervals&nbsp;&nbsp;<small><a href="#preventingnakstormswithnakintervals">&lt;-</a></small></h1>
<p>The NAK generation interval should be sufficiently longer than the NAK backoff interval so that the source, after receiving the first NAK from a receiver, has time to retransmit the missing datagram and prevent a NAK storm from all receivers. LBTRM, LBTRU, and MIM all use NAK generation and backoff intervals. The NAK behavior for all transports is the same.</p>
<dl class="section user"><dt><b>Interrelated</b> <b>Options</b>:</dt><dd><ul>
<li>
<a class="el" href="grptransportlbtrmreliability.html#transportlbtrmnakbackoffintervalreceiver">transport_lbtrm_nak_backoff_interval (receiver)</a> </li>
<li>
<a class="el" href="grptransportlbtrmreliability.html#transportlbtrmnakgenerationintervalreceiver">transport_lbtrm_nak_generation_interval (receiver)</a> </li>
<li>
<a class="el" href="grptransportlbtrureliability.html#transportlbtrunakbackoffintervalreceiver">transport_lbtru_nak_backoff_interval (receiver)</a> </li>
<li>
<a class="el" href="grptransportlbtrureliability.html#transportlbtrunakgenerationintervalreceiver">transport_lbtru_nak_generation_interval (receiver)</a> </li>
<li>
<a class="el" href="grpmulticastimmediatemessagingreliability.html#mimnakbackoffintervalcontext">mim_nak_backoff_interval (context)</a> </li>
<li>
<a class="el" href="grpmulticastimmediatemessagingreliability.html#mimnakgenerationintervalcontext">mim_nak_generation_interval (context)</a> </li>
</ul>
</dd></dl>
<dl class="section user"><dt><b>Recommendation</b>:</dt><dd>Set the NAK generation interval to at least 2x the NAK backoff interval.</dd></dl>
<dl class="section user"><dt><b>Example</b>:</dt><dd><pre class="fragment">#
# To avoid NAK storms, set NAK generation interval to at least 2x the
# NAK backoff interval.
#
receiver transport_lbtrm_nak_backoff_interval 200       # .2 seconds
receiver transport_lbtrm_nak_generation_interval 10000  # 10 seconds
</pre></dd></dl>
<dl class="section user"><dt><b>See</b> <b>also</b>:</dt><dd><a class="el" href="grptransportlbtrmreliability.html">Transport LBT-RM Reliability Options</a> <br />
<a class="el" href="grptransportlbtrureliability.html">Transport LBT-RU Reliability Options</a> <br />
<a class="el" href="grpmulticastimmediatemessagingreliability.html">Multicast Immediate Messaging Reliability Options</a></dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="preventingtaillosswithtsniandnakintervaloptions"></a>
Preventing Tail Loss With TSNI and NAK Interval Options&nbsp;&nbsp;<small><a href="#preventingtaillosswithtsniandnakintervaloptions">&lt;-</a></small></h1>
<p><a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Config/design.tag:../Design/" href="../Design/fundamentalconcepts.html#tailloss">Tail Loss</a> refers to the situation where a receiver (subscriber) does not receive the last few (tail) messages sent by a source (publisher). When unrecoverable loss occurs on a transport, due to the possibility of multiple topic-level messages being contained in a single transport-level sequence number (due to implicit batching), a receiver does not know which particular messages were unrecoverable until the arrival of later messages (revealing earlier gaps in topic-level sequence number) or until the arrival of Topic Sequence Number Information (TSNI) records sent periodically by a publisher. Specific topic-level knowledge of sequence gaps is a prerequisite for the receiver to deliver event callbacks to the application indicating that unrecoverable loss has occurred, because those event callbacks are per-receiver (topic-level). A TSNI active threshold that is too small relative to the TSNI and/or NAK generation interval may prevent the reporting of tail loss to the application, especially with ordered delivery.</p>
<dl class="section user"><dt><b>Interrelated</b> <b>Options</b>:</dt><dd><ul>
<li>
<a class="el" href="grpmajoroptions.html#transporttopicsequencenumberinfoactivethresholdsource">transport_topic_sequence_number_info_active_threshold (source)</a> </li>
<li>
<a class="el" href="grpmajoroptions.html#transporttopicsequencenumberinfointervalsource">transport_topic_sequence_number_info_interval (source)</a> </li>
<li>
<a class="el" href="grptransportlbtrmreliability.html#transportlbtrmnakgenerationintervalreceiver">transport_lbtrm_nak_generation_interval (receiver)</a> </li>
<li>
<a class="el" href="grptransportlbtrureliability.html#transportlbtrunakgenerationintervalreceiver">transport_lbtru_nak_generation_interval (receiver)</a> </li>
</ul>
</dd></dl>
<dl class="section user"><dt><b>Recommendation</b>:</dt><dd>Set the source's <a class="el" href="grpmajoroptions.html#transporttopicsequencenumberinfoactivethresholdsource">transport_topic_sequence_number_info_active_threshold (source)</a> to at least 4x the <a class="el" href="grpmajoroptions.html#transporttopicsequencenumberinfointervalsource">transport_topic_sequence_number_info_interval (source)</a> plus the receiver's <a class="el" href="grptransportlbtrureliability.html#transportlbtrunakgenerationintervalreceiver">transport_lbtru_nak_generation_interval (receiver)</a>, all divided by 1000 to get seconds..</dd></dl>
<dl class="section user"><dt><b>Example</b>:</dt><dd><pre class="fragment">#
# NOTE: transport_topic_sequence_number_info_active_threshold is in seconds.
#
source   transport_topic_sequence_number_info_interval 5000
receiver transport_lbtrm_nak_generation_interval       10000
# (5000*4 + 10000)/1000 = 30
source   transport_topic_sequence_number_info_active_threshold 30
</pre></dd></dl>
<dl class="section user"><dt><b>See</b> <b>also</b>:</dt><dd><a class="el" href="interrelatedconfigurationoptions.html#preventingundetectedloss">Preventing Undetected Unrecoverable Loss</a> <br />
<a class="el" href="grptransportlbtrmreliability.html">Transport LBT-RM Reliability Options</a> <br />
<a class="el" href="grptransportlbtrureliability.html">Transport LBT-RU Reliability Options</a></dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="preventingundetectedloss"></a>
Preventing Undetected Unrecoverable Loss&nbsp;&nbsp;<small><a href="#preventingundetectedloss">&lt;-</a></small></h1>
<p>The UM UDP-based protocols are generally able to successfully recover packet loss. However, there can be cases where UM is not able to recover the lost packets, leading to <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Config/design.tag:../Design/" href="../Design/fundamentalconcepts.html#unrecoverableloss1">Unrecoverable Loss</a>.</p>
<p>With the default settings, there is a type of unrecoverable loss which can remain unreported to the application for an unbounded period of time.</p>
<p>For example: </p><ol>
<li>
A sudden burst of data from a source overloads a receiver, resulting in the last few packets being lost. </li>
<li>
The source sends one more data message and then exits. </li>
<li>
The receiver's <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Config/design.tag:../Design/" href="../Design/fundamentalconcepts.html#deliverycontroller">Delivery Controller</a> gets the last message and sees the sequence number gap. So it buffers the last message and waits for the transport layer to recover the missing messages. But since the source no longer exists, there is no recovery. </li>
<li>
The NAK generation interval lapses. Thus, the gapped messages are considered unrecoverable. However, due to UM's design, a receive event is needed to deliver the unrecoverable loss event and the buffered message. But since the source is deleted, no more receive events will happen. The delivery controller is an a "stale loss" state. </li>
<li>
Finally, the transport session times out and the delivery controller is deleted, delivering EOS to the application, but not the unrecoverable loss event or the buffered message. </li>
</ol>
<p>In this scenario, not only is the unrecoverable loss not delivered, but the buffered message which was successfully received is also never delivered. Note that this kind of <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.16.1/doc/Config/design.tag:../Design/" href="../Design/fundamentalconcepts.html#tailloss">Tail Loss</a> is rare, but can happen.</p>
<p>This result can be avoided by enabling the "loss check interval" feature on the delivery controller. For example: </p><pre class="fragment">receiver delivery_control_loss_check_interval 2500
</pre><p> This starts a timer that wakes up every 2.5 seconds and scans UM's internal list of all topic receivers, looking for delivery controllers in the "stale loss" state. For each one it finds, it generates the unrecoverable loss event to the application's receiver callback, and also delivers the subsequently buffered message.</p>
<p>However, for applications that have large numbers of receivers, the cost of scanning every receiver can become significant, introducing regular latency outliers. For latency-sensitive applications, an alternate method to avoid the unreported loss is to make sure <a class="el" href="grpmajoroptions.html#transporttopicsequencenumberinfointervalsource">transport_topic_sequence_number_info_interval (source)</a> is non-zero, and have the publisher delays two of those intervals plus the NAK generation interval (default: 2*5+60=70 seconds) before deleting a source that isn't needed any more. The TSNI messages will serve as receiver events to force delivery. See <a class="el" href="interrelatedconfigurationoptions.html#preventingtaillosswithtsniandnakintervaloptions">Preventing Tail Loss With TSNI and NAK Interval Options</a>.</p>
<p>Be aware that the <a class="el" href="grpdeliverycontrol.html#deliverycontrollosscheckintervalreceiver">delivery_control_loss_check_interval (receiver)</a> can interact with other interval configurations.</p>
<dl class="section user"><dt><b>Interrelated</b> <b>Options</b>:</dt><dd><ul>
<li>
<a class="el" href="grpdeliverycontrol.html#deliverycontrollosscheckintervalreceiver">delivery_control_loss_check_interval (receiver)</a> </li>
<li>
<a class="el" href="grptransportlbtrmoperation.html#transportlbtrmactivitytimeoutreceiver">transport_lbtrm_activity_timeout (receiver)</a> </li>
<li>
<a class="el" href="grptransportlbtrmreliability.html#transportlbtrmnakgenerationintervalreceiver">transport_lbtrm_nak_generation_interval (receiver)</a> </li>
<li>
<a class="el" href="grptransportlbtruoperation.html#transportlbtruactivitytimeoutreceiver">transport_lbtru_activity_timeout (receiver)</a> </li>
</ul>
</dd></dl>
<dl class="section user"><dt><b>Recommendation</b>, if using loss check interval:</dt><dd>For LBT-RM, set the transport activity timeout to value greater than the sum of the delivery control loss check interval and the NAK generation interval. Also, set the NAK generation interval to at least 4x the delivery control loss check interval. <br />
For LBT-RU, set the transport activity timeout to value greater than the delivery control loss check interval <br />
For UMP, always enable and set accordingly the delivery control loss check interval when configuring a store</dd></dl>
<dl class="section user"><dt><b>Example</b>:</dt><dd><pre class="fragment">#
# To avoid undetected or unreported loss, set NAK generation to 4x the delivery
# control check interval, and ensure that these two combined are less than the
# transport activity timeout
#
receiver delivery_control_loss_check_interval 2500
receiver transport_lbtrm_activity_timeout 60000
receiver transport_lbtrm_nak_generation_interval 10000
</pre></dd></dl>
<dl class="section user"><dt><b>See</b> <b>also</b>:</dt><dd><a class="el" href="grpdeliverycontrol.html">Delivery Control Options</a></dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="preventingundetectedlatejoinloss"></a>
Preventing Undetected Late Join Loss&nbsp;&nbsp;<small><a href="#preventingundetectedlatejoinloss">&lt;-</a></small></h1>
<p>If during a Late Join operation, a transport times out while a receiver is requesting retransmission of missing messages, this can cause lost messages to go undetected and likely become unrecoverable.</p>
<dl class="section user"><dt><b>Interrelated</b> <b>Options</b>:</dt><dd><ul>
<li>
<a class="el" href="grpdeprecated.html#retransmitrequestgenerationintervalreceiver">retransmit_request_generation_interval (receiver)</a> </li>
<li>
<a class="el" href="grptransporttcpoperation.html#transporttcpactivitytimeoutreceiver">transport_tcp_activity_timeout (receiver)</a> </li>
<li>
<a class="el" href="grptransportlbtrmoperation.html#transportlbtrmactivitytimeoutreceiver">transport_lbtrm_activity_timeout (receiver)</a> </li>
<li>
<a class="el" href="grptransportlbtruoperation.html#transportlbtruactivitytimeoutreceiver">transport_lbtru_activity_timeout (receiver)</a> </li>
<li>
<a class="el" href="grptransportlbtipcoperation.html#transportlbtipcactivitytimeoutreceiver">transport_lbtipc_activity_timeout (receiver)</a> </li>
</ul>
</dd></dl>
<dl class="section user"><dt><b>Recommendations</b>:</dt><dd>Set the Late Join retransmit request interval to a value less than its transport's activity timeout value</dd></dl>
<dl class="section user"><dt><b>Example</b>:</dt><dd><pre class="fragment">#
# To avoid a transport inactivity timeout while requesting Late Join
# retransmissions, set the Late Join retransmit request interval to a value
# less than its transport's activity timeout.
#
receiver retransmit_request_generation_interval 10000
receiver transport_lbtrm_activity_timeout 60000
</pre></dd></dl>
<dl class="section user"><dt><b>See</b> <b>also</b>:</dt><dd><a class="el" href="grplatejoin.html">Late Join Options</a></dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="preventingipcreceiverdeafnesswithkeepaliveoptions"></a>
Preventing IPC Receiver Deafness With Keepalive Options&nbsp;&nbsp;<small><a href="#preventingipcreceiverdeafnesswithkeepaliveoptions">&lt;-</a></small></h1>
<p>With an LBT-IPC transport, an activity timeout that is too small relative to the session message interval may cause receiver deafness. If a timeout is too short, the keepalive messages might not be received in time to prevent the receiver from being deleted or disconnecting because the source appears to be gone.</p>
<dl class="section user"><dt><b>Interrelated</b> <b>Options</b>:</dt><dd><ul>
<li>
<a class="el" href="grptransportlbtipcoperation.html#transportlbtipcactivitytimeoutreceiver">transport_lbtipc_activity_timeout (receiver)</a> </li>
<li>
<a class="el" href="grptransportlbtipcoperation.html#transportlbtipcsmintervalsource">transport_lbtipc_sm_interval (source)</a> </li>
</ul>
</dd></dl>
<dl class="section user"><dt><b>Recommendations</b>:</dt><dd>Set the activity timeout to at least 2x the session message interval</dd></dl>
<dl class="section user"><dt><b>Example</b>:</dt><dd><pre class="fragment">#
# To avoid receiver deafness:
# - set client activity timeout to at least 2x the acknowledgement interval.
# - set activity timeout to at least 2x the session message interval.
#
receiver transport_lbtipc_activity_timeout 60000
source   transport_lbtipc_sm_interval      10000
</pre></dd></dl>
<dl class="section user"><dt><b>See</b> <b>also</b>:</dt><dd><a class="el" href="grptransportlbtipcoperation.html">Transport LBT-IPC Operation Options</a></dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="preventingerroneouslbtrmlbtrusessiontimeouts"></a>
Preventing Erroneous LBT-RM/LBT-RU Session Timeouts&nbsp;&nbsp;<small><a href="#preventingerroneouslbtrmlbtrusessiontimeouts">&lt;-</a></small></h1>
<p>An LBT-RM or LBT-RU receiver-side quiescent timeout may delete a transport session that a source is still active on. This can happen if the timeout is too short relative to the source's interval between session messages (which serve as a session keepalive).</p>
<dl class="section user"><dt><b>Interrelated</b> <b>Options</b>:</dt><dd><ul>
<li>
<a class="el" href="grptransportlbtrmoperation.html#transportlbtrmactivitytimeoutreceiver">transport_lbtrm_activity_timeout (receiver)</a> </li>
<li>
<a class="el" href="grptransportlbtrmoperation.html#transportlbtrmsmmaximumintervalsource">transport_lbtrm_sm_maximum_interval (source)</a> </li>
<li>
<a class="el" href="grptransportlbtruoperation.html#transportlbtruactivitytimeoutreceiver">transport_lbtru_activity_timeout (receiver)</a> </li>
<li>
<a class="el" href="grptransportlbtruoperation.html#transportlbtrusmmaximumintervalsource">transport_lbtru_sm_maximum_interval (source)</a> </li>
</ul>
</dd></dl>
<dl class="section user"><dt><b>Recommendations</b>:</dt><dd>Set the receiver LBT-RM or LBT-RU activity timeout to at least 3x the source session message maximum interval.</dd></dl>
<dl class="section user"><dt><b>Example</b>:</dt><dd><pre class="fragment">#
# To avoid erroneous session timeouts, set receiver transport activity
# timeout to at least 3x the source session message maximum interval.
#
receiver  transport_lbtrm_activity_timeout    60000
source    transport_lbtrm_sm_maximum_interval 10000
receiver  transport_lbtru_activity_timeout    60000
source    transport_lbtru_sm_maximum_interval 10000
</pre></dd></dl>
<dl class="section user"><dt><b>See</b> <b>also</b>:</dt><dd><a class="el" href="grptransportlbtrmoperation.html">Transport LBT-RM Operation Options</a> <br />
<a class="el" href="grptransportlbtruoperation.html">Transport LBT-RU Operation Options</a></dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="preventingerrorsduetobadmulticastaddressranges"></a>
Preventing Errors Due to Bad Multicast Address Ranges&nbsp;&nbsp;<small><a href="#preventingerrorsduetobadmulticastaddressranges">&lt;-</a></small></h1>
<p>Sometimes it is easy to accidentally reverse the low and high values for LBT-RM multicast addresses, which actually creates a very large range. Aside from excluding intended addresses, this can cause error conditions.</p>
<dl class="section user"><dt><b>Interrelated</b> <b>Options</b>:</dt><dd><ul>
<li>
<a class="el" href="grptransportlbtrmnetwork.html#transportlbtrmmulticastaddresslowcontext">transport_lbtrm_multicast_address_low (context)</a> </li>
<li>
<a class="el" href="grptransportlbtrmnetwork.html#transportlbtrmmulticastaddresshighcontext">transport_lbtrm_multicast_address_high (context)</a> </li>
</ul>
</dd></dl>
<dl class="section user"><dt><b>Recommendations</b>:</dt><dd>Ensure that the intended low and high values for LBT-RM multicast addresses are not reversed</dd></dl>
<dl class="section user"><dt><b>Example</b>:</dt><dd><pre class="fragment">#
# To avoid incorrect LBT-RM multicast address ranges, ensure that you have not
# reversed the low and high values.
#
context transport_lbtrm_multicast_address_low 239.101.4.10.10
context transport_lbtrm_multicast_address_high 239.101.4.10.14
</pre></dd></dl>
<dl class="section user"><dt><b>See</b> <b>also</b>:</dt><dd><a class="el" href="grptransportlbtrmnetwork.html">Transport LBT-RM Network Options</a></dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="preventingstoretimeouts"></a>
Preventing Store Timeouts&nbsp;&nbsp;<small><a href="#preventingstoretimeouts">&lt;-</a></small></h1>
<p>When using Persistence, a store may be erroneously declared unresponsive if its activity timeout expires before it has had adequate opportunity to verify it is still active via activity check intervals.</p>
<dl class="section user"><dt><b>Interrelated</b> <b>Options</b>:</dt><dd><ul>
<li>
<a class="el" href="grpultramessagingpersistence.html#umestoreactivitytimeoutsource">ume_store_activity_timeout (source)</a> </li>
<li>
<a class="el" href="grpultramessagingpersistence.html#umestorecheckintervalsource">ume_store_check_interval (source)</a> </li>
</ul>
</dd></dl>
<dl class="section user"><dt><b>Recommendations</b>:</dt><dd>Set the store activity timeout to at least 5x the activity check interval</dd></dl>
<dl class="section user"><dt><b>Example</b>:</dt><dd><pre class="fragment">#
# To avoid erroneous store activity timeouts, set the activity
# timeout to at least 5x the activity check interval.
#
source ume_store_activity_timeout 3000
source ume_store_check_interval 500
</pre></dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="preventingulbtimeouts"></a>
Preventing ULB Timeouts&nbsp;&nbsp;<small><a href="#preventingulbtimeouts">&lt;-</a></small></h1>
<p>When using ULB queuing, ULB source or receiver may be erroneously declared unresponsive if its activity timeout expires before it has had adequate opportunities to attempt to re-register via activity check intervals if the source appears to be inactive. It is also possible for sources to attempt to reassign messages that have already been processed.</p>
<dl class="section user"><dt><b>Interrelated</b> <b>Options</b>:</dt><dd><ul>
<li>
<a class="el" href="grpultramessagingqueuing.html#umqulbsourceactivitytimeoutreceiver">umq_ulb_source_activity_timeout (receiver)</a> </li>
<li>
<a class="el" href="grpultramessagingqueuing.html#umqulbsourcecheckintervalreceiver">umq_ulb_source_check_interval (receiver)</a> </li>
<li>
<a class="el" href="grpultramessagingqueuing.html#umqulbapplicationsetmessagereassignmenttimeoutsource">umq_ulb_application_set_message_reassignment_timeout (source)</a> </li>
<li>
<a class="el" href="grpultramessagingqueuing.html#umqulbapplicationsetreceiveractivitytimeoutsource">umq_ulb_application_set_receiver_activity_timeout (source)</a> </li>
<li>
<a class="el" href="grpultramessagingqueuing.html#umqulbcheckintervalsource">umq_ulb_check_interval (source)</a> </li>
</ul>
</dd></dl>
<dl class="section user"><dt><b>Recommendations</b>:</dt><dd>Set the ULB source activity timeout to at least 5x the ULB source activity check interval. <br />
Set the ULB application set message reassignment timeout to at least 5x the ULB check interval. <br />
Set the ULB receiver activity timeout to at least 5x the ULB check interval.</dd></dl>
<dl class="section user"><dt><b>Example</b>:</dt><dd><pre class="fragment">#
# To avoid erroneous ULB source, receiver or application set message activity
# timeouts, set the activity timeout to at least 5x the activity check interval.
#
receiver umq_ulb_source_activity_timeout 10000
receiver umq_ulb_source_check_interval   1000
source   umq_ulb_application_set_message_reassignment_timeout 50000
source   umq_ulb_application_set_receiver_activity_timeout    10000
source   umq_ulb_check_interval 1000
</pre></dd></dl>
<dl class="section user"><dt><b>See</b> <b>also</b>:</dt><dd><a class="el" href="grpultramessagingqueuing.html">Ultra Messaging Queuing Options</a> ]]])</dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="preventingunicastresolverdaemontimeouts"></a>
Preventing Unicast Resolver Daemon Timeouts&nbsp;&nbsp;<small><a href="#preventingunicastresolverdaemontimeouts">&lt;-</a></small></h1>
<p>A unicast resolver daemon may be erroneously declared inactive if its activity timeout expires before it has had adequate opportunity to verify that it is still alive.</p>
<dl class="section user"><dt><b>Interrelated</b> <b>Options</b>:</dt><dd><ul>
<li>
<a class="el" href="grpudpbasedresolveroperation.html#resolverunicastactivitytimeoutcontext">resolver_unicast_activity_timeout (context)</a> </li>
<li>
<a class="el" href="grpudpbasedresolveroperation.html#resolverunicastcheckintervalcontext">resolver_unicast_check_interval (context)</a> </li>
</ul>
</dd></dl>
<dl class="section user"><dt><b>Recommendations</b>:</dt><dd>Set the unicast resolver daemon activity timeout to at least 5x the activity check interval. Or, if activity notification is not desired, set both options to 0.</dd></dl>
<dl class="section user"><dt><b>Example</b>:</dt><dd><pre class="fragment">#
# To avoid erroneous unicast resolver daemon timeouts, set the activity
# timeout to at least 5x the activity check interval.
#
context resolver_unicast_activity_timeout 1000
context resolver_unicast_check_interval 200
</pre></dd></dl>
<dl class="section user"><dt><b>See</b> <b>also</b>:</dt><dd><a class="el" href="grpudpbasedresolveroperation.html">UDP-Based Resolver Operation Options</a></dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="preventingstoreregistrationhangs"></a>
Preventing Store Registration Hangs&nbsp;&nbsp;<small><a href="#preventingstoreregistrationhangs">&lt;-</a></small></h1>
<p>The following configuration options come into play when sources register with stores in a lossy environment:</p>
<dl class="section user"><dt><b>Interrelated</b> <b>Options</b>:</dt><dd><ul>
<li>
<a class="el" href="grpultramessagingpersistence.html#umesrirequestintervalreceiver">ume_sri_request_interval (receiver)</a> </li>
<li>
<a class="el" href="grpultramessagingpersistence.html#umesrirequestmaximumreceiver">ume_sri_request_maximum (receiver)</a> </li>
<li>
<a class="el" href="grpmajoroptions.html#transporttopicsequencenumberinforequestintervalreceiver">transport_topic_sequence_number_info_request_interval (receiver)</a> </li>
<li>
<a class="el" href="grpmajoroptions.html#transporttopicsequencenumberinforequestmaximumreceiver">transport_topic_sequence_number_info_request_maximum (receiver)</a> </li>
<li>
<a class="el" href="grptransporttcpoperation.html#transporttcpactivitytimeoutreceiver">transport_tcp_activity_timeout (receiver)</a> </li>
<li>
<a class="el" href="grptransportlbtrmoperation.html#transportlbtrmactivitytimeoutreceiver">transport_lbtrm_activity_timeout (receiver)</a> </li>
<li>
<a class="el" href="grptransportlbtruoperation.html#transportlbtruactivitytimeoutreceiver">transport_lbtru_activity_timeout (receiver)</a> </li>
<li>
<a class="el" href="grptransportlbtipcoperation.html#transportlbtipcactivitytimeoutreceiver">transport_lbtipc_activity_timeout (receiver)</a> </li>
</ul>
</dd></dl>
<p>The sri_request "interval" and "maximum" options multiply to define a duration over which the receiver requests Store Information Records (SRI) messages from the source. Similarly, the transport_topic_sequence_number_info_request "interval" and "maximum" options multiply to define a duration over which the receiver requests Transport Topic Sequence Number Info (TSNI) messages from the source.</p>
<dl class="section user"><dt><b>Recommendations</b>:</dt><dd></dd></dl>
<p>The two request durations should be twice the value of the appropriate transport activity timer.</p>
<dl class="section user"><dt><b>Example</b>:</dt><dd><pre class="fragment">#
# To avoid hung store registration, set the durations of the SRI and TSNI
# requests to 2x the transport activity timeout.
# 
receiver transport_lbtrm_activity_timeout 60000
receiver ume_sri_request_maximum 120
receiver ume_sri_request_interval 1000
receiver transport_topic_sequence_number_info_request_maximum 120
receiver transport_topic_sequence_number_info_request_interval 1000
</pre></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>As of this version of UM, the default values for these options do not satisfy this recommendation. Users are advised to double the values for <a class="el" href="grpultramessagingpersistence.html#umesrirequestmaximumreceiver">ume_sri_request_maximum (receiver)</a> and <a class="el" href="grpmajoroptions.html#transporttopicsequencenumberinforequestmaximumreceiver">transport_topic_sequence_number_info_request_maximum (receiver)</a>.</dd></dl>
<p><br />
<br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
</body>
</html>
