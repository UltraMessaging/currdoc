<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Configuration Guide: Transport TCP Operation Options</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen_manual.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Configuration Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('grptransporttcpoperation.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Transport TCP Operation Options </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><br />
 </p>
<h1><a class="anchor" id="transporttcpoperationref"></a>
Reference&nbsp;&nbsp;<small><a href="#transporttcpoperationref">&lt;-</a></small></h1>
<p><br />
 </p>
<h2><a class="anchor" id="transportsessionmaximumbuffersource"></a>
transport_session_maximum_buffer (source)&nbsp;&nbsp;<small><a href="#transportsessionmaximumbuffersource">&lt;-</a></small></h2>
<dl class="section user"><dt></dt><dd>Value used to control the maximum amount of data buffered in UM for the transport session used for the topic. </dd></dl>
<dl class="section user"><dt></dt><dd>For the normal multiple receiver behavior, this value represents the total buffered by all TCP receivers. For the bounded_latency and source_paced multiple receiver behavior, this value represents the individual receiver buffered amount. This option affects the transport session underlying the source rather than the source itself. The transport session uses the value from the first source created on the session and ignores subsequent sources' configuration. </dd></dl>
<dl class="section user"><dt></dt><dd>Refer to <a class="elRef" doxygen="/29W/Amun/home/sford/backup_exclude/labbox/sfordmac_REL_6_13/29West/lbm/doc/Config/design.tag:../Design/" href="../Design/fundamentalconcepts.html#sourceobject">Source Object</a> for additional information.</dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><em>Scope:</em> </td><td>source </td></tr>
<tr>
<td><em>Type:</em> </td><td><b><a class="elRef" doxygen="/29W/Amun/home/sford/backup_exclude/labbox/sfordmac_REL_6_13/29West/lbm/doc/Config/api.tag:../API/" href="../API/lbm_8h.html#a72438fab15bf500af58d2a8a521e470d">lbm_ulong_t</a></b> </td></tr>
<tr>
<td><em>Units:</em> </td><td>bytes </td></tr>
<tr>
<td><em>Default value:</em> </td><td>65536 </td></tr>
<tr>
<td><em>When to Set:</em> </td><td>Can only be set during object initialization.</td></tr>
</table>
</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="transporttcpactivitymethodreceiver"></a>
transport_tcp_activity_method (receiver)&nbsp;&nbsp;<small><a href="#transporttcpactivitymethodreceiver">&lt;-</a></small></h2>
<dl class="section user"><dt></dt><dd>The type of timeout method to use for TCP receivers to detect "half-open" TCP connections. </dd></dl>
<dl class="section user"><dt></dt><dd>For TCP sessions only. </dd></dl>
<dl class="section user"><dt></dt><dd>This defines how <a class="el" href="grptransporttcpoperation.html#transporttcpactivitytimeoutreceiver">transport_tcp_activity_timeout (receiver)</a> is interpreted. Note that <a class="el" href="grptransporttcpoperation.html#transporttcpactivitytimeoutreceiver">transport_tcp_activity_timeout (receiver)</a> defaults to 0 (disabled), meaning that half-open TCP connections may not be detected in a timely way.</dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><em>Scope:</em> </td><td>receiver </td></tr>
<tr>
<td><em>Type:</em> </td><td><b>int</b> </td></tr>
<tr>
<td><em>When to Set:</em> </td><td>Can only be set during object initialization.</td></tr>
<tr>
<td><em>Version:</em> </td><td>This option was implemented in LBM 3.3.8/UME 2.0.6. </td></tr>
</table>
<br />
</dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>String value </th><th>Integer value </th><th>Description </th></tr>
<tr>
<td>"timer" </td><td>LBM_RCV_TOPIC_ATTR_TCP_ACTIVITY_TIMEOUT_TIMER </td><td>Timer method that requires new TCP session data to be sent to determine if the connection is alive. <b>Default for all.</b> </td></tr>
<tr>
<td>"SO_KEEPALIVE" </td><td>LBM_RCV_TOPIC_ATTR_TCP_ACTIVITY_TIMEOUT_SO_KEEPALIVE </td><td>Set SO_KEEPALIVE on the TCP connection which uses the TCP keepalive support in the operating system to determine if the connection is alive. When you use the SO_KEEPALIVE method, UM uses <a class="el" href="grptransporttcpoperation.html#transporttcpactivitytimeoutreceiver">transport_tcp_activity_timeout (receiver)</a> value to set the idle and probe times for SO_KEEPALIVE. The idle time is 90% of the timeout value at most. The probe time is 10% with 10 seconds as the minimum. </td></tr>
</table>
</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="transporttcpactivitytimeoutreceiver"></a>
transport_tcp_activity_timeout (receiver)&nbsp;&nbsp;<small><a href="#transporttcpactivitytimeoutreceiver">&lt;-</a></small></h2>
<dl class="section user"><dt></dt><dd>A timeout used by a receiver to close a TCP transport session that has no activity. </dd></dl>
<dl class="section user"><dt></dt><dd>For TCP sessions only. </dd></dl>
<dl class="section user"><dt></dt><dd>Normally, when a source transport session is deleted by the sending application, the TCP connection is closed, which the receiver detects within a few milliseconds. However, there are unusual situations where a temporary network outage prevents the receiver from detecting the closing of the connection, resulting in a "half-open" connection. This situation can prevent the receiver from detecting the closed connection for an unbounded time. </dd></dl>
<dl class="section user"><dt></dt><dd>This timeout can be used to detect and close half-open connections. </dd></dl>
<dl class="section user"><dt></dt><dd>This option has two different meanings, depending on the setting of <a class="el" href="grptransporttcpoperation.html#transporttcpactivitymethodreceiver">transport_tcp_activity_method (receiver)</a>. See that option for details. </dd></dl>
<dl class="section user"><dt></dt><dd>A value greater than zero turns the timer on.</dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><em>Scope:</em> </td><td>receiver </td></tr>
<tr>
<td><em>Type:</em> </td><td><b><a class="elRef" doxygen="/29W/Amun/home/sford/backup_exclude/labbox/sfordmac_REL_6_13/29West/lbm/doc/Config/api.tag:../API/" href="../API/lbm_8h.html#a72438fab15bf500af58d2a8a521e470d">lbm_ulong_t</a></b> </td></tr>
<tr>
<td><em>Units:</em> </td><td>milliseconds </td></tr>
<tr>
<td><em>Default value:</em> </td><td>0 </td></tr>
<tr>
<td><em>When to Set:</em> </td><td>Can only be set during object initialization.</td></tr>
</table>
</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="transporttcpactivitytimeoutsource"></a>
transport_tcp_activity_timeout (source)&nbsp;&nbsp;<small><a href="#transporttcpactivitytimeoutsource">&lt;-</a></small></h2>
<dl class="section user"><dt></dt><dd>This timeout option enables a source to use SO_KEEPALIVE to detect when a receiver does not cleanly disconnect or is no longer reachable from the source. </dd></dl>
<dl class="section user"><dt></dt><dd>For TCP sessions only. </dd></dl>
<dl class="section user"><dt></dt><dd>When the timeout expires, a DISCONNECT source event is delivered. This option affects only Linux or Windows platforms. Outstanding TCP retransmit timers must expire before this timer starts. With a default Linux or Windows system configuration, TCP retransmit timers may take minutes or even hours to expire. Therefore the total time taken to detect an unreachable receiver may be significantly higher than the value configured for this timeout. A value of zero (0) defers TCP timeout to OS settings.</dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><em>Scope:</em> </td><td>source </td></tr>
<tr>
<td><em>Type:</em> </td><td><b><a class="elRef" doxygen="/29W/Amun/home/sford/backup_exclude/labbox/sfordmac_REL_6_13/29West/lbm/doc/Config/api.tag:../API/" href="../API/lbm_8h.html#a72438fab15bf500af58d2a8a521e470d">lbm_ulong_t</a></b> </td></tr>
<tr>
<td><em>Units:</em> </td><td>milliseconds </td></tr>
<tr>
<td><em>Default value:</em> </td><td>0 </td></tr>
<tr>
<td><em>When to Set:</em> </td><td>Can only be set during object initialization.</td></tr>
</table>
</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="transporttcpcoalescethresholdsource"></a>
transport_tcp_coalesce_threshold (source)&nbsp;&nbsp;<small><a href="#transporttcpcoalescethresholdsource">&lt;-</a></small></h2>
<dl class="section user"><dt></dt><dd>UM passes implicitly batched messages to the Operating System sendmsg() as a set unless the size of the set exceeds the coalescing threshold at which point the messages are coalesced and passed to the O/S as one copy. </dd></dl>
<dl class="section user"><dt></dt><dd>This option accommodates the different number of iovecs supported by different O/Ss. Tuning this option balances the efficiency of less iovecs handled by the OS vs. the expense of an additional copy operation of the messages before sending. The default values are also the maximum allowable values.</dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><em>Scope:</em> </td><td>source </td></tr>
<tr>
<td><em>Type:</em> </td><td><b>int</b> </td></tr>
<tr>
<td><em>Units:</em> </td><td>number of individual messages </td></tr>
<tr>
<td><em>Default value:</em> </td><td>1024 for Linux, Microsoft Windows, Darwin; 16 for Solaris, AIX, HPUX </td></tr>
<tr>
<td><em>When to Set:</em> </td><td>Can only be set during object initialization.</td></tr>
<tr>
<td><em>Version:</em> </td><td>This option was implemented in LBM 3.6/UME 2.3. </td></tr>
</table>
</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="transporttcpdatagrammaxsizecontext"></a>
transport_tcp_datagram_max_size (context)&nbsp;&nbsp;<small><a href="#transporttcpdatagrammaxsizecontext">&lt;-</a></small></h2>
<dl class="section user"><dt></dt><dd>The maximum datagram size that can be generated for a TCP transport session. While TCP does not use UDP datagrams, this option limits the size of the UM message which is given to the underlying transport type, including all UM headers and overhead. It does not include TCP, IP, or packet overhead added by the network stack. The default value is 65535, the minimum is 500 bytes, and the maximum is 65535. </dd></dl>
<dl class="section user"><dt></dt><dd>See <a class="elRef" doxygen="/29W/Amun/home/sford/backup_exclude/labbox/sfordmac_REL_6_13/29West/lbm/doc/Config/design.tag:../Design/" href="../Design/architecture.html#messagefragmentationandreassembly">Message Fragmentation and Reassembly</a> for more information. </dd></dl>
<dl class="section user"><dt></dt><dd>Informatica does not recommend setting datagram max size options to the network MTU. See <a class="elRef" doxygen="/29W/Amun/home/sford/backup_exclude/labbox/sfordmac_REL_6_13/29West/lbm/doc/Config/design.tag:../Design/" href="../Design/architecture.html#datagrammaxsizeandnetworkmtu">Datagram Max Size and Network MTU</a>. </dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>When the DRO is in use, it is recommended that all UM applications and components (including the DRO and Persistent Store) share the same maximum datagram size setting. See <a class="elRef" doxygen="/29W/Amun/home/sford/backup_exclude/labbox/sfordmac_REL_6_13/29West/lbm/doc/Config/gateway.tag:../Gateway/" href="../Gateway/umrouterconcepts.html#protocolconversion">Protocol Conversion</a>.</dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><em>Scope:</em> </td><td>context </td></tr>
<tr>
<td><em>Type:</em> </td><td><b><a class="elRef" doxygen="/29W/Amun/home/sford/backup_exclude/labbox/sfordmac_REL_6_13/29West/lbm/doc/Config/api.tag:../API/" href="../API/lbm_8h.html#abdb96b55cc467a75e1f9ec0036dbc14b">lbm_uint_t</a></b> </td></tr>
<tr>
<td><em>Units:</em> </td><td>bytes </td></tr>
<tr>
<td><em>Default value:</em> </td><td>65535 </td></tr>
<tr>
<td><em>When to Set:</em> </td><td>Can only be set during object initialization.</td></tr>
<tr>
<td><em>Version:</em> </td><td>This option was implemented in LBM 4.1/UME 3.1/UMQ 1.1 </td></tr>
</table>
</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="transporttcpdrolossrecoverytimeoutreceiver"></a>
transport_tcp_dro_loss_recovery_timeout (receiver)&nbsp;&nbsp;<small><a href="#transporttcpdrolossrecoverytimeoutreceiver">&lt;-</a></small></h2>
<dl class="section user"><dt></dt><dd>For TCP transport sessions originating from a DRO endpoint portal, delay declaring as unrecoverable a lost message. </dd></dl>
<dl class="section user"><dt></dt><dd>Message streams traversing a DRO can have the message order changed. If the DRO's outgoing transport session uses the TCP protocol, these out-of-order messages will normally trigger immediate unrecoverable loss. This timeout allows an opportunity for the messages to be re-ordered properly. </dd></dl>
<dl class="section user"><dt></dt><dd>The value 0 disables this delay (i.e. receivers immediately declare unrecoverable loss). </dd></dl>
<dl class="section user"><dt></dt><dd>See <a class="elRef" doxygen="/29W/Amun/home/sford/backup_exclude/labbox/sfordmac_REL_6_13/29West/lbm/doc/Config/gateway.tag:../Gateway/" href="../Gateway/umrouterimplementation.html#umrouterreliableloss">DRO Reliable Loss</a> for more information.</dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><em>Scope:</em> </td><td>receiver </td></tr>
<tr>
<td><em>Type:</em> </td><td><b><a class="elRef" doxygen="/29W/Amun/home/sford/backup_exclude/labbox/sfordmac_REL_6_13/29West/lbm/doc/Config/api.tag:../API/" href="../API/lbm_8h.html#a72438fab15bf500af58d2a8a521e470d">lbm_ulong_t</a></b> </td></tr>
<tr>
<td><em>Units:</em> </td><td>milliseconds </td></tr>
<tr>
<td><em>Default value:</em> </td><td>0 </td></tr>
<tr>
<td><em>When to Set:</em> </td><td>Can only be set during object initialization.</td></tr>
<tr>
<td><em>Version:</em> </td><td>This option was implemented in LBM 6.12 </td></tr>
</table>
</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="transporttcpexclusiveaddrsource"></a>
transport_tcp_exclusiveaddr (source)&nbsp;&nbsp;<small><a href="#transporttcpexclusiveaddrsource">&lt;-</a></small></h2>
<dl class="section user"><dt></dt><dd>Indicate whether the TCP session should set SO_EXCLUSIVEADDRUSE or not before it binds. </dd></dl>
<dl class="section user"><dt></dt><dd>Applicable only to Windows. The default setting in Windows allows multiple binds to the same port. By default, UM will set SO_EXCLUSIVEADDRUSE to minimize port sharing. Refer to Microsoft's web site for more information on SO_EXCLUSIVEADDRUSE.</dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><em>Scope:</em> </td><td>source </td></tr>
<tr>
<td><em>Type:</em> </td><td><b>int</b> </td></tr>
<tr>
<td><em>When to Set:</em> </td><td>Can only be set during object initialization.</td></tr>
</table>
<br />
</dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Value </th><th>Description </th></tr>
<tr>
<td>1 </td><td>Set SO_EXCLUSIVEADDRUSE. <b>Default for Windows.</b> </td></tr>
<tr>
<td>0 </td><td><p class="starttd">Do not set SO_EXCLUSIVEADDRUSE.</p>
<p class="endtd"></p>
</td></tr>
</table>
</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="transporttcplistenbacklogsource"></a>
transport_tcp_listen_backlog (source)&nbsp;&nbsp;<small><a href="#transporttcplistenbacklogsource">&lt;-</a></small></h2>
<dl class="section user"><dt></dt><dd>The backlog used in the TCP listen() call to set the queue length for incoming connections. </dd></dl>
<dl class="section user"><dt></dt><dd>If 20 or more receivers will be joining this source, it may be beneficial to increase this number.</dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><em>Scope:</em> </td><td>source </td></tr>
<tr>
<td><em>Type:</em> </td><td><b>int</b> </td></tr>
<tr>
<td><em>Units:</em> </td><td>number of queued connections </td></tr>
<tr>
<td><em>Default value:</em> </td><td>5 </td></tr>
<tr>
<td><em>When to Set:</em> </td><td>Can only be set during object initialization.</td></tr>
</table>
</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="transporttcpmultiplereceiverbehaviorsource"></a>
transport_tcp_multiple_receiver_behavior (source)&nbsp;&nbsp;<small><a href="#transporttcpmultiplereceiverbehaviorsource">&lt;-</a></small></h2>
<dl class="section user"><dt></dt><dd>This option determines the flow control behavior of a TCP source that is sending to multiple receivers. </dd></dl>
<dl class="section user"><dt></dt><dd>In particular, it addresses the scenario where some receivers are consuming messages slower than other receivers (or not at all). In this scenario, pending messages will be buffered by the source up to the configured limit specified by the <a class="el" href="grptransporttcpoperation.html#transportsessionmaximumbuffersource">transport_session_maximum_buffer (source)</a> option. Once that limit is reached, the source can either wait for slow receivers (resulting in a blocked source) or discard messages from the buffer (resulting in gaps and potentially unrecoverable loss of messages for slow receivers). </dd></dl>
<dl class="section user"><dt></dt><dd>This option affects the transport session underlying the source rather than the source itself. The transport session uses the value from the first source created on the session and ignores the value set for subsequent sources. </dd></dl>
<dl class="section user"><dt></dt><dd>Refer to <a class="elRef" doxygen="/29W/Amun/home/sford/backup_exclude/labbox/sfordmac_REL_6_13/29West/lbm/doc/Config/design.tag:../Design/" href="../Design/fundamentalconcepts.html#sourceobject">Source Object</a> for additional information.</dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><em>Scope:</em> </td><td>source </td></tr>
<tr>
<td><em>Type:</em> </td><td><b>int</b> </td></tr>
<tr>
<td><em>When to Set:</em> </td><td>Can only be set during object initialization.</td></tr>
</table>
<br />
</dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>String value </th><th>Integer value </th><th>Description </th></tr>
<tr>
<td>"normal" </td><td>LBM_SRC_TOPIC_ATTR_TCP_MULTI_RECV_NORMAL </td><td>The application will wait for the slowest receiver rather than discarding recent messages. This slows down all sources on the TCP session. <b>Default for all.</b> </td></tr>
<tr>
<td>"source_paced" </td><td>LBM_SRC_TOPIC_ATTR_TCP_MULTI_RECV_SOURCE_PACED </td><td><p class="starttd">The application sends as fast as it can even if recent messages headed for any or all receivers must be discarded. Note that for applications requiring source-paced behavior, LBT-RU and LBT-RM are more efficient than source-paced TCP, so this setting is primarily for scenarios where UDP-based protocols are not viable.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>"bounded_latency" </td><td>LBM_SRC_TOPIC_ATTR_TCP_MULTI_RECV_BOUNDED_LATENCY </td><td><p class="starttd">The application sends as fast as the fastest receiver can consume data even if recent data headed for slower receivers must be discarded. Deprecated since UM 6.9.</p>
<p class="endtd"></p>
</td></tr>
</table>
</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="transporttcpmultiplereceiversendordersource"></a>
transport_tcp_multiple_receiver_send_order (source)&nbsp;&nbsp;<small><a href="#transporttcpmultiplereceiversendordersource">&lt;-</a></small></h2>
<dl class="section user"><dt></dt><dd>In the case of multiple receivers, this option determines whether datagrams are sent to each receiver in the established order of receivers, or if receivers are selected in random order for each datagram transmission. </dd></dl>
<dl class="section user"><dt></dt><dd>Using random ordering can avoid giving one receiver a consistent latency advantage, at the expense of slightly higher per-message processing (calculating the random number).</dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><em>Scope:</em> </td><td>source </td></tr>
<tr>
<td><em>Type:</em> </td><td><b>int</b> </td></tr>
<tr>
<td><em>When to Set:</em> </td><td>Can only be set during object initialization.</td></tr>
</table>
<br />
</dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>String value </th><th>Integer value </th><th>Description </th></tr>
<tr>
<td>"serial" </td><td>LBM_SRC_TOPIC_ATTR_TCP_MULTI_RECV_SEND_ORDER_SERIAL </td><td>Select receivers to receive a datagram based on current established order. <b>Default for all.</b> </td></tr>
<tr>
<td>"random" </td><td>LBM_SRC_TOPIC_ATTR_TCP_MULTI_RECV_SEND_ORDER_RANDOM </td><td><p class="starttd">For each datagram sent, select receivers in random order, for the sake of "fairness". Note that this option adds a small amount of CPU overhead.</p>
<p class="endtd"></p>
</td></tr>
</table>
</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="transporttcpnodelaysource"></a>
transport_tcp_nodelay (source)&nbsp;&nbsp;<small><a href="#transporttcpnodelaysource">&lt;-</a></small></h2>
<dl class="section user"><dt></dt><dd>Controls whether the context sets TCP_NODELAY before it binds to the source port. </dd></dl>
<dl class="section user"><dt></dt><dd>Setting TCP_NODELAY disables Nagle's algorithm, which somewhat decreases the efficiency and throughput of TCP, but decreases the latency of individual messages.</dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><em>Scope:</em> </td><td>source </td></tr>
<tr>
<td><em>Type:</em> </td><td><b>int</b> </td></tr>
<tr>
<td><em>When to Set:</em> </td><td>Can only be set during object initialization.</td></tr>
</table>
<br />
</dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Value </th><th>Description </th></tr>
<tr>
<td>1 </td><td>TCP transport sockets should set TCP_NODELAY (disable Nagle). <b>Default for all.</b> </td></tr>
<tr>
<td>0 </td><td><p class="starttd">TCP transport sockets should not set TCP_NODELAY (leave Nagle enabled).</p>
<p class="endtd"></p>
</td></tr>
</table>
</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="transporttcpreceiversocketbuffercontext"></a>
transport_tcp_receiver_socket_buffer (context)&nbsp;&nbsp;<small><a href="#transporttcpreceiversocketbuffercontext">&lt;-</a></small></h2>
<dl class="section user"><dt></dt><dd>Value used to set SO_RCVBUF value of the TCP receivers for topics. In some cases the OS will not allow all of this value to be used. </dd></dl>
<dl class="section user"><dt></dt><dd>A value of 0 instructs UM to use the default OS values. See <a class="el" href="generalconfigurationguidelines.html#socketbuffersizes">Socket Buffer Sizes</a> for platform-dependent information.</dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><em>Scope:</em> </td><td>context </td></tr>
<tr>
<td><em>Type:</em> </td><td><b><a class="elRef" doxygen="/29W/Amun/home/sford/backup_exclude/labbox/sfordmac_REL_6_13/29West/lbm/doc/Config/api.tag:../API/" href="../API/lbm_8h.html#a72438fab15bf500af58d2a8a521e470d">lbm_ulong_t</a></b> </td></tr>
<tr>
<td><em>Units:</em> </td><td>bytes </td></tr>
<tr>
<td><em>Default value:</em> </td><td>0 (use TCP autotuning) </td></tr>
<tr>
<td><em>When to Set:</em> </td><td>Can only be set during object initialization.</td></tr>
</table>
</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="transporttcpreuseaddrsource"></a>
transport_tcp_reuseaddr (source)&nbsp;&nbsp;<small><a href="#transporttcpreuseaddrsource">&lt;-</a></small></h2>
<dl class="section user"><dt></dt><dd>Whether the TCP session should set SO_REUSEADDR or not before it binds. </dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This option is not recommended for Microsoft Windows users because the SO_REUSEADDR socket option in Windows allows a socket to forcibly bind to a port in use by another socket. Multiple sockets using the same port results in indeterminate behavior.</dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><em>Scope:</em> </td><td>source </td></tr>
<tr>
<td><em>Type:</em> </td><td><b>int</b> </td></tr>
<tr>
<td><em>When to Set:</em> </td><td>Can only be set during object initialization.</td></tr>
</table>
<br />
</dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Value </th><th>Description </th></tr>
<tr>
<td>1 </td><td><p class="starttd">Set SO_REUSEADDR.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>0 </td><td>Do not set SO_REUSEADDR. <b>Default for all.</b> </td></tr>
</table>
</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="transporttcpsendersocketbuffersource"></a>
transport_tcp_sender_socket_buffer (source)&nbsp;&nbsp;<small><a href="#transporttcpsendersocketbuffersource">&lt;-</a></small></h2>
<dl class="section user"><dt></dt><dd>Value used to set the SO_SNDBUF value of the TCP session. </dd></dl>
<dl class="section user"><dt></dt><dd>In some cases the OS will not allow all of this value to be used. A value of 0 instructs UM to use the OS defaults. See <a class="el" href="generalconfigurationguidelines.html#socketbuffersizes">Socket Buffer Sizes</a> for platform-dependent information.</dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><em>Scope:</em> </td><td>source </td></tr>
<tr>
<td><em>Type:</em> </td><td><b><a class="elRef" doxygen="/29W/Amun/home/sford/backup_exclude/labbox/sfordmac_REL_6_13/29West/lbm/doc/Config/api.tag:../API/" href="../API/lbm_8h.html#a72438fab15bf500af58d2a8a521e470d">lbm_ulong_t</a></b> </td></tr>
<tr>
<td><em>Units:</em> </td><td>bytes </td></tr>
<tr>
<td><em>Default value:</em> </td><td>0 (use TCP autotuning) </td></tr>
<tr>
<td><em>When to Set:</em> </td><td>Can only be set during object initialization.</td></tr>
</table>
</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="transporttcpusesessionidsource"></a>
transport_tcp_use_session_id (source)&nbsp;&nbsp;<small><a href="#transporttcpusesessionidsource">&lt;-</a></small></h2>
<dl class="section user"><dt></dt><dd>Control whether a session ID is used for TCP Transport sessions. </dd></dl>
<dl class="section user"><dt></dt><dd>This option should be set to 0 if a version 6.0 (and beyond) TCP source must interoperate with a version pre-6.0 receiver.</dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td><em>Scope:</em> </td><td>source </td></tr>
<tr>
<td><em>Type:</em> </td><td><b>int</b> </td></tr>
<tr>
<td><em>When to Set:</em> </td><td>Can only be set during object initialization.</td></tr>
<tr>
<td><em>Version:</em> </td><td>This option was implemented in UM 6.0 </td></tr>
</table>
<br />
</dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Value </th><th>Description </th></tr>
<tr>
<td>1 </td><td>Indicates the application desires TCP to use a session ID. <b>Default for all.</b> </td></tr>
<tr>
<td>0 </td><td><p class="starttd">Indicates the application does not desire TCP to use a session ID. For use when version pre-6.0 receivers must be used with TCP sources that are version 6.0 and beyond.</p>
<p class="endtd"></p>
</td></tr>
</table>
</dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
</body>
</html>
