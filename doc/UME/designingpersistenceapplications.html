<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Guide for Persistence: Designing Persistence Applications</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen_manual.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Guide for Persistence
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('designingpersistenceapplications.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Designing Persistence Applications </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A persistent system is composed of sources, receivers, and stores managed by one or more applications. Sources and receivers are the endpoints of communication and the store(s) provide fault recovery and persistence of state information. Your application can leverage UM's flexible methods of persistence to add fault tolerance. With this flexibility, your applications assume new responsibilities not normally required in other persistent messaging systems. This section identifies the important considerations for your messaging applications when implementing the following persistence features:</p>
<ul>
<li>
<a class="el" href="designingpersistenceapplications.html#registrationidentifiers">Registration Identifiers</a> </li>
<li>
<a class="el" href="designingpersistenceapplications.html#designingpersistentsources">Designing Persistent Sources</a> </li>
<li>
<a class="el" href="designingpersistenceapplications.html#designingpersistentreceivers">Designing Persistent Receivers</a> </li>
<li>
<a class="el" href="designingpersistenceapplications.html#designingpersistentstores">Designing Persistent Stores</a> </li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="registrationidentifiers"></a>
Registration Identifiers&nbsp;&nbsp;<small><a href="#registrationidentifiers">&lt;-</a></small></h1>
<p>As mentioned in <a class="el" href="persistenceconcepts.html#registrationidentifierconcept">Registration Identifier Concept</a> and <a class="el" href="enablingpersistence.html#addingfaultrecoverywithregistrationids">Adding Fault Recovery with Registration IDs</a>, stores use RegIDs to identify sources and receivers. UM offers three main methods for managing RegIDs:</p>
<ul>
<li>
<p class="startli"><b>Recommended</b>: use Session IDs to enable the Store to both assign and manage RegIDs. See <a class="el" href="designingpersistenceapplications.html#managingregidswithsessionids">Managing RegIDs with Session IDs</a>. Note: while the use of Session IDs is recommended, an understanding of the underlying registration IDs is often helpful to understanding persistence.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Your applications assign static RegIDs and ensure that the same RegID is not assigned to multiple sources and/or receivers. See <a class="el" href="designingpersistenceapplications.html#usestaticregids">Use Static RegIDs</a>.</p>
<p class="endli"></p>
</li>
<li>
You can allow Stores to assign RegIDs and then save the assigned RegIDs for subsequent reuse. See <a class="el" href="designingpersistenceapplications.html#saveassignedregids">Save Assigned RegIDs</a>. </li>
</ul>
<p>Your applications can manage RegIDs for the lifetime of a source or receiver as long as multiple applications do not reuse RegIDs simultaneously on the same store. RegIDs only need to be unique on the same store and may be reused between stores as desired. You can use a static mapping of RegIDs to applications or use some simple service to assign them.</p>
<p><br />
 </p>
<h2><a class="anchor" id="usestaticregids"></a>
Use Static RegIDs&nbsp;&nbsp;<small><a href="#usestaticregids">&lt;-</a></small></h2>
<p>For very small deployments, the simplest method uses static RegIDs for individual applications. This method requires every persistent source connecting to a given store have a unique RegID from every other persistent source attaching to the same store. This includes publishing applications that have multiple persistent topics; each topic's source object must have a unique RegID. (The use of session IDs greatly simplifies the management of these RegIDs.)</p>
<p>The following source code examples assign a static RegID to a source by adding the RegID, 1000, to the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umestoresource">ume_store (source)</a> attribute. See also <a href="../example/ume-example-src-2.c">ume-example-src-2.c</a></p>
<p><b>C API</b></p>
<pre class="fragment">lbm_src_topic_attr_t * sattr;

if (lbm_src_topic_attr_create(&amp;sattr) == LBM_FAILURE) {
  fprintf(stderr, "lbm_src_topic_attr_create: %s\n", lbm_errmsg());
  exit(1);
}
if (lbm_src_topic_attr_str_setopt(sattr, "ume_store", "127.0.0.1:14567:1000")
== LBM_FAILURE) {
  fprintf(stderr, "lbm_src_topic_attr_str_setopt: %s\n", lbm_errmsg());
  exit(1);
}
</pre><p><b>JAVA API</b></p>
<pre class="fragment">LBMSourceAttributes sattr = null;
try {
  sattr = new LBMSourceAttributes();
  sattr.setValue("ume_store", "127.0.0.1:14567:1000");
}
catch (LBMException ex) {
  System.err.println("Error creating source attribute: " + ex.toString());
  System.exit(1);
}
</pre><p><b>.NET API</b></p>
<pre class="fragment">LBMSourceAttributes sattr = null;
try {
  sattr = new LBMSourceAttributes();
  sattr.setValue("ume_store", "127.0.0.1:14567:1000");
}
catch (LBMException ex) {
  System.Console.Error.WriteLine ("Error creating source attribute: " + ex.toString());
  System.Environment.Exit(1);
}
</pre><p><br />
 </p>
<h2><a class="anchor" id="saveassignedregids"></a>
Save Assigned RegIDs&nbsp;&nbsp;<small><a href="#saveassignedregids">&lt;-</a></small></h2>
<p>When using RegIDs, your application can request that the store assign it a new and unique RegID when it registers for the first time. That RegID is made available to the application, which can then save it to local storage. Thus, the next time the application starts (or restarts) and wants to use the same registration, it reads the value written to local storage. This method of managing RegIDs is not common. For example, what if the application needs to be restarted on a different server due to hardware failure? If it cannot re-register with its earlier RegID, it will not be able to recover only those messages it had not yet acknowledged. (The use of Session IDs simplifies this greatly by essentially saving the registration IDs for you on the store itself.)</p>
<p>The following minimal source code example saves the RegID assigned to a source to a file. See also <a href="../example/ume-example-src-3.c">ume-example-src-3.c</a></p>
<p><b>C API</b></p>
<pre class="fragment">/* Callback invoked by UM for source events. */
int app_src_callback(lbm_src_t *src, int event, void *eventd, void *clientd)
{
  ...
  switch (event) {
  ...
  case LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX:
    /* Get the registration information. */
    lbm_src_event_ume_registration_ex_t *reginfo = (lbm_src_event_ume_registration_ex_t *)eventd;

    /* Might want to do the following conditionally only if we are requesting a new RegID. */
    FILE *fp = fopen("UME-example-src-RegID", "w");  /* Error checking omitted for clarity. */
    fprintf(fp, "%s:%u", reginfo-&gt;store, reginfo-&gt;registration_id);
    fclose(fp);
  ...
  }  /* switch */
  ...
}  /* app_src_callback */

...

err = lbm_src_create(&amp;src, ctx, topic, app_src_callback, ...);  /* Error checking omitted. */
</pre><p><br />
 </p>
<h2><a class="anchor" id="managingregidswithsessionids"></a>
Managing RegIDs with Session IDs&nbsp;&nbsp;<small><a href="#managingregidswithsessionids">&lt;-</a></small></h2>
<p>The RegIDs used by stores to identify sources and receivers must be unique. Rather than maintaining RegIDs (either statically or dynamically), applications can use a Session ID, which is simply a 64-bit value that uniquely identifies any set of sources with unique topics and receivers with unique topics. A single Session ID allows UM stores to correctly identify all the sources and receivers for a particular application.</p>
<p>In practice, a Session ID is often thought of as an application identifier, although it is more accurately thought of as a context identifier. (For applications that only have a single context with persistent sources and/or receivers, the two are effectively the same.) However, be aware that many application systems run multiple instances of a given program, perhaps for horizontal scaling. Each instance needs its own Session ID.</p>
<p>It is also possible for a single context to host multiple Session IDs, although this is rarely done. The UM configuration options <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umesessionidsource">ume_session_id (source)</a> and <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umesessionidreceiver">ume_session_id (receiver)</a> can be used to arrange individual source and/or receiver objects into registration groupings. However, it is more common to use the option <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umesessionidcontext">ume_session_id (context)</a> to group all sources and receivers created within a context into a single session ID. (If both a context and a source or receiver option is specified, the source or receiver option will override the context option.)</p>
<p><b>How Stores Associate Session IDs and RegIDs</b></p>
<p>Session IDs do not replace the use of RegIDs by UM but rather simplify RegID management. Using Session IDs equates to your application specifying a 0 (zero) RegID for all sources and receivers. However, instead of your application persisting the RegID assigned by the store, the store maintains the RegID for you.</p>
<p>When a store receives a registration request from a source or receiver with a particular Session ID, it checks to see if it already has a source or receiver for that topic/Session ID. If it does, then it responds with that source's or receiver's RegID.</p>
<p>If it does not find a source or receiver for that topic/Session ID pair, the store:</p>
<ol>
<li>
Assigns a new RegID. </li>
<li>
Associates the topic/Session ID with the new RegID. </li>
<li>
Responds to the source or receiver with the new RegID. </li>
</ol>
<p>The source can then advertise with the RegID supplied by the store. Receivers include the source's RegID in their registration request.</p>
<p>All of the above steps happen within UM itself without any intervention by the application. However, the application does have access to the underlying registration ID, if it desires it.</p>
<p><br />
 </p>
<h1><a class="anchor" id="designingpersistentsources"></a>
Designing Persistent Sources&nbsp;&nbsp;<small><a href="#designingpersistentsources">&lt;-</a></small></h1>
<p>The major concerns of sources revolve around RegID management and message retention.</p>
<p><br />
 </p>
<h2><a class="anchor" id="neworreregistration"></a>
New or Re-Registration&nbsp;&nbsp;<small><a href="#neworreregistration">&lt;-</a></small></h2>
<p>Any source needs to know at start-up if it is a new registration or a re-registration. The answer determines how a source registers with the store. The UM library can not answer this question. Therefore, it is essential that the developer consider what identifies the lifetime of a source and how a source determines the appropriate value to use as the RegID when it is ready to register. RegIDs are per source per topic per store, thus a single RegID per store is needed.</p>
<p>The following source code examples look for an existing RegID from a file and uses a new RegID assigned from the store if it finds no existing RegID. See also <a href="../example/ume-example-src-3.c">ume-example-src-3.c</a></p>
<p><b>C API</b></p>
<pre class="fragment">    err = lbm_context_create(&amp;ctx, NULL, NULL, NULL);
    if (err) {printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);}

    srcinfo.message_num = 1;
    srcinfo.existing_regid = 0;

    err = read_src_regid_from_file(SRC_REGID_SAVE_FILENAME, store_info, sizeof(store_info));
    if (!err) { srcinfo.existing_regid = 1; }

        err = lbm_src_topic_attr_create(&amp;attr);
        if (err) {printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);}

        err = lbm_src_topic_attr_str_setopt(attr, "ume_store", store_info);
        if (err) {printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);}
</pre><p>The use of Session IDs allows UM, as opposed to your application, to accomplish the same RegID management. See <a class="el" href="designingpersistenceapplications.html#managingregidswithsessionids">Managing RegIDs with Session IDs</a> Managing RegIDs with Session IDs.</p>
<p><br />
 </p>
<h2><a class="anchor" id="sourcesmustbeabletoresumesending"></a>
Sources Must Be Able to Resume Sending&nbsp;&nbsp;<small><a href="#sourcesmustbeabletoresumesending">&lt;-</a></small></h2>
<p>A source sends messages unless UM prevents it, in which case, the send function returns an error. A source may lose the ability to send messages temporarily if the store(s) in use become unresponsive, e.g. the store(s) die or become disconnected from the source. Once the store(s) are responsive again, sending can continue. Thus source applications need to take into account that sending may fail temporarily under specific failure cases and be able to resume sending when the failure is removed.</p>
<p>The following source code examples demonstrate how a failed send function can sleep for a second and try again:</p>
<p><b>C API</b></p>
<pre class="fragment">while (lbm_src_send(src, message, len, 0) == LBM_FAILURE) {
    If (lbm_errnum() == LBM_EUMENOREG) {
        printf("Send unsuccessful. Waiting...\n");
        sleep(1);
        continue;
    }
    fprintf(stderr, "lbm_src_send: %s\n", lbm_errmsg());
    exit(1);
}
</pre><p><b>Java API</b></p>
<p>for (;;) { try { src.send(message, len, 0); } catch (UMENoRegException ex) { System.out.println("Send unsuccessful. Waiting..."); try { Thread.sleep(1000); } catch (InterruptedException e) { } continue; } catch (LBMException ex) { System.err.println("Error sending message: " + ex.toString()); System.exit(1); } break; }</p>
<p><b>.NET API</b></p>
<pre class="fragment">for (;;) {
    try {
        src.send(message, len, 0);
    }
    catch (UMENoRegException ex) {
        System.Console.Out.WriteLine("Send unsuccessful. Waiting...");
        System.Threading.Thread.Sleep(1000);
        continue;
    }
    catch (LBMException ex) {
        System.Console.Out.WriteLine ("Error sending message: " + ex.toString());
        System.exit(1);
    }
    break;
}
</pre><p><br />
 </p>
<h2><a class="anchor" id="sourcemessageretentionandrelease"></a>
Source Message Retention and Release&nbsp;&nbsp;<small><a href="#sourcemessageretentionandrelease">&lt;-</a></small></h2>
<p>UM allows streaming of messages from a source without regard to message stability at a store, which is one reason for UM's performance advantage over other persistent messaging systems. Sources retain all messages until notified by the active store(s) that they are stable. This provides a method for stores to be brought up to date when restarted or started anew.</p>
<p>When messages are considered stable at the store, the source can release them which frees up source retention memory for new messages. Generally, the source releases older stable messages first. To release the oldest retained message, all the following conditions must be met:</p>
<ul>
<li>
<p class="startli">Message must meet stability requirements of the source, which can range from a single stability notice from the active store to stability notices from a group of stores (See <a class="el" href="designingpersistenceapplications.html#sourcesusingquorumconsensusstoreconfiguration">Sources Using Quorum/Consensus Store Configuration</a>).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Message must have been confirmed as delivered by a configured number of receivers (<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeretentionuniqueconfirmationssource">ume_retention_unique_confirmations (source)</a>).</p>
<p class="endli"></p>
</li>
<li>
The aggregate amount of buffered messages exceeds <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizethresholdsource">retransmit_retention_size_threshold (source)</a> bytes in payload and headers. </li>
</ul>
<p>Some things to note:</p>
<ul>
<li>
<p class="startli">If <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizethresholdsource">retransmit_retention_size_threshold (source)</a> is not met, no messages will be released regardless of stability.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If the source registered with a "no-cache" store (See <a class="el" href="persistenceconcepts.html#persistentstoreconcept">Persistent Store Concept</a>) or <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umemessagestabilitynotificationsource">ume_message_stability_notification (source)</a> is turned off, <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeretentionuniqueconfirmationssource">ume_retention_unique_confirmations (source)</a> is the only way to allow the source to release messages before retention size options come into play.</p>
<p class="endli"></p>
</li>
<li>
With a quorum/consensus store configuration, when a quorum of stores report stability for a message, remaining stores may or may not send additional stability acks for that message. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/design.tag:../Design/" href="../Design/advancedoptimizations.html#smartsources">Smart Sources</a> simplify matters somewhat by pre-allocating retention buffers. They are not dynamically allocated or deallocated during operation. See <a class="el" href="enablingpersistence.html#smartsourcesandpersistence">Smart Sources and Persistence</a> for more information.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="forcedreclaims"></a>
Forced Reclaims&nbsp;&nbsp;<small><a href="#forcedreclaims">&lt;-</a></small></h2>
<p>If the aggregate amount of buffered messages exceeds <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizelimitsource">retransmit_retention_size_limit (source)</a> bytes in payload and headers, then UM forcibly releases the oldest retained message even if it does not meet one or more of the conditions stated in Source Message Retention and Release. This condition should be avoided and Informatica suggests increasing the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizelimitsource">retransmit_retention_size_limit (source)</a>.</p>
<p>A second condition that produces a forced reclaim is when a message remains unstabilized when the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umemessagestabilitylifetimesource">ume_message_stability_lifetime (source)</a> expires.</p>
<p>Whenever UM performs a Forced Reclaim, it notifies the application in the following ways:</p>
<ul>
<li>
<p class="startli">The source event callback's RECLAIMED_EX event (see <a class="el" href="operationalview.html#persistencesourceevents">Persistence Source Events</a>) includes a "FORCED" flag on the event. (UM uses the same RECLAIMED_EX event, without the FORCED flag, for normal reclaims.)</p>
<p class="endli"></p>
</li>
<li>
Through the separate forced reclaim callback, if registered. You set this separate forced reclaim callback with the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeforcereclaimfunctionsource">ume_force_reclaim_function (source)</a> configuration option. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>UM retains the separate callback for backwards compatibility purposes and may be deprecated in future releases. The source event FORCED flag is the recommended method of tracking forced reclaims.</dd></dl>
<p>The following sample code, from <a href="../example/umesrc.c">umesrc.c</a>, implements the extended reclaim source event with the 'Forced' flag set if the reclamation is a forced reclaim.</p>
<p><b>C API</b></p>
<pre class="fragment">case LBM_SRC_EVENT_UME_MESSAGE_RECLAIMED_EX:
{
    lbm_src_event_ume_ack_ex_info_t *ackinfo = (lbm_src_event_ume_ack_ex_info_t *)ed;
    if (opts-&gt;verbose) {
        printf("UME message reclaimed (ex) - sequence number %x (cd %p). Flags 0x%x ",
               ackinfo-&gt;sequence_number, (char*)(ackinfo-&gt;msg_clientd) - 1, ackinfo-&gt;flags);
        if (ackinfo-&gt;flags &amp; LBM_SRC_EVENT_UME_MESSAGE_RECLAIMED_EX_FLAG_FORCED) {
            printf("FORCED");
        }
        printf("\n");
    }
}
break;
</pre><p><b>Java API</b></p>
<pre class="fragment">case LBM.SRC_EVENT_UME_MESSAGE_RECLAIMED_EX:
    UMESourceEventAckInfo reclaiminfo = sourceEvent.ackInfo();
    if (_verbose &gt; 0) {
        if (reclaiminfo.clientObject() != null) {
            System.out.print("UME message reclaimed (ex) - sequence number "
                               + Long.toHexString(reclaiminfo.sequenceNumber())
                               + " (cd "
                               + Long.toHexString(((Long)reclaiminfo.clientObject()).longValue())
                               + "). Flags 0x"
                               + reclaiminfo.flags());
        } else {
            System.out.print("UME message reclaimed (ex) - sequence number "
                               + Long.toHexString(reclaiminfo.sequenceNumber())
                               + " Flags 0x"
                               + reclaiminfo.flags());
        }
        if ((reclaiminfo.flags() &amp; LBM.SRC_EVENT_UME_MESSAGE_RECLAIMED_EX_FLAG_FORCED) != 0) {
            System.out.print(" FORCED");
        }
        System.out.println();
    }
    break;
</pre><p><b>.NET API</b></p>
<pre class="fragment">case LBM.SRC_EVENT_UME_MESSAGE_RECLAIMED_EX:
    UMESourceEventAckInfo reclaiminfo = sourceEvent.ackInfo();
    if (_verbose &gt; 0) {
        System.Console.Out.Write("UME message reclaimed (ex) - sequence number "
                                   + reclaiminfo.sequenceNumber()
                                   + " (cd "
                                   + ((uint)reclaiminfo.clientObject()).ToString("x")
                                   + "). Flags "
                                   + reclaiminfo.flags());
        if ((reclaiminfo.flags() &amp; LBM.SRC_EVENT_UME_MESSAGE_RECLAIMED_EX_FLAG_FORCED) != 0) {
            System.Console.Out.Write(" FORCED");
        }
        System.Console.Out.WriteLine();
    }
    break;
</pre><p><br />
 </p>
<h2><a class="anchor" id="sourcereleasepolicyoptions"></a>
Source Release Policy Options&nbsp;&nbsp;<small><a href="#sourcereleasepolicyoptions">&lt;-</a></small></h2>
<p>Sources use a set of configuration options to release messages that, in effect, specify the source's release policy. The following configuration options directly impact when the source may release retained messages:</p>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umemessagestabilitynotificationsource">ume_message_stability_notification (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeretentionuniqueconfirmationssource">ume_retention_unique_confirmations (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizethresholdsource">retransmit_retention_size_threshold (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizelimitsource">retransmit_retention_size_limit (source)</a> </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="confirmeddelivery"></a>
Confirmed Delivery&nbsp;&nbsp;<small><a href="#confirmeddelivery">&lt;-</a></small></h2>
<p>The configuration option <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeretentionuniqueconfirmationssource">ume_retention_unique_confirmations (source)</a> requires a message to have a minimum number of unique confirmations from different receivers before the message may be released. This retains messages that have not been confirmed as being received and processed and keeps them available to fulfill any retransmission requests. This provides a form of receiver-pacing; the source will not be allowed to exceed <a class="el" href="operationalview.html#persistenceflightsize">Persistence Flight Size</a> beyond receiving applications.</p>
<p>For example, a topic might have 2 receivers which are considered essential to keep up, and which should therefore contribute to flight size calculation. There might be any number of less-essential receivers which can be allowed to lag behind. In this case, <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeretentionuniqueconfirmationssource">ume_retention_unique_confirmations (source)</a> would be set to 2, and the non-essential receivers would set <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeallowconfirmeddeliveryreceiver">ume_allow_confirmed_delivery (receiver)</a> to 0.</p>
<dl class="section note"><dt>Note</dt><dd><a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/design.tag:../Design/" href="../Design/advancedoptimizations.html#smartsources">Smart Sources</a> do not support delivery confirmation.</dd></dl>
<p>The following code samples show how to require a message to have 10 unique receiver confirmations</p>
<p><b>C API</b></p>
<pre class="fragment">lbm_src_topic_attr_t * sattr;

if (lbm_src_topic_attr_create(&amp;sattr) == LBM_FAILURE) {
    fprintf(stderr, "lbm_src_topic_attr_create: %s\n", lbm_errmsg());
    exit(1);
}
if (lbm_src_topic_attr_str_setopt(sattr, "ume_retention_unique_confirmations",
                                  "10") == LBM_FAILURE) {
    fprintf(stderr, "lbm_src_topic_attr_str_setopt: %s\n", lbm_errmsg());
    exit(1);
}
</pre><p><b>JAVA API</b></p>
<pre class="fragment">LBMSourceAttributes sattr = null;
try {
    sattr = new LBMSourceAttributes();
    sattr.setValue("ume_retention_unique_confirmations", "10");
}
catch (LBMException ex) {
    System.err.println("Error creating source attribute: " + ex.toString());
    System.exit(1);
}
</pre><p><b>.NET API</b></p>
<pre class="fragment">LBMSourceAttributes sattr = null;
try {
    sattr = new LBMSourceAttributes();
    sattr.setValue("ume_retention_unique_confirmations", "10");
}
catch (LBMException ex) {
    System.Console.Error.WriteLine ("Error creating source attribute: " + ex.toString());
    System.Environment.Exit(1);
}
</pre><p><br />
 </p>
<h2><a class="anchor" id="sourceeventhandler"></a>
Source Event Handler&nbsp;&nbsp;<small><a href="#sourceeventhandler">&lt;-</a></small></h2>
<p>The Source Event Handler is a function callback initialized at source creation to provide source events to your application related to the operation of the source. The following source code examples illustrate the use of a source event handler for registration events. To accept other source events, additional case statements would be required, one for each additional source event. See also <a class="el" href="operationalview.html#persistenceevents">Persistence Events</a>.</p>
<p><b>C API</b></p>
<pre class="fragment">int handle_src_event(lbm_src_t *src, int event, void *ed, void *cd)
{
    switch (event) {
    case LBM_SRC_EVENT_UME_REGISTRATION_ERROR:
    {
        const char *errstr = (const char *)ed;
        printf("Error registering source with UME store: %s\n", errstr);
    }
    break;

    case LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX:
    {
        lbm_src_event_ume_registration_ex_t *reg =
            (lbm_src_event_ume_registration_ex_t *)ed;

        printf("UME store %u: %s registration success. RegID %u. Flags %x ",
               reg-&gt;store_index, reg-&gt;store, reg-&gt;registration_id, reg-&gt;flags);
        if (reg-&gt;flags &amp; LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD)
            printf("OLD[SQN %x] ", reg-&gt;sequence_number);
        if (reg-&gt;flags &amp; LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_NOACKS)
            printf("NOACKS ");
        printf("\n");
    }
    break;

    case LBM_SRC_EVENT_UME_REGISTRATION_COMPLETE_EX:
    {
        lbm_src_event_ume_registration_complete_ex_t *reg =
            (lbm_src_event_ume__complete_ex_t *)ed;
        printf("UME registration complete. SQN %x. Flags %x ",
               reg-&gt;sequence_number, reg-&gt;flags);
        if (reg-&gt;flags &amp; LBM_SRC_EVENT_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM)
            printf("QUORUM ");
        printf("\n");
    }
    break;

    case LBM_SRC_EVENT_UME_STORE_UNRESPONSIVE:
    {
        const char *infostr = (const char *)ed;
        printf("UME store: %s\n", infostr);
    }
    break;

    default:
        printf("Unknown source event %d\n", event);
        break;
    }
    return 0;
}
</pre><p><b>JAVA API</b></p>
<pre class="fragment">public int onSourceEvent(Object arg, LBMSourceEvent sourceEvent)
{
    switch (sourceEvent.type()) {
    case LBM.SRC_EVENT_UME_REGISTRATION_ERROR:
        System.out.println("Error registering source with UME store: "
            + sourceEvent.dataString());
        break;

    case LBM.SRC_EVENT_UME_REGISTRATION_SUCCESS_EX:
        UMESourceEventRegistrationSuccessInfo reg =
            sourceEvent.registrationSuccessInfo();
        System.out.print("UME store " + reg.storeIndex() + ": " + reg.store()
            + " registration success. RegID " + reg.registrationId() + ". Flags "
            + reg.flags() + " ");
        if (((reg.flags() &amp; LBM.SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD)) != 0) {
            System.out.print("OLD[SQN " + reg.sequenceNumber() + "] ");
        }
        if (((reg.flags() &amp; LBM.SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_NOACKS)) != 0) {
            System.out.print("NOACKS ");
        }
        System.out.println();
        break;

    case LBM.SRC_EVENT_UME_REGISTRATION_COMPLETE_EX:
        UMESourceEventRegistrationCompleteInfo regcomp =
            sourceEvent.registrationCompleteInfo();
        System.out.print("UME registration complete. SQN " + regcomp.sequenceNumber()
            + ". Flags " + regcomp.flags() + " ");
        if ((regcomp.flags() &amp; LBM.SRC_EVENT_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM) != 0) {
            System.out.print("QUORUM ");
        }
        System.out.println();
        break;

    case LBM.SRC_EVENT_UME_STORE_UNRESPONSIVE:
        System.out.println("UME store: " + sourceEvent.dataString());
        break;
    ...
    default:
        System.out.println("Unknown source event " + sourceEvent.type());
        break;
    }
    return 0;
}
</pre><p><b>.NET API</b></p>
<pre class="fragment">public int onSourceEvent(Object arg, LBMSourceEvent sourceEvent)
{
    switch (sourceEvent.type()) {
    case LBM.SRC_EVENT_UME_REGISTRATION_ERROR:
        System.Console.Out.WriteLine("Error registering source with UME store: "
            + sourceEvent.dataString());
        break;

    case LBM.SRC_EVENT_UME_REGISTRATION_SUCCESS_EX:
        UMESourceEventRegistrationSuccessInfo reg = sourceEvent.registrationSuccessInfo();
        System.Console.Out.Write("UME store " + reg.storeIndex() + ": " + reg.store()
            + " registration success. RegID " + reg.registrationId() + ". Flags "
            + reg.flags() + " ");
        if (((reg.flags() &amp; LBM.SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD)) != 0) {
            System.Console.Out.Write("OLD[SQN " + reg.sequenceNumber() + "] ");
        }
        if (((reg.flags() &amp; LBM.SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_NOACKS)) != 0) {
            System.Console.Out.Write("NOACKS ");
        }
        System.Console.Out.WriteLine();
        break;

    case LBM.SRC_EVENT_UME_REGISTRATION_COMPLETE_EX:
        UMESourceEventRegistrationCompleteInfo regcomp =
            sourceEvent.registrationCompleteInfo();
        System.Console.Out.Write("UME registration complete. SQN " +
            regcomp.sequenceNumber() + ". Flags " + regcomp.flags() + " ");
        if ((regcomp.flags() &amp; LBM.SRC_EVENT_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM) != 0) {
            System.Console.Out.Write("QUORUM ");
        }
        System.Console.Out.WriteLine();
        break;

    case LBM.SRC_EVENT_UME_STORE_UNRESPONSIVE:
        System.Console.Out.WriteLine("UME store: " + sourceEvent.dataString());
        break;
    ...
    default:
        System.Console.Out.WriteLine("Unknown source event " + sourceEvent.type());
        break;
    }
    return 0;
}
</pre><p><br />
 </p>
<h2><a class="anchor" id="sourceeventhandlerstabilityconfirmationandrelease"></a>
Source Event Handler - Stability, Confirmation and Release&nbsp;&nbsp;<small><a href="#sourceeventhandlerstabilityconfirmationandrelease">&lt;-</a></small></h2>
<p>As shown in Source Event Handler above, the Source Event Handler can be expanded to handle more source events by adding additional case statements. The following source code examples show case statements to handle message stability events, delivery confirmation events and message release (reclaim) events. See also <a class="el" href="operationalview.html#persistenceevents">Persistence Events</a>.</p>
<p><b>C API</b></p>
<pre class="fragment">case LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX:
/* requires that source ume_message_stability_notification attribute is enabled */
{
    lbm_src_event_ume_ack_ex_info_t *info = (lbm_src_event_ume_ack_ex_info_t *)ed;

    printf("UME store %u: %s message stable. SQN %x (msgno %d). Flags %x ",
        info-&gt;store_index, info-&gt;store, info-&gt;sequence_number,
        (int)info-&gt;msg_clientd - 1, info-&gt;flags);
    if (info-&gt;flags &amp; LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_INTRAGROUP_STABLE)
        printf("IA "); /* Stable within store group */
    if (info-&gt;flags &amp; LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_INTERGROUP_STABLE)
        printf("IR "); /* Stable amongst all stores */
    if (info-&gt;flags &amp; LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_STABLE)
        printf("STABLE ");  /* Just plain stable */
    if (info-&gt;flags &amp; LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_STORE)
        printf("STORE ");   /* Stability reported by UME Store */
    printf("\n");
}
break;

case LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX:
/* requires that source ume_confirmed_delivery_notification attribute is enabled */
{
    lbm_src_event_ume_ack_ex_info_t *info = (lbm_src_event_ume_ack_ex_info_t *)ed;

    printf("UME delivery confirmation. SQN %x, Receiver RegID %u (msgno %d). Flags %x ",
        info-&gt;sequence_number, info-&gt;rcv_registration_id,
        (int)info-&gt;msg_clientd - 1, info-&gt;flags);
    if (info-&gt;flags &amp; LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_UNIQUEACKS)
        printf("UNIQUEACKS "); /* Satisfied number of unique ACKs requirement */
    if (info-&gt;flags &amp; LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_UREGID)
        printf("UREGID "); /* Confirmation contains receiver application registration ID */
    if (info-&gt;flags &amp; LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_OOD)
        printf("OOD "); /* Confirmation received from arrival order receiver */
    if (info-&gt;flags &amp; LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_EXACK)
        printf("EXACK "); /* Confirmation explicitly sent by receiver */
    printf("\n");
}
break;

case LBM_SRC_EVENT_UME_MESSAGE_RECLAIMED:
/* requires that source ume_confirmed_delivery_notification or ume_message_stability_notification
attributes are enabled */
{
    lbm_src_event_ume_ack_info_t *ackinfo = (lbm_src_event_ume_ack_info_t *)ed;

    printf("UME message released - sequence number %x (msgno %d)\n",
        ackinfo-&gt;sequence_number, (int)ackinfo-&gt;msg_clientd - 1);
}
break;
</pre><p><b>JAVA API</b></p>
<pre class="fragment">case LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX:
    // requires that source ume_message_stability_notification attribute is enabled
    UMESourceEventAckInfo staInfo = sourceEvent.ackInfo();
    System.out.print("UME store " + staInfo.storeIndex() + ": "
                    + staInfo.store() + " message stable. SQN " + staInfo.sequenceNumber()
                    + " (msgno " + staInfo.clientObject() + "). Flags "
                    + staInfo.flags() + " ");
    if ((staInfo.flags() &amp; LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_INTRAGROUP_STABLE) != 0) {
        System.out.print("IA "); // Stable within store group
    }
    if ((staInfo.flags() &amp; LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_INTERGROUP_STABLE) != 0) {
        System.out.print("IR ");  // Stable amongst all stores
    }
    if ((staInfo.flags() &amp; LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_STABLE) != 0) {
        System.out.print("STABLE ");  // Just plain stable
    }
    if ((staInfo.flags() &amp; LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_STORE) != 0) {
        System.out.print("STORE ");   // Stability reported by UME Store
    }
    System.out.println();
    break;

case LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX:
    // requires that source ume_confirmed_delivery_notification attribute is enabled
    UMESourceEventAckInfo cdelvinfo = sourceEvent.ackInfo();
    System.out.print("UME delivery confirmation. SQN " + cdelvinfo.sequenceNumber()
                    + ", RcvRegID " + cdelvinfo.receiverRegistrationId() + " (msgno "
                    + cdelvinfo.clientObject() + "). Flags " + cdelvinfo.flags() + " ");
    if ((cdelvinfo.flags() &amp; LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_UNIQUEACKS) != 0) {
        System.out.print("UNIQUEACKS "); // Satisfied number of unique ACKs requirement
    }
    if ((cdelvinfo.flags() &amp; LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_UREGID) != 0) {
        System.out.print("UREGID ");    // Confirmation contains receiver application reg ID
    }
    if ((cdelvinfo.flags() &amp; LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_OOD) != 0) {
        System.out.print("OOD ");      // Confirmation received from arrival order receiver
    }
    if ((cdelvinfo.flags() &amp; LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_EXACK) != 0) {
        System.out.print("EXACK ");    // Confirmation explicitly sent by receiver
    }
    System.out.println();
    break;

case LBM.SRC_EVENT_UME_MESSAGE_RECLAIMED:
    // requires that source ume_confirmed_delivery_notification or
    // ume_message_stability_notification attributes are enabled
    System.out.println("UME message released - sequence number "
                + Long.toHexString(sourceEvent.sequenceNumber())
                + " (msgno "
                + Long.toHexString(((Integer)sourceEvent.clientObject()).longValue())
                + ")");
    break;
</pre><p><b>.NET API</b></p>
<pre class="fragment">case LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX:
    // requires that source ume_message_stability_notification attribute is enabled
    UMESourceEventAckInfo staInfo = sourceEvent.ackInfo();
    System.Console.Out.Write("UME store " + staInfo.storeIndex() + ": "
                        + staInfo.store() + " message stable. SQN " + staInfo.sequenceNumber()
                        + " (msgno " + ((int)staInfo.clientObject()).ToString("x") + ").
                        Flags " + staInfo.flags() + " ");
    if ((staInfo.flags() &amp; LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_INTRAGROUP_STABLE) != 0) {
        System.Console.Out.Write("IA ");  // Stable within store group
    }
    if ((staInfo.flags() &amp; LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_INTERGROUP_STABLE) != 0) {
        System.Console.Out.Write("IR ");  // Stable amongst all stores
    }
    if ((staInfo.flags() &amp; LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_STABLE) != 0) {
        System.Console.Out.Write("STABLE ");  // Just plain stable
    }
    if ((staInfo.flags() &amp; LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_STORE) != 0) {
        System.Console.Out.Write("STORE ");  // Stability reported by UME Store
    }
    System.Console.Out.WriteLine();
    break;

case LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX:
    // requires that source ume_confirmed_delivery_notification attribute is enabled

    UMESourceEventAckInfo cdelvinfo = sourceEvent.ackInfo();

    System.Console.Out.Write("UME delivery confirmation. SQN " +
    cdelvinfo.sequenceNumber()
                        + ", RcvRegID " + cdelvinfo.receiverRegistrationId() + " (msgno "
                        + ((int)cdelvinfo.clientObject()).ToString("x") + "). Flags " +
                        cdelvinfo.flags() + " ");
    if ((cdelvinfo.flags() &amp; LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_UNIQUEACKS) != 0) {
        System.Console.Out.Write("UNIQUEACKS ");  // Satisfied number of unique ACKs requirement
    }
    if ((cdelvinfo.flags() &amp; LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_UREGID) != 0) {
        System.Console.Out.Write("UREGID ");  // Confirmation contains receiver application reg ID
    }
    if ((cdelvinfo.flags() &amp; LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_OOD) != 0) {
        System.Console.Out.Write("OOD ");  // Confirmation received from arrival order receiver
    }
    if ((cdelvinfo.flags() &amp; LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_EXACK) != 0) {
        System.Console.Out.Write("EXACK ");  // Confirmation explicitly sent by receiver
    }
    System.Console.Out.WriteLine();
    break;

case LBM.SRC_EVENT_UME_MESSAGE_RECLAIMED:
    // requires that source ume_confirmed_delivery_notification or
    // ume_message_stability_notification attributes are enabled

    System.Console.Out.WriteLine("UME message released - sequence number "
                               + sourceEvent.sequenceNumber().ToString("x")
                               + " (msgno "
                               + ((int)sourceEvent.clientObject()).ToString("x")
                               + ")");
    break;
</pre><p><br />
 </p>
<h2><a class="anchor" id="mappingyourmessagenumberstosequencenumbers"></a>
Mapping Your Message Numbers to Sequence Numbers&nbsp;&nbsp;<small><a href="#mappingyourmessagenumberstosequencenumbers">&lt;-</a></small></h2>
<p>The C API function <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/api.tag:../API/" href="../API/lbm_8h.html#a4d883eaaa22baf81abf21d495f471c8b">lbm_src_sendv_ex()</a> allows you to create a pointer to an object or structure. This pointer will be returned to your application along with all source events. You can then update the object or structure with source event information. For example, if your messages exceed 8K - which requires fragmentation your application's message into more than one UM message - receiving sequence number events with this pointer allows you to determine all the UM sequence numbers for the message and, therefore, how many release (reclaim) events to expect. The following two source code examples show how to:</p>
<ul>
<li>
Enable message sequence number information. </li>
<li>
Handle sequence number source events to determine the application message number in the Source Event Handler. </li>
</ul>
<p><b>C API - Enable Message Information</b></p>
<pre class="fragment">lbm_src_send_ex_info_t exinfo;

/* Enable message sequence number info to be returned */
exinfo.flags = LBM_SRC_SEND_EX_FLAG_UME_CLIENTD | LBM_SRC_SEND_EX_FLAG_SEQUENCE_NUMBER_INFO;
exinfo.ume_msg_clientd = (void *)(msgno + 1);
/* msgno set to application message number (can't evaluate to NULL) */
while (lbm_src_send_ex(src, message, msglen, 0, &amp;exinfo) == LBM_FAILURE) {
    if (lbm_errnum() == LBM_EUMENOREG) {
        printf("Send unsuccessful. Waiting...\n");
                SLEEP_MSEC(1000);    /* Sleep for 1 second */
    }
    else {
         fprintf(stderr, "lbm_src_send: %s\n", lbm_errmsg());
        break;
    }
}
</pre><p><b>C API - Sequence Number Event Handler</b></p>
<pre class="fragment">int handle_src_event(lbm_src_t *src, int event, void *ed, void *cd)
{
    switch (event) {
    case LBM_SRC_EVENT_SEQUENCE_NUMBER_INFO:
        {
            lbm_src_event_sequence_number_info_t *info =
                (lbm_src_event_sequence_number_info_t *)ed;

            if (info-&gt;first_sequence_number != info-&gt;last_sequence_number) {
                printf("SQN [%x,%x] (msgno %d)\n", info-&gt;first_sequence_number,
                        info-&gt;last_sequence_number, (int)info-&gt;msg_clientd - 1);
            }
            else {
                printf("SQN %x (msgno %d)\n", info-&gt;last_sequence_number,
                        (int)info-&gt;msg_clientd - 1);
            }
        }
        break;
    ...
    }
    return 0;
}
</pre><p><b>JAVA API - Enable Message Information</b></p>
<pre class="fragment">LBMSourceSendExInfo exinfo = new LBMSourceSendExInfo();
exinfo.setClientObject(new Integer(msgno));  // msgno set to application message number
exinfo.setFlags(LBM.SRC_SEND_EX_FLAG_SEQUENCE_NUMBER_INFO);
// Enable message sequence number info to be returned
for (;;)
{
    try {
        src.send(message, msglen, 0, exinfo);
    }
    catch(UMENoRegException ex) {
        try {
            Thread.sleep(1000);
        }
        catch (InterruptedException e) { }
        continue;
    }
    catch (LBMException ex) {
        System.err.println("Error sending message: " + ex.toString());
    }
    break;
}
</pre><p><b>JAVA API - Sequence Number Event Handler</b></p>
<pre class="fragment">public int onSourceEvent(Object arg, LBMSourceEvent sourceEvent)
{
    switch (sourceEvent.type())
    {
    case LBM.SRC_EVENT_SEQUENCE_NUMBER_INFO:
        LBMSourceEventSequenceNumberInfo info = sourceEvent.sequenceNumberInfo();
        if (info.firstSequenceNumber() != info.lastSequenceNumber()) {
            System.out.println("SQN [" + info.firstSequenceNumber()
                            + "," + info.lastSequenceNumber() + "] (msgno "
                            + info.clientObject() + ")");
        }
        else {
            System.out.println("SQN " + info.lastSequenceNumber()
                            + " (msgno " + info.clientObject() + ")");
        }
        break;
    ...
    }
    return 0;
}
</pre><p><b>.NET API - Enable Message Information</b></p>
<pre class="fragment">LBMSourceSendExInfo exinfo = new LBMSourceSendExInfo();
exinfo.setClientObject(msgno);  // msgno set to application message number
exinfo.setFlags(LBM.SRC_SEND_EX_FLAG_SEQUENCE_NUMBER_INFO);
// Enable message sequence number info to be returned
for (;;)
{
    try {
        src.send(message, msglen, 0, exinfo);
    }
    catch(UMENoRegException ex) {
        System.Threading.Thread.Sleep(100);
        continue;
    }
    catch (LBMException ex) {
        System.Console.Out.WriteLine("Error sending message: " + ex.Message());
    }
    break;
}
</pre><p><b>.NET API - Sequence Number Event Handler</b></p>
<pre class="fragment">public void onSourceEvent(Object arg, LBMSourceEvent sourceEvent)
{
    switch (sourceEvent.type())
    {
    case LBM.SRC_EVENT_SEQUENCE_NUMBER_INFO:
        LBMSourceEventSequenceNumberInfo info = sourceEvent.sequenceNumberInfo();
        if (info.firstSequenceNumber() != info.lastSequenceNumber()) {
            System.Console.Out.WriteLine("SQN [" + info.firstSequenceNumber()
                              + "," + info.lastSequenceNumber() + "] (cd "
                              + ((int)info.clientObject()).ToString("x") + ")");
        }
        else {
            System.Console.Out.WriteLine("SQN " + info.lastSequenceNumber()
                + " (msgno " + ((int)info.clientObject()).ToString("x") + ")");
        }
        break;
    ...

    }
    return 0;
}
</pre><p><br />
 </p>
<h2><a class="anchor" id="receiverlivenessdetection"></a>
Receiver Liveness Detection&nbsp;&nbsp;<small><a href="#receiverlivenessdetection">&lt;-</a></small></h2>
<p>As an extension to Confirmed Delivery, you can set receivers to send a keepalive to a source during a measured absence of delivery confirmations (due to traffic lapse). In the event that neither message reaches the source within a designated interval, or if the delivery confirmation TCP connection breaks down, the receiver is assumed to have "died". UM then notifies the publishing application via context event callback. This lets the publisher assign a new subscriber.</p>
<p>To use this feature, set these five configuration options: </p><ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umesourcelivenesstimeoutcontext">ume_source_liveness_timeout (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umereceiverlivenessintervalcontext">ume_receiver_liveness_interval (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeconfirmeddeliverynotificationsource">ume_confirmed_delivery_notification (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeuserreceiverregistrationidcontext">ume_user_receiver_registration_id (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umesessionidcontext">ume_session_id (context)</a>, <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umesessionidsource">ume_session_id (source)</a>, <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umesessionidreceiver">ume_session_id (receiver)</a> </li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/design.tag:../Design/" href="../Design/advancedoptimizations.html#smartsources">Smart Sources</a> do not support liveness detection.</dd></dl>
<p>This specialized feature is not recommended for general use. If you are considering it, please note the following caveats: </p><ul>
<li>
Do not use in conjunction with a UM Router. </li>
<li>
There is a variety of potential network occurrences that can break or reset the TCP connection and falsely indicate the death of a receiver. </li>
<li>
In cases where a receiver object is deleted while its context is not, the publisher may still falsely assume the receiver to be alive. </li>
</ul>
<p>Other false receiver-alive assumptions could be caused by the following: </p><ul>
<li>
TCP connections can enter a half-open or otherwise corrupted state. </li>
<li>
Failed TCP connections sometimes do not fully close, or experience objectionable delays before fully closing. </li>
<li>
A switch or router failure along the path does not affect the TCP connection state. </li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="designingpersistentreceivers"></a>
Designing Persistent Receivers&nbsp;&nbsp;<small><a href="#designingpersistentreceivers">&lt;-</a></small></h1>
<p>Receivers are predominantly interested in RegID management and recovery management.</p>
<p><br />
 </p>
<h2><a class="anchor" id="receiverregidmanagement"></a>
Receiver RegID Management&nbsp;&nbsp;<small><a href="#receiverregidmanagement">&lt;-</a></small></h2>
<p>RegIDs are slightly more involved for receivers than for sources. Since RegIDs are per source per topic per store and a topic may have several sources, a receiver may have to manage several RegIDs per store in use. Fortunately, receivers in UM can leverage the RegID of the source with the use of a callback as discussed in Adding Fault Recovery with Registration IDs and shown in ume-example-rcv-2.c. Your application can determine the correct RegID to use and return it to UM. You can also use Session IDs to enable UM to manage receiver RegIDs. See <a class="el" href="designingpersistenceapplications.html#managingregidswithsessionids">Managing RegIDs with Session IDs</a>.</p>
<p>Much like sources, receivers typically have a lifetime based on an amount of work, perhaps an infinite amount. And just like sources, it may be helpful to consider that a RegID is "assigned" at the start of that work and is out of use at the end. In between, the RegID is in use by the instance of the receiver application. However, the nature of RegIDs being per source means that the expected lifetime of a source should play a role in how RegIDs on the receiver are managed. Thus, it may be helpful for the application developer to consider the source application lifetime when deciding how best to handle RegIDs on the receiver.</p>
<p><b>Receiver Message and Event Handler</b></p>
<p>The Receiver Message and Event Handler is an application callback, defined at receiver initialization, to deliver received messages to your application. The following source code examples illustrate the use of a receiver message and event handler for registration messages. To accept other receiver events, additional case statements would be required, one for each additional event. See also <a class="el" href="operationalview.html#persistenceevents">Persistence Events</a></p>
<p><b>C API</b></p>
<pre class="fragment">int rcv_handle_msg(lbm_rcv_t *rcv, lbm_msg_t *msg, void *clientd)
{
    switch (msg-&gt;type) {
    case LBM_MSG_UME_REGISTRATION_ERROR:
        printf("[%s][%s] UME registration error: %s\n", msg-&gt;topic_name,
                msg-&gt;source, msg-&gt;data);
        exit(0);
        break;

    case LBM_MSG_UME_REGISTRATION_SUCCESS:
        {
            lbm_msg_ume_registration_t *reg =
                (lbm_msg_ume_registration_t *)(msg-&gt;data);

            printf("[%s][%s] UME registration successful. "
                "SrcRegID %u RcvRegID %u\n",
                msg-&gt;topic_name, msg-&gt;source,
                reg-&gt;src_registration_id, reg-&gt;rcv_registration_id);
        }
        break;

    case LBM_MSG_UME_REGISTRATION_SUCCESS_EX:
        {
            lbm_msg_ume_registration_ex_t *reg =
                (lbm_msg_ume_registration_ex_t *)(msg-&gt;data);

            printf("[%s][%s] store %u: %s UME registration successful. "
                "SrcRegID %u RcvRegID %u. Flags %x ",
                msg-&gt;topic_name, msg-&gt;source, reg-&gt;store_index, reg-&gt;store,
                reg-&gt;src_registration_id, reg-&gt;rcv_registration_id, reg-&gt;flags);
            if (reg-&gt;flags &amp; LBM_MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD)
                printf("OLD[SQN %x] ", reg-&gt;sequence_number);
            if (reg-&gt;flags &amp; LBM_MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_NOCACHE)
                printf("NOCACHE ");
            printf("\n");
        }
        break;

    case LBM_MSG_UME_REGISTRATION_COMPLETE_EX:
        {
            lbm_msg_ume_registration_complete_ex_t *reg =
                (lbm_msg_ume_registration_complete_ex_t *)(msg-&gt;data);

            printf("[%s][%s] UME registration complete. SQN %x. Flags %x ",
                msg-&gt;topic_name, msg-&gt;source, reg-&gt;sequence_number, reg-&gt;flags);
            if (reg-&gt;flags &amp; LBM_MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM)
                printf("QUORUM ");
            if (reg-&gt;flags &amp; LBM_MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_RXREQMAX)
                printf("RXREQMAX ");
            printf("\n");
        }
        break;

    case LBM_MSG_UME_REGISTRATION_CHANGE:
        printf("[%s][%s] UME registration change: %s\n", msg-&gt;topic_name,
            msg-&gt;source, msg-&gt;data);
        break;
    ...

    default:
        printf("Unknown lbm_msg_t type %x [%s][%s]\n", msg-&gt;type,
            msg-&gt;topic_name, msg-&gt;source);
        break;
    }
    return 0;
}
</pre><p><b>JAVA API</b></p>
<pre class="fragment">public int onReceive(Object cbArg, LBMMessage msg)
{
    case LBM.MSG_UME_REGISTRATION_ERROR:
        System.out.println("[" + msg.topicName() + "][" + msg.source()
                    + "] UME registration error: " + msg.dataString());
        break;

    case LBM.MSG_UME_REGISTRATION_SUCCESS_EX:
        UMERegistrationSuccessInfo reg = msg.registrationSuccessInfo();
        System.out.print("[" + msg.topicName() + "][" + msg.source()
                    + "] store " + reg.storeIndex() + ": "
                    + reg.store() + " UME registration successful. SrcRegID "
                    + reg.sourceRegistrationId() + " RcvRegID "
                    + reg.receiverRegistrationId()
                    + ". Flags " + reg.flags() + " ");
        if ((reg.flags() &amp; LBM.MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD) != 0) {
            System.out.print("OLD[SQN " + reg.sequenceNumber() + "] ");
        }
        if ((reg.flags() &amp; LBM.MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_NOCACHE) != 0) {
            System.out.print("NOCACHE ");
        }
        System.out.println();
        break;

    case LBM.MSG_UME_REGISTRATION_COMPLETE_EX:
        UMERegistrationCompleteInfo regcomplete = msg.registrationCompleteInfo();
        System.out.print("[" + msg.topicName() + "][" + msg.source()
            + "] UME registration complete. SQN " + regcomplete.sequenceNumber()
            + ". Flags " + regcomplete.flags() + " ");
        if ((regcomplete.flags() &amp; LBM.MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM) != 0) {
            System.out.print("QUORUM ");
        }
        if ((regcomplete.flags() &amp; LBM.MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_RXREQMAX) != 0) {
            System.out.print("RXREQMAX ");
        }
        System.out.println();
        break;

    case LBM.MSG_UME_REGISTRATION_CHANGE:
        System.out.println("[" + msg.topicName() + "][" + msg.source()
                    + "] UME registration change: " + msg.dataString());
        break;
    ...

    default:
        System.err.println("Unknown lbm_msg_t type " + msg.type() + " ["
                    + msg.topicName() + "][" + msg.source() + "]");
        break;
    }
    return 0;
}
</pre><p><b>.NET API</b></p>
<pre class="fragment">public int onReceive(Object cbArg, LBMMessage msg)
{
    case LBM.MSG_UME_REGISTRATION_ERROR:
        System. Console.Out.WriteLine("[" + msg.topicName() + "]["
            + msg.source() + "] UME registration error: " + msg.dataString());
        break;

    case LBM.MSG_UME_REGISTRATION_SUCCESS_EX:
        UMERegistrationSuccessInfo reg = msg.registrationSuccessInfo();
        System.Console.Out.Write("[" + msg.topicName() + "][" + msg.source()
                    + "] store " + reg.storeIndex() + ": "
                    + reg.store() + " UME registration successful. SrcRegID "
                    + reg.sourceRegistrationId() + " RcvRegID "
                    + reg.receiverRegistrationId()
                    + ". Flags " + reg.flags() + " ");
        if ((reg.flags() &amp; LBM.MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD) != 0) {
            System.Console.Out.Write ("OLD[SQN " + reg.sequenceNumber() + "] ");
        }
        if ((reg.flags() &amp; LBM.MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_NOCACHE) != 0) {
            System.Console.Out.Write ("NOCACHE ");
        }
        System.Console.Out.WriteLine();
        break;

    case LBM.MSG_UME_REGISTRATION_COMPLETE_EX:
        UMERegistrationCompleteInfo regcomplete = msg.registrationCompleteInfo();
        System.Console.Out.Write("[" + msg.topicName() + "][" + msg.source()
                    + "] UME registration complete. SQN "
                    + regcomplete.sequenceNumber()
                    + ". Flags " + regcomplete.flags() + " ");
        if ((regcomplete.flags() &amp; LBM.MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM) != 0) {
            System.Console.Out.Write("QUORUM ");
        }
        if ((regcomplete.flags() &amp; LBM.MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_RXREQMAX) != 0) {
            System.Console.Out.Write("RXREQMAX ");
        }
        System.Console.Out.WriteLine();
        break;

    case LBM.MSG_UME_REGISTRATION_CHANGE:
        System.Console.Out.WriteLine("[" + msg.topicName() + "][" + msg.source()
                    + "] UME registration change: " + msg.dataString());
        break;
    ...

    default:
        System.Console.Out.WriteLine("Unknown lbm_msg_t type " + msg.type()
                    + " [" + msg.topicName() + "][" + msg.source() + "]");
        break;
    }
    return 0;
}
</pre><p><br />
 </p>
<h2><a class="anchor" id="recoverymanagement"></a>
Recovery Management&nbsp;&nbsp;<small><a href="#recoverymanagement">&lt;-</a></small></h2>
<p>Recovery management for failed and restarted receivers is fairly simple. UM requests any missed messages from the store(s) and delivers them to the restarted receiver. However, your application can override that default behavior either by configuring a <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestmaximumreceiver">retransmit_request_maximum (receiver)</a> value, or by configuring a <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umerecoverysequencenumberinfofunctionreceiver">ume_recovery_sequence_number_info_function (receiver)</a> application callback, or both.</p>
<p>For example, let's say a source sends 7 messages with sequence numbers 0-6 which are stabilized at the store. A C-based receiver, configured with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestmaximumreceiver">retransmit_request_maximum (receiver)</a> set to 2, and an application callback <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umerecoverysequencenumberinfofunctionreceiver">ume_recovery_sequence_number_info_function (receiver)</a>, consumes (and acknowledges) message 0, goes down, then restarts right after message 6.</p>
<p>During receiver registration, the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/api.tag:../API/" href="../API/lbm_8h.html#ac318ae4d0d80e5595ce572558102c7b5">lbm_ume_rcv_recovery_info_ex_func_t</a> application callback is called with the following values in the passed-in structure <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/api.tag:../API/" href="../API/lbm_8h.html#a864aeb7e5113d0d496950cf75ae3cda9">lbm_ume_rcv_recovery_info_ex_func_info_t</a>&#160;*info:</p>
<pre class="fragment">info-&gt;high_sequence_number == 6
info-&gt;low_rxreq_max_sequence_number == 4
info-&gt;low_sequence_number == 1
</pre><p>Where: </p><ul>
<li>
<p class="startli"><a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/api.tag:../API/" href="../API/structlbm__ume__rcv__recovery__info__ex__func__info__t__stct.html#a6365dff87b32b8f4e6e7e985d01acb75">lbm_ume_rcv_recovery_info_ex_func_info_t::high_sequence_number</a> - the most recent message sent by the source,</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/api.tag:../API/" href="../API/structlbm__ume__rcv__recovery__info__ex__func__info__t__stct.html#ab8e05918a9c715b8edbd1e834815eb10">lbm_ume_rcv_recovery_info_ex_func_info_t::low_rxreq_max_sequence_number</a> - high_sequence_number (above) minus the number configured for <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestmaximumreceiver">retransmit_request_maximum (receiver)</a> (2 in this example), and</p>
<p class="endli"></p>
</li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/api.tag:../API/" href="../API/structlbm__ume__rcv__recovery__info__ex__func__info__t__stct.html#a730df0455e0c47ec41434c5f0664e0be">lbm_ume_rcv_recovery_info_ex_func_info_t::low_sequence_number</a> - the first sequence number missed by the receiver after it went down. </li>
</ul>
<p>Normally, UM would start delivering messages at 1, but <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestmaximumreceiver">retransmit_request_maximum (receiver)</a> is set to 2, which overrides UM's normal behavior. So in this example, the first message delivered will be number 4.</p>
<p>Finally, the application can, at run-time, further override the starting sequence number. The callback function can modify the contents of the passed-in structure <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/api.tag:../API/" href="../API/lbm_8h.html#a864aeb7e5113d0d496950cf75ae3cda9">lbm_ume_rcv_recovery_info_ex_func_info_t</a>&#160;*info; specifically it can update the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/api.tag:../API/" href="../API/structlbm__ume__rcv__recovery__info__ex__func__info__t__stct.html#a730df0455e0c47ec41434c5f0664e0be">lbm_ume_rcv_recovery_info_ex_func_info_t::low_sequence_number</a> field. When the callback returns, UM examines that field to see if it was modified by the callback. If so, UM overrides the effect of <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestmaximumreceiver">retransmit_request_maximum (receiver)</a> and starts at the requested sequence number.</p>
<p>Notice that this design does not allow the callback to override the effect of <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestmaximumreceiver">retransmit_request_maximum (receiver)</a> by setting the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/api.tag:../API/" href="../API/structlbm__ume__rcv__recovery__info__ex__func__info__t__stct.html#a730df0455e0c47ec41434c5f0664e0be">lbm_ume_rcv_recovery_info_ex_func_info_t::low_sequence_number</a> field to its original value, 1 in this example. Upon return, UM will see the value unchanged, and will allow <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestmaximumreceiver">retransmit_request_maximum (receiver)</a> to override the starting sequence number. This is only an issue if <em>both</em> <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestmaximumreceiver">retransmit_request_maximum (receiver)</a> and <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umerecoverysequencenumberinfofunctionreceiver">ume_recovery_sequence_number_info_function (receiver)</a> are used. If the application wants to use the sequence number remembered by the store, it should not configure <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestmaximumreceiver">retransmit_request_maximum (receiver)</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="duplicatmessagedelivery"></a>
Duplicate Message Delivery&nbsp;&nbsp;<small><a href="#duplicatmessagedelivery">&lt;-</a></small></h2>
<p>In a distributed system, it is not possible to <em>guarantee</em> "once-and-only-once" delivery of messages in the face of unpredictable system or component failure. Regardless of the algorithms and handshaking, there is always the possibility of messages sent that are never received, as well as messages received and then received again if the receiving application fails and restarts.</p>
<p>UM's persistence design is based on the principle of being close to once-and-only-once, but when that is not possible, UM prefers to fail on the side of duplicate message delivery. Due to other design goals (low latency and high throughput), the possibility of receiving duplicate messages is significant after an application failure and restart.</p>
<p>It is therefore important for persistent applications to be designed to tolerate duplicate message reception, either by making message processing idempotent, or by including logic in the receiving application to detect duplicates and only process the messages which have not been previously processed.</p>
<p>To assist the application in implementing "de-duplication", all messages retransmitted to a receiver are marked as retransmissions via a flag in the message structure. Thus it is easy for an application to determine if a message is a new "live" message from the source, or a retransmission, which may or may not have been processed before the failure. The presence or absence of the retransmit flag gives the application a hint of how best to handle the message with regard to it being processed previously or not.</p>
<p>Informatica recommends that you always check the data or other message properties of messages with the retransmit flag set to be sure the message has not been already processed. Relying on UM sequence numbers is not a 100% reliable method for detecting duplicate messages.</p>
<p><br />
 </p>
<h2><a class="anchor" id="settingcallbackfunctiontosetrecoverysequencenumber"></a>
Setting Callback Function to Set Recovery Sequence Number&nbsp;&nbsp;<small><a href="#settingcallbackfunctiontosetrecoverysequencenumber">&lt;-</a></small></h2>
<p>Whereas the UM persistence design attempts to choose the correct starting sequence number for a recovering receiver, there are cases where the application wishes to override UM's choice.</p>
<p>The sample code below demonstrates how to use the recovery sequence number info function to determine the stored message with which to restart a receiver. This example retrieves the low sequence number from the recovery sequence number structure and adds an offset to determine the beginning sequence number. The offset is a value completely under the control of your application. For example, if a receiver was down for a "long" period and you only want the receiver to receive the last 10 messages, use an offset to start the receiver with the 10th most recent message. If you wish not to receive any messages, set the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/api.tag:../API/" href="../API/structlbm__ume__rcv__recovery__info__ex__func__info__t__stct.html#a730df0455e0c47ec41434c5f0664e0be">lbm_ume_rcv_recovery_info_ex_func_info_t::low_sequence_number</a> to the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/api.tag:../API/" href="../API/structlbm__ume__rcv__recovery__info__ex__func__info__t__stct.html#a6365dff87b32b8f4e6e7e985d01acb75">lbm_ume_rcv_recovery_info_ex_func_info_t::high_sequence_number</a> plus one.</p>
<p><b>C API</b></p>
<pre class="fragment">lbm_ume_rcv_recovery_info_ex_func_t cb;

cb.func = ume_rcv_seqnum_ex;  /* declared below */
cb.clientd = NULL;
if (lbm_rcv_topic_attr_setopt(&amp;rcv_attr,
                              "ume_recovery_sequence_number_info_function",
                              &amp;cb, sizeof(cb)) == LBM_FAILURE) {
    fprintf(stderr,
        "lbm_rcv_topic_attr_setopt:ume_recovery_sequence_number_info_function: %s\n",
        lbm_errmsg());
    exit(1);
}
printf("Will use seqnum info with low offset %u.\n", seqnum_offset);

...

int ume_rcv_seqnum_ex(lbm_ume_rcv_recovery_info_ex_func_info_t *info, void *clientd)
{
    lbm_uint_t new_lo = info-&gt;low_sequence_number + seqnum_offset;

    printf("[%s] SQNs Low %x (will set to %x), Low rxreqmax %x, High %x (CD %p)\n",
        info-&gt;source, info-&gt;low_sequence_number,
        new_lo, info-&gt;low_rxreq_max_sequence_number,
        info-&gt;high_sequence_number, info-&gt;source_clientd);
    info-&gt;low_sequence_number = new_lo;
    return 0;
}
</pre><p><b>JAVA API</b></p>
<pre class="fragment">UMERcvRecInfo umerecinfocb = new UMERcvRecInfo(seqnum_offset);
rcv_attr.setRecoverySequenceNumberCallback(umerecinfocb, null);
System.out.println("Will use seqnum info with low offset " + seqnum_offset);

class UMERcvRecInfo implements UMERecoverySequenceNumberCallback {
    private long _seqnum_offset = 0;

    public UMERcvRecInfo(long seqnum_offset) {
        _seqnum_offset = seqnum_offset;
    }

    public int setRecoverySequenceNumberInfo(Object cbArg,
    UMERecoverySequenceNumberCallbackInfo cbInfo)
    {
        long new_low = cbInfo.lowSequenceNumber() + _seqnum_offset;
        System.out.println("SQNs Low " + cbInfo.lowSequenceNumber() + " (will set to "
            + new_low + "), Low rxreqmax " + cbInfo.lowRxReqMaxSequenceNumber()
            + ", High " + cbInfo.highSequenceNumber());
        try {
            cbInfo.setLowSequenceNumber(new_low);
        }
        catch (LBMEInvalException e) {
            System.err.println(e.getMessage());
        }
        return 0;
     }
 }
</pre><p><b>.NET API</b></p>
<pre class="fragment">UMERcvRecInfo umerecinfocb = new UMERcvRecInfo(seqnum_offset);
rcv_attr.setRecoverySequenceNumberCallback(umerecinfocb, null);
System.Console.Out.WriteLine("Will use seqnum info with low offset " + seqnum_offset);

class UMERcvRecInfo implements UMERecoverySequenceNumberCallback {
    private long _seqnum_offset = 0;

    public UMERcvRecInfo(long seqnum_offset) {
        _seqnum_offset = seqnum_offset;
    }

    public int setRecoverySequenceNumberInfo(Object cbArg,
        UMERecoverySequenceNumberCallbackInfo cbInfo)
    {
        long new_low = cbInfo.lowSequenceNumber() + _seqnum_offset;
        System.Console.Out.WriteLine ("SQNs Low " + cbInfo.lowSequenceNumber() + " (will set to "
            + new_low + "), Low rxreqmax " + cbInfo.lowRxReqMaxSequenceNumber()
            + ", High " + cbInfo.highSequenceNumber());
        try {
            cbInfo.setLowSequenceNumber(new_low);
        }
        catch (LBMEInvalException e) {
            System.Console.Out.WriteLine (e.getMessage());
        }
        return 0;
    }
}
</pre><p><br />
 </p>
<h2><a class="anchor" id="persistencemessageconsumption"></a>
Persistence Message Consumption&nbsp;&nbsp;<small><a href="#persistencemessageconsumption">&lt;-</a></small></h2>
<p>Receivers use message consumption, defined as message deletion, to indicate that UM should notify the store(s) that the application consumed the message. This notification takes the form of an acknowledgement, or ACK, to the store(s) in use, and optionally to the source if you configure the source for delivery confirmation.</p>
<p>In many applications, the message receiver application callback will fully process the received message. When the application callback returns, the message should be deleted and acknowledged.</p>
<p>However, there are other application designs where a received message cannot be fully processed inside the receiver application callback. For example, the message might need to be passed to a worker thread for longer-term processing. Or the acknowledgement must be delayed until some other event happens, like a handshake with another application. In these cases, the message deletion and/or message acknowledgement must not be done when the receiver callback returns.</p>
<p>Finally, for high-throughput applications, an application can completely suppress the acknowledgement of each individual message in favor of acknowledgement batching (acknowledging multiple messages in one operation). This is done to reduce the per-message overhead. Note that acknowledgement batching increases the chances that a restarted application will receive duplicate messages (messages that had been previously process but not yet acknowledged). See <a class="el" href="designingpersistenceapplications.html#duplicatmessagedelivery">Duplicate Message Delivery</a> for more information.</p>
<p><br />
 </p>
<h2><a class="anchor" id="immediatemessageconsumption"></a>
Immediate Message Consumption&nbsp;&nbsp;<small><a href="#immediatemessageconsumption">&lt;-</a></small></h2>
<p>In many applications, the message receiver application callback will fully process the received message. When the receive callback returns, the message should be deleted and acknowledged. This is handled differently between the C API vs. the Java and .NET APIs.</p>
<p><b>C API</b></p>
<p>The default behavior for a C receiver application callback is for the message to be deleted and acknowledged when the receiver callback returns. No special coding is needed for this use case.</p>
<p><b>Java and .NET</b></p>
<p>With Java and .NET, the UM library is not able to differentiate between a message that is passed to a different part of the application vs. a message which is simply dereferenced for eventual garbage collection. So the default behavior of the UM library is different &ndash; it is assumed that the message should <em>not</em> be deleted and acknowledged when the receiver application callback returns. Instead, the application is expected to explicitly dispose of received messages when processing is complete.</p>
<p>In the case where message processing is completed in the receiver callback, the application must call the "dispose()" method of the message object before returning. This triggers acknowledgement as well as cleanup of the message's resources.</p>
<p><br />
 </p>
<h2><a class="anchor" id="delayedmessageprocessing"></a>
Delayed Message Processing&nbsp;&nbsp;<small><a href="#delayedmessageprocessing">&lt;-</a></small></h2>
<p>There are application designs where a received message cannot be fully processed inside the receiver application callback. For example, the message might need to be passed to a worker thread for longer-term processing. Or the acknowledgement must be delayed until some other event happens, like a handshake with another application.</p>
<p>This is handled differently between the C API vs. the Java and .NET APIs.</p>
<p><b>C API</b></p>
<p>In the C API, the application's receiver callback function must call the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/api.tag:../API/" href="../API/lbm_8h.html#a2b7788ff58f9e78bc89ea890dad0cccf">lbm_msg_retain()</a> function for the received message. This suppresses the automatic deletion of the received message when the receiver callback returns, and allows the message buffer to be handed to some other part of the application for processing and deletion at a later time.</p>
<p>When the application subsequently completes all processing of the message and is ready for the message to be deleted and acknowledged, it calls <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/api.tag:../API/" href="../API/lbm_8h.html#aa5fc1eb324a55b8c800c31460b0f0116">lbm_msg_delete()</a>.</p>
<p><b>Java and .NET</b></p>
<p>With Java and .NET, the UM library assumes that the message should <em>not</em> be deleted and acknowledged when the receiver application callback returns. The callback can simply pass the message to some other part of the application for subsequent processing.</p>
<p>When the application has completed all processing on the message, the message's "dispose()" method should be called. This releases resources held by the object and also triggers the acknowledgement.</p>
<p><br />
 </p>
<h2><a class="anchor" id="batchingacknowledgments"></a>
Batching Acknowledgments&nbsp;&nbsp;<small><a href="#batchingacknowledgments">&lt;-</a></small></h2>
<p>For high-throughput applications, it is often desired to reduce the per-message overhead. Sending acknowledgements to the Store and optionally to the source normally involves multiple socket operations, which can limit the maximum sustainable throughput of a persistent receiver.</p>
<p>A significant reduction in per-message overhead can be achieved by batching acknowledgements. In this use case, the sending of acknowledgements is delayed until multiple messages have been received and processed. Then an acknowledgement is sent which covers all messages processed so far.</p>
<dl class="section warning"><dt>Warning</dt><dd>While ACK batching provides significant improvements in receiver throughput, it also increases the probability that a failed and restarted receiver will be sent <a class="el" href="designingpersistenceapplications.html#duplicatmessagedelivery">duplicate messages</a> (i.e. messages that the application has already received and processed).</dd></dl>
<p>ACK Batching can be done implicitly or explicitly. For implicit ACK batching, use the configuration options <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeuseackbatchingreceiver">ume_use_ack_batching (receiver)</a> and <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeackbatchingintervalcontext">ume_ack_batching_interval (context)</a>. Note that implicit ACK batching also supports out-of-order acknowledgements. See <a class="el" href="designingpersistenceapplications.html#ackordering">ACK Ordering</a>.</p>
<p>Explicit ACK batching gives the application precise control over when acknowledgements are sent via API calls. This mode of operation is enabled with the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeexplicitackonlyreceiver">ume_explicit_ack_only (receiver)</a> configuration option. If enabled, acknowledgements are only sent as a result of the application explicitly calling an API. This allows the application to use application-level knowledge to optimize when to send acknowledgements, potentially minimizing the time that processed messages are left unacknowledged (and therefore minimizing the number of potential <a class="el" href="designingpersistenceapplications.html#duplicatmessagedelivery">duplicate messages</a>).</p>
<p>See <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/api.tag:../API/" href="../API/lbm_8h.html#a2b5aa9394b4911eb8e39768a57d5b49e">lbm_ume_ack_send_explicit_ack()</a> and <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/api.tag:../API/" href="../API/lbm_8h.html#ad920e7ab51a45099390091dd36d26a34">lbm_msg_ume_send_explicit_ack()</a> for the C API. See <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/javaapi.tag:../JavaAPI/" href="../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMMessage.html#ac367c5298b0db98072b89d4572069db0">com::latencybusters::lbm::LBMMessage::sendExplicitAck()</a> for Java and .NET. See <a class="el" href="designingpersistenceapplications.html#explicitacknowledgments">Explicit Acknowledgments</a> for details on explicit ACKs.</p>
<p><br />
 </p>
<h2><a class="anchor" id="ackordering"></a>
ACK Ordering&nbsp;&nbsp;<small><a href="#ackordering">&lt;-</a></small></h2>
<p>The Persistent Store does not support "out of order" acknowledgement of messages. If the Store receives an acknowledgement of sequence number N, that implicitly acknowledges all sequence numbers less than N. If a receiving application has the ability to complete processing of messages out of order, it must ensure that an acknowledgement is sent for a given message until all previously-received messages have been completely processed.</p>
<p>Normally, the only way that a receiving application <em>can</em> process messages out of order is to retain those messages and complete processing of them outside of the receiver application callback function. This normally requires "retaining" the messages so that they aren't deleted (and therefore acknowledged) automatically when the receiver callback returns. In this usage, when a message is completely processed, that message is deleted by the application, triggering the acknowledgement of that message. However, if the application design allows those messages to be processed out of order, then the risk exists that the acknowledgement of a given message will implicitly acknowledge previous message which have not been completely processed. This will prevent those incompletely processed messages from being recovered if the receiving application fails and restarts.</p>
<p>ACK Batching can provide a solution, implicitly or explicitly.</p>
<p>The implicit form of ACK batching provides, as a convenience, the ability to postpone the sending of a message ACK until all previous received messages have also been processed. When the UM context wakes up every <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeackbatchingintervalcontext">ume_ack_batching_interval (context)</a> milliseconds, it checks for unacknowledged messages that have been deleted, either implicitly from the receiver callback returning, or explicitly by API calls to retain and then delete the message. UM will only acknowledge up to the highest <em>continuous</em> sequence number.</p>
<p>For example, let's say the application deletes messages with sequence numbers 0, 1, 5, 2, 4. Messages 3 and 6 are still being processed. If the context wakes up at this point, it will send an acknowledgement for sequence 2. If the application fails at this point and restarts, the Store will re-send messages 3, 4, 5, and 6. The receiving application must handle the fact that 3 and 6 were incompletely processed, whereas 4 and 5 were completely processed (see <a class="el" href="designingpersistenceapplications.html#duplicatmessagedelivery">Duplicate Message Delivery</a>).</p>
<p>Instead of using implicit batching for this, the application can be coded to use <a class="el" href="designingpersistenceapplications.html#explicitacknowledgments">Explicit Acknowledgments</a>. However, in this case, the application has the responsibility to implement a similar algorithm as the implicit ACK batcher described above. I.e. even though the messages 4 and 5 were fully processed, the application would need to postpone sending an acknowledgement until message 3 is also completed, at which point a single acknowledgement for sequence 5 can be sent.</p>
<p><br />
 </p>
<h2><a class="anchor" id="explicitacknowledgments"></a>
Explicit Acknowledgments&nbsp;&nbsp;<small><a href="#explicitacknowledgments">&lt;-</a></small></h2>
<p>UM supports Explicit acknowledgement which suppresses UM's default acknowledgement behavior, allowing your application complete control of message consumption notification.</p>
<p>There are two common use cases for Explicit Acknowledgements: </p><ul>
<li>
Deferred Acknowledgement. </li>
<li>
Application-level ACK batching. </li>
</ul>
<p>Deferred Acknowledgement means that the receiving application is not able to fully process a message within the message receiver application callback. For example, the message may require processing in a separate thread. By default, UM will acknowledge a persisted message when the receiver callback returns.</p>
<p>Application-level ACK batching means that the application chooses not to acknowledge every received message. Instead, it implements its own logic to decide which messages to acknowledge. Note that acknowledging a given message implicitly acknowledges all earlier messages. For example, acknowledging messages 5, 10, and 15 tells the Store that <em>all</em> messages 0-15 are acknowledged.</p>
<p>Also note that this imposes the restriction that messages be acknowledged in ascending order. See <a class="el" href="designingpersistenceapplications.html#ackordering">ACK Ordering</a> for more information.</p>
<p>Explicit acknowledgement is enabled using the configuration option <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeexplicitackonlyreceiver">ume_explicit_ack_only (receiver)</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="objectfreeexplicitacknowledgments"></a>
Object-free Explicit Acknowledgments&nbsp;&nbsp;<small><a href="#objectfreeexplicitacknowledgments">&lt;-</a></small></h2>
<p>When using explicit ACKs, you can extract ACK information from messages. This allows the received message buffer to be deleted when the receiver callback is done, while still allowing the application to save the ACK structure for persistent acknowledgement to the Store at a future time. This can improve receiver performance when used with the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/design.tag:../Design/" href="../Design/advancedoptimizations.html#receivebufferrecycling">Receive Buffer Recycling</a> feature to reduce the per-message use of dynamic memory (malloc/free) with a persistent receiver. Extracting ACKs can also additionally improve performance of Java and .NET applications by allowing the use of <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/design.tag:../Design/" href="../Design/fundamentalconcepts.html#zeroobjectdelivery">Zero Object Delivery</a>.</p>
<p>The following source code examples show how to extract ACK information and send an explicit ACK.</p>
<p><b>C API</b></p>
<pre class="fragment">int rcv_handle_msg(lbm_rcv_t *rcv, lbm_msg_t *msg, void *clientd)
{
  lbm_ume_rcv_ack_t *ack = NULL;
...

  ack = lbm_msg_extract_ume_ack(msg);
  defer_ack(ack);  /* Pass the "ack" to another thread or work queue. */
...
  return 0;
}

int worker()
{
  lbm_ume_rcv_ack_t *ack = NULL;
...
  ack = get_deferred_ack();  /* Get "ack" that was saved above. */

  /* Some applications improve throughput by not ACKing every message. */
  if (ack_this_message) {
    lbm_ume_ack_send_explicit_ack(ack, msg-&gt;sequence_number);
  }

  lbm_ume_ack_delete(ack);  /* Extracted ack *must* be deleted. */
...

}
</pre><p><b>JAVA API or .NET API</b></p>
<pre class="fragment">public int onReceive(Object cbArg, LBMMessage msg)
{
  UMEMessageAck ack;
...

  ack = msg.extractUMEAck();
  defer_ack(ack);  /* Pass the "ack" to another thread or work queue. */
...
  return 0;
}

int worker()
{
  UMEMessageAck ack;

  ack = get_deferred_ack();  /* Get "ack" that was saved above. */

  /* Some applications improve throughput by not ACKing every message. */
  if (ack_this_message) {
    ack.sendExplicitAck(msg.sequenceNumber());
  }
  ack.dispose();  /* Extracted ack *must* be deleted. */
}
</pre><p><br />
 </p>
<h1><a class="anchor" id="designingpersistentstores"></a>
Designing Persistent Stores&nbsp;&nbsp;<small><a href="#designingpersistentstores">&lt;-</a></small></h1>
<p>As mentioned in <a class="el" href="persistenceconcepts.html#persistentstoreconcept">Persistent Store Concept</a>, the persistent stores, also just called stores, actually persist the source and receiver state and use RegIDs to identify sources and receivers. Each source to which a store provides persistence may have zero or more receivers. The store maintains each receiver's state along with the source's state and the messages the source has sent.</p>
<p>The store can be configured with its own set of options to persist this state information on disk or simply in memory. The term disk store is used to signify a store that persists state to disk, and the term memory store is used to signify a store that persists state only in memory. A store may also be configured not to cache the source's data, but to simply persist the source and receiver state in memory. This is called a no-cache store.</p>
<p>A source does not send data to the store and then have the store forward it to the receivers. In UM, the source sends to receivers and the stores in parallel. See <a class="el" href="operationalview.html#persistencenormaloperation">Persistence Normal Operation</a>. Thus, UM can provide extremely low latency to receiving applications.</p>
<p>The store(s) that a source uses are part of the source's configuration settings. Sources must be configured to use specific store(s) in a Quorum/Consensus arrangement.</p>
<p>Receivers, on the other hand, do not need to be configured with store information a priori. The source provides store information to receivers via a Source Registration Information (SRI) message after the source registers with a store. Thus the receivers learn about stores from the source, without needing to be configured themselves. Because receivers learn about the store or stores with which they must register via a SRI record, the source must be available to receivers. However, the source does not have to be actively sending data to do this.</p>
<p><br />
 </p>
<h2><a class="anchor" id="storelogfile"></a>
Store Log File&nbsp;&nbsp;<small><a href="#storelogfile">&lt;-</a></small></h2>
<p>The store daemon generates log messages that are used to monitor its health and operation. You can configure these to be directed to "console" (standard output) or a specified log "file", via the <a class="el" href="configurationreferenceforumestored.html#logelement">&lt;log&gt;</a> configuration element. Normally "console" is only used during testing, as a persistent log file is preferred for production use. The store does not over-write log files on startup, but instead appends them.</p>
<p><br />
 </p>
<h2><a class="anchor" id="storerollinglogs"></a>
Store Rolling Logs&nbsp;&nbsp;<small><a href="#storerollinglogs">&lt;-</a></small></h2>
<p>To prevent unbounded disk file growth, the store supports rolling log files. When the log file rolls, the file is renamed according to the model: <br />
&#160;&#160;<em>CONFIGUREDNAME</em><code>_</code><em>PID</em><code>.</code><em>DATE</em><code>.</code><em>SEQNUM</em> <br />
where: </p><ul>
<li>
<em>CONFIGUREDNAME</em> - Root name of log file, as configured by user. </li>
<li>
<em>PID</em> - Process ID of the store daemon process. </li>
<li>
<em>DATE</em> - Date that the log file was rolled, in YYYY-MM-DD format. </li>
<li>
<em>SEQNUM</em> - Sequence number, starting at 1 when the process starts, and incrementing each time the log file rolls. </li>
</ul>
<p>For example: <code>umestorelog_9867.2017-08-20.2</code></p>
<p>The user can configure when the log file is eligible to roll over by either or both of two criteria: size and frequency. The size criterion is in millions of bytes. The frequency criterion can be daily or hourly. Once one or both criteria are met, the next message written to the log will trigger a roll operation. These criteria are supplied as attributes to the <a class="el" href="configurationreferenceforumestored.html#logelement">&lt;log&gt;</a> configuration element.</p>
<p>If both criteria are supplied, then the first one to be reached will trigger a roll. For example, consider the setting: </p><pre class="fragment">  &lt;log type="file" size="23" frequency="daily"&gt;store.log&lt;/log&gt;
</pre><p> Let say that the log file grows at 1 million bytes per hour. At 11:00 pm, the log file will reach 23 million bytes, and will roll. Then, at 12:00 midnight, the log file will roll again, even though it is only 1 million bytes in size.</p>
<dl class="section note"><dt>Note</dt><dd>The rolling logs cannot be configured to automatically overwrite old logs. Thus, the amount of disk space consumed by log files will grow without bound. The user must implement a desired process of archiving or deleting older log files according to the user's preference.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="quorumconsensusstoreusage"></a>
Quorum/Consensus Store Usage&nbsp;&nbsp;<small><a href="#quorumconsensusstoreusage">&lt;-</a></small></h2>
<p>To provide the highest degree of resiliency in the face of failures, UM provides the Quorum/Consensus failover strategy which allows a source to provide UM with a number of stores to be used at the same time. Multiple stores can fail and messaging can continue operation unhindered as long as a majority of configured stores are operational.</p>
<p>Quorum/Consensus, also called QC, allows a source and the associated receivers to have their persisted state maintained at several stores at the same time. Central to QC is the concept of a group of stores, which is a logical grouping of stores that are intended to signify a single entity of resilience. Within the group, individual stores may fail but for the group as a whole to be viable and provide resiliency, a quorum must be available. In UM, a quorum is a simple majority. For example, in a group of five stores, three stores are required to maintain a quorum. One or two stores may fail and the group continues to provide resiliency. UM requires a source to have a quorum of stores available in the group in order to send messages. A group can consist of a single store.</p>
<p>QC also provides the ability to use multiple groups. As long as a single group maintains quorum, then UM allows a source to proceed. Groups are logical in nature and can be combined in any way imaginable, such as by store location, store type, etc. In addition, QC provides the ability to specify backup stores within groups. Backups may be used if or when a store in the group becomes unresponsive to the source. Quorum/Consensus allows a source many different failure scenarios simply not available in other persistent messaging systems.</p>
<p><br />
 </p>
<h2><a class="anchor" id="sourcesusingquorumconsensusstoreconfiguration"></a>
Sources Using Quorum/Consensus Store Configuration&nbsp;&nbsp;<small><a href="#sourcesusingquorumconsensusstoreconfiguration">&lt;-</a></small></h2>
<p>In the case of Quorum/Consensus store behavior, a message is considered stable after it has been successfully stored within a group of stores or among groups of stores according to the two settings, intergroup behavior and intragroup behavior, described below.</p>
<ul>
<li>
<p class="startli">The intragroup behavior specifies the requirements needed to stabilize a message among the stores within a group. A message is stable for the group once it is successfully stored at a quorum (majority) of the group's stores or successfully stored in all the stores in the group.</p>
<p class="endli"></p>
</li>
<li>
The intergroup behavior specifies the requirements needed to stabilize a message among groups of stores. A message is stable among the groups if it is successfully stored at any group, a majority of groups, all groups, or all active groups. </li>
</ul>
<p>Notice that a message needs to meet intragroup stability requirements before it can meet intergroup stability requirements. These options provide a number of possibilities for retention of messages for the source.</p>
<p>The following figure displays a 3-group Quorum/Consensus configuration with each group in a different location. A message is considered stable when it has been successfully stored at a quorum of stores in all the active groups.</p>
<p><b>Quorum/Consensus - Single Location Groups</b></p>
<div class="image">
<img src="qc_config_one_locn.png" alt="qc_config_one_locn.png"/>
</div>
 <p>The source application's UM configuration file appears below.</p>
<pre class="fragment">source ume_store 10.29.3.77:10313:101000:0
source ume_store 10.29.3.77:11313:110000:0
source ume_store 10.29.3.77:12313:120000:0
source ume_store 10.29.3.77:13313:130000:0
source ume_store 10.29.3.77:14313:140000:0
source ume_store 10.29.3.78:15313:150000:1
source ume_store 10.29.3.78:16313:160000:1
source ume_store 10.29.3.78:17313:170000:1
source ume_store 10.29.3.79:18313:180000:2
source ume_store 10.29.3.79:19313:190000:2
source ume_store 10.29.3.79:29313:290000:2
source ume_store 10.29.3.79:39313:390000:2
source ume_store 10.29.3.79:49313:490000:2

source ume_message_stability_notification 1
source ume_store_behavior qc

source ume_store_group 0:5
source ume_store_group 1:3
source ume_store_group 2:5

source ume_retention_intragroup_stability_behavior quorum
source ume_retention_intergroup_stability_behavior all-active
</pre><p><br />
 </p>
<h1><a class="anchor" id="persistentfaultrecovery"></a>
Persistent Fault Recovery&nbsp;&nbsp;<small><a href="#persistentfaultrecovery">&lt;-</a></small></h1>
<p>Recovery from source and receiver failure is the real heart of persistent operation. For a source, this means continuing operation from where it stopped. For a receiver, this means essentially the same thing, but with the retransmission of missed messages. Application developers can easily leverage the information in UM to make their applications recover from failure in graceful ways.</p>
<p><a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/design.tag:../Design/" href="../Design/fundamentalconcepts.html#latejoin">Late Join</a> is the mechanism of persistent recovery as well as an UM streaming feature. If Late Join is turned off on a source (<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grplatejoin.html#latejoinsource">late_join (source)</a>) or receiver (<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grplatejoin.html#uselatejoinreceiver">use_late_join (receiver)</a>), it also turns off persistent recovery. In order to control Late Join behavior, UM provides a mechanism for a receiver to control the low sequence number. See <a class="el" href="designingpersistenceapplications.html#recoverymanagement">Recovery Management</a>.</p>
<p>Not all failures are recoverable. For application developers it usually pays in the long run to identify what types of errors are non-recoverable and how best to handle them when possible. Such an exercise establishes the precise boundaries of expected versus abnormal operating conditions.</p>
<p><br />
 </p>
<h2><a class="anchor" id="persistentsourcerecovery"></a>
Persistent Source Recovery&nbsp;&nbsp;<small><a href="#persistentsourcerecovery">&lt;-</a></small></h2>
<p>The following shows the basic steps of source recovery:</p>
<ol>
<li>
Re-register with the store. </li>
<li>
Determine the highest sequence number that the store has from the source. </li>
<li>
Resume sending with the next sequence number. </li>
</ol>
<p>Because UM allows you to stream messages and not wait until a message is stable at the persistent store before sending the next message, the main task of source recovery is to determine what messages the persistent store(s) have and what they don't. Therefore, when a source re-registers with a store during recovery, the store tells the source what sequence number it has as the most recent from the source. The registration event informs the application of this sequence number. See <a class="el" href="designingpersistenceapplications.html#sourceeventhandler">Source Event Handler</a>.</p>
<p>In addition, a mechanism exists (LBM_SRC_EVENT_SEQUENCE_NUMBER_INFO) that allows the application to know the sequence number assigned to every piece of data it sends. The combination of registration and sequence number information allows an application to know exactly what a store does have and what it does not and where it should pick up sending. An application designed to stream data in this way should consider how best to maintain this information.</p>
<p>When QC is in use, UM uses the consensus of the group(s) to determine what sequence number to use in the first message it will send. This is necessary as not all stores can be expected to be in total agreement about what was sent in a distributed system. The application can configure the source with the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeconsensussequencenumberbehaviorsource">ume_consensus_sequence_number_behavior (source)</a> to use the lowest sequence number of the latest group of sequence numbers seen from any store, the highest, or the majority. In most cases, the majority, which is the default, makes the most sense as the consensus. The lowest is a very conservative setting. And the highest is somewhat optimistic. Your application has the flexibility to handle this in any way needed.</p>
<p>If streaming is not what an application desires due to complexity, then it is very simple to use the <a class="el" href="operationalview.html#persistenceevents">Persistence Events</a> delivered to the application to mimic the behavior of restricting a source to having only one unstable message at a time.</p>
<p><br />
 </p>
<h2><a class="anchor" id="persistentreceiverrecovery"></a>
Persistent Receiver Recovery&nbsp;&nbsp;<small><a href="#persistentreceiverrecovery">&lt;-</a></small></h2>
<p>The following shows the basic steps of receiver recovery:</p>
<ol>
<li>
Re-register with the store. </li>
<li>
Determine the low sequence number. </li>
<li>
Request retransmission of messages starting with the low sequence number. </li>
</ol>
<p>UM provides extensive options for controlling how receivers handle recovery. By default, receivers want to restart after the last piece of data that was consumed prior to failure or graceful suspension. Since UM persists receiver state at the store, receivers request this state from the store as part of re-registration and recovery. Receiving applications experiencing unrecoverable loss can potentially retrieve missed messages from the stores by deleting and recreating the receiver object.</p>
<p>The actual sequence number that a receiver uses as the first topic level message to resume reception with is called the "low sequence number". UM provides a means of modifying this sequence number if desired. An application can decide to use the sequence number as is, to use an even older sequence number, to use a more recent sequence number, or to simply use the most recent sequence number from the source. See <a class="el" href="designingpersistenceapplications.html#recoverymanagement">Recovery Management</a> and <a class="el" href="designingpersistenceapplications.html#settingcallbackfunctiontosetrecoverysequencenumber">Setting Callback Function to Set Recovery Sequence Number</a>. This allows receivers great flexibility on a per source basis when recovering. New receivers, receivers with no pre-existing registration, also have the same flexibility in determining the sequence number to begin data reception.</p>
<p>Like sources, when QC is in use, UM uses the consensus of the group(s) to determine the low sequence number. And as with sources, this is necessary as not all stores can be expected to be in total agreement about what was acknowledged. The application can configure the receiver with <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeconsensussequencenumberbehaviorreceiver">ume_consensus_sequence_number_behavior (receiver)</a> to use the lowest sequence number of the latest group of sequence numbers seen from any store, the highest, or the majority. In most cases, the majority, which is the default, makes the most sense as the consensus. The lowest is a very conservative setting. And the highest is somewhat optimistic. In addition, this sequence number may be modified by the application after the consensus is determined.</p>
<p>For QC, UM load balances receiver retransmission requests among the available stores. In addition, if requests are unanswered, retransmissions of the actual requests will use different stores. This means that as long as a single store has a message, then it is possible for that message to be retransmitted to a requesting receiver.</p>
<p><br />
 </p>
<h1><a class="anchor" id="callablestore"></a>
Callable Store&nbsp;&nbsp;<small><a href="#callablestore">&lt;-</a></small></h1>
<p>It is possible for an application to start an instance of the store to run as an independent set of threads within the application process. However, there are several restrictions:</p>
<ol>
<li>
<p class="startli">The application may not make use of messaging. I.e. an application which intends to start a store instance must not create contexts, sources, or receivers, or make any use of UM except starting (and optionally stopping) the store. For applications that need to use messaging, it is suggested that the application create a child process from which to invoke the store. The parent process can then use messaging freely. See the example program <a href="../example/umestored_example.c">umestored_example.c</a> for an example of how this can be done.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Only a C API is provided at this time. Two API functions are available: <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/api.tag:../API/" href="../API/umestored__main_8h.html#ae0f0d211a889aee9ea3f4f57d4c75e3a">umestored_main()</a> to start the store threads running, and <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/api.tag:../API/" href="../API/umestored__main_8h.html#a974d80bb5206243675c3e0646cbd88d4">umestored_main_shutdown()</a> to request the store threads to stop gracefully.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/api.tag:../API/" href="../API/umestored__main_8h.html#ae0f0d211a889aee9ea3f4f57d4c75e3a">umestored_main()</a> API will not return until the store exits, either by processing a signal, or by the application calling <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/api.tag:../API/" href="../API/umestored__main_8h.html#a974d80bb5206243675c3e0646cbd88d4">umestored_main_shutdown()</a>. When <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/api.tag:../API/" href="../API/umestored__main_8h.html#ae0f0d211a889aee9ea3f4f57d4c75e3a">umestored_main()</a> does return, the store is in a safe state for the application to exit.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Only a single instance of the store may be started. This means that an application may not have two stores running concurrently, and it also means that an application may not start a store, shut it down, and then start it again. The store API is "single use".</p>
<p class="endli"></p>
</li>
<li>
The application may not set signal handlers for SIGPIPE, SIGUSR1, SIGINT, or SIGTERM. The store uses those signals. For applications that need to handle those signals, it is suggested that the application create a child process, as mentioned above (#1). </li>
</ol>
<p>For an example of how to use the <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/api.tag:../API/" href="../API/umestored__main_8h.html#ae0f0d211a889aee9ea3f4f57d4c75e3a">umestored_main()</a> API, see the example program <a href="../example/umestored_example.c">umestored_example.c</a>. Note that while the callable store APIs are usable on all supported platforms, this example program is restricted to Linux due to its use of <code>prctl()</code>, a Linux-only function. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
</body>
</html>
