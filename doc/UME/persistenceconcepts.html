<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Guide for Persistence: Persistence Concepts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen_manual.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Guide for Persistence
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('persistenceconcepts.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Persistence Concepts </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In discussing Persistence, we refer to specific recovery from the failures of sources, receivers, and Persistent Stores.</p>
<ul>
<li>
Failed sources can restart and resume sending data from the point at which they stopped. </li>
<li>
Receivers can recover from failure and begin receiving data from the point immediately prior to failure. This process is sometimes called durable subscription. </li>
<li>
Persistent Stores can also be restarted and continue providing persistence to the sources and receivers that they serve. </li>
</ul>
<p>The user can choose between two different persistence modes:</p>
<ul>
<li>
Source-paced Persistence (SPP) - default mode - the rate of message consumption by receivers does not constrain the rate a source can send. The Store instance writes all messages to storage, and messages are retained until they are overwritten when the allocated storage is filled. See <a class="el" href="operationalview.html#persistencenormaloperation">Persistence Normal Operation</a>. </li>
<li>
Receiver-paced Persistence (RPP) - optional mode - the rate of message consumption by receivers <em>does</em> constrain the rate a source can send. The Store instance only writes message to non-volatile storage if one or more required RPP receivers is absent or slow in consuming the messages. Messages are deleted from the Store instance once all receivers have consumed the RPP message. See <a class="el" href="operationalview.html#receiverpacedpersistenceoperations">RPP: Receiver-Paced Persistence</a>. </li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="persistentstoreconcept"></a>
Persistent Store Concept&nbsp;&nbsp;<small><a href="#persistentstoreconcept">&lt;-</a></small></h1>
<p>UM uses a daemon program known as the Store to persist source (publisher) and receiver (subscriber) state. A Store instance can persist state in memory as well as on disk. State is persisted on a per-topic, per-source basis by the Store. Along with each publisher's state is a message cache containing the full message contents of recently-sent messages by the source.</p>
<p>The purpose of the Store is to allow receivers to recover messages that the receiver was not able to receive directly from the source.</p>
<p>The Store is an independent component, not part of the source. If a persistent publisher fails, that source's messages are maintained by the Store according to configurable retention policies.</p>
<p>Note that the design of UM's persistence allows a maximum of 2,147,483,647 messages (2**31 - 1) to be persisted.</p>
<p><br />
 </p>
<h1><a class="anchor" id="persistenceconfigurationconcept"></a>
Persistence Configuration Concept&nbsp;&nbsp;<small><a href="#persistenceconfigurationconcept">&lt;-</a></small></h1>
<p>It is important to remember the different kinds of configuration. </p><ul>
<li>
Applications create UM objects (contexts, sources, receivers) using the UM library. Those objects must be configured to control their operation and behavior using <b>"LBM configuration options"</b>. An application typically uses an <b>"LBM configuration file"</b> in either XML or flat format. For full details on LBM configuration options, see <a href="../Config/index.html">UM Configuration Guide</a> </li>
<li>
A Store Process is configured using a <b>"Store configuration file"</b> in XML format. For full details on Store configuration files, see <a class="el" href="configurationreferenceforumestored.html">Configuration Reference for Umestored</a>. </li>
<li>
A Store Process also internally creates UM objects (contexts, sources, receivers) using the UM library. The Store's objects must also be configured using one or more LBM configuration files. </li>
</ul>
<p>So Stores need two kinds of configuration files: Store configuration files and LBM configuration files. Applications only need LBM configuration files.</p>
<p><br />
 </p>
<h1><a class="anchor" id="registrationidentifierconcept"></a>
Registration Identifier Concept&nbsp;&nbsp;<small><a href="#registrationidentifierconcept">&lt;-</a></small></h1>
<p>UM persistence identifies sources and receivers with Registration Identifiers, also called Registration IDs or RegIDs. A RegID is a 32-bit number that uniquely identifies a source or a receiver to a Store instance. This means that RegIDs are also specific to a Store instance and can be reused between individual Store instances, if needed. No two active sources or receivers can share a RegID or use the same RegID at the same time. This point is critical: since UM enables your application to use and handle RegIDs very freely, you must use RegIDs carefully to avoid destructive results.</p>
<p>RegIDs can also be managed easily through the use of Session IDs. See <a class="el" href="registrationidentifiers.html#managingregidswithsessionids">Managing RegIDs with Session IDs</a>.</p>
<p><br />
 </p>
<h1><a class="anchor" id="deliveryconfirmationconcept"></a>
Delivery Confirmation Concept&nbsp;&nbsp;<small><a href="#deliveryconfirmationconcept">&lt;-</a></small></h1>
<p>A persistent receiver provides confirmation (acknowledgement) to the Store instance as it consumes (processes) messages. This is fundamental to the design of UM persistence.</p>
<p>The receiver can optionally provide this confirmation (acknowledgment) to the persistent source. These confirmations are turned off by default, but can be requested through either or both two LBM configuration options: </p><ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.15/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeconfirmeddeliverynotificationsource">ume_confirmed_delivery_notification (source)</a> - deliver a source event to the application indicating message consumption. </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.15/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeretentionuniqueconfirmationssource">ume_retention_unique_confirmations (source)</a> - include receiver consumption as part of source flight size calculation. </li>
</ul>
<p>These two options are unrelated to each other, except that they both request the receiver to send delivery confirmations. Note that when either or both of the options are set, the persistent source <em>requests</em> that the persistent receiver supply delivery confirmations. The persistent receiver has the option to decline the request by setting the option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.15/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeallowconfirmeddeliveryreceiver">ume_allow_confirmed_delivery (receiver)</a> to 0.</p>
<dl class="section note"><dt>Note</dt><dd><a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.15/doc/UME/design.tag:../Design/" href="../Design/advancedoptimizations.html#smartsources">Smart Sources</a> do not support either form of delivery confirmation.</dd></dl>
<p>The latter LBM option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.15/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeretentionuniqueconfirmationssource">ume_retention_unique_confirmations (source)</a>, can provide a form of receiver-pacing; the source will not be allowed to exceed <a class="el" href="operationalview.html#persistenceflightsize">Persistence Flight Size</a> beyond receiving applications. For more information, see: <a class="el" href="designingpersistentsources.html#confirmeddelivery">Confirmed Delivery</a></p>
<p><br />
 </p>
<h1><a class="anchor" id="releasepolicy"></a>
Release Policy&nbsp;&nbsp;<small><a href="#releasepolicy">&lt;-</a></small></h1>
<p>Sources and Persistent Stores retain messages in memory according to a release policy, which is a set of rules that specifies when a message can be reclaimed. Each rule would allow any message that complies with the rule to be reclaimed. However, a message must comply with all rules before it can be reclaimed. Conversely, any message not complying with all rules will not be reclaimed. A source or Store instance retains messages in memory until its retention policy dictates the message may be removed. Sources and Stores use slightly different retention policies based on their individual roles.</p>
<p>For more information, see <a class="el" href="designingpersistentsources.html#sourcemessageretentionandrelease">Source Message Retention and Release</a>.</p>
<p><br />
 </p>
<h1><a class="anchor" id="messagestabilityconcept"></a>
Message Stability Concept&nbsp;&nbsp;<small><a href="#messagestabilityconcept">&lt;-</a></small></h1>
<p>Sources send messages to both receivers and to Store instances. Messages become stable once the message has been persisted at the Store or a set of Stores, and those Stores acknowledge stability to the sources. Since it takes time to write messages to disk and signal stability, the source is allowed to continue sending messages while waiting for stability acknowledgements. Any messages sent but not yet acknowledged are said to be "&lt;i&gt;in flight&lt;/i&gt;". The number of in-flight messages is normally limited. For more information, see <a class="el" href="operationalview.html#persistenceflightsize">Persistence Flight Size</a>.</p>
<p>In addition, UM informs the application when messages are stabilized. Until that stability acknowledgement is received, the source can not assume the messages will be successfully delivered. The message stability acknowledgement is vital to ensuring that messages will not be lost. For more information, see <a class="el" href="designingpersistentsources.html#sourcemessageretentionandrelease">Source Message Retention and Release</a>.</p>
<p><br />
 </p>
<h1><a class="anchor" id="quorumconsensusstorefailover"></a>
Quorum/Consensus Store Failover&nbsp;&nbsp;<small><a href="#quorumconsensusstorefailover">&lt;-</a></small></h1>
<p>Typically, multiple Store instances are deployed as a group for redundant operation. In this configuration, one or more Stores (or the hosts they run on) can fail without impacting the message flow from sources to receivers, as long as a <em>quorum</em> of the configured Stores is operational. UM defines a quorum as a majority of the configured Stores. E.g. if 3 Store instances are configured, messaging can continue as long as at least 2 are operational. If 5 Store instances are configured, messaging can continue if at least 3 are operational. (Quorum/Consensus requires an odd number of Store instances in the QC group.)</p>
<p>Sources define the QC group by the LBM configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.areas/builds/UMQ_6.15/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umestoresource">ume_store (source)</a>, one for each Store in the group.</p>
<p><br />
<br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
</body>
</html>
