<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Guide for Persistence: Persistence Concepts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen_manual.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Guide for Persistence
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('persistenceconcepts.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Persistence Concepts </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In discussing Persistence, we refer to specific recovery from the failures of sources, receivers, and persistent stores. Failed sources can restart and resume sending data from the point at which they stopped. Receivers can recover from failure and begin receiving data from the point immediately prior to failure. This process is sometimes called durable subscription. Persistent stores can also be restarted and continue providing persistence to the sources and receivers that they serve. Persistence is not designed to address ongoing, corrupting agents. Rather, if one of its components fails, the design of Persistence enables it to continue supporting its ongoing operations at some level.</p>
<p>UM offers persistence in the following two modes:</p>
<ul>
<li>
Source-paced Persistence (SPP) - default mode - the rate of message consumption by receivers does not constrain the rate a source can send. Persistent Stores write all messages to non-volatile storage, and messages are retained until they are overwritten when the allocated storage is filled. See <a class="el" href="operationalview.html#persistencenormaloperation">Persistence Normal Operation</a>. </li>
<li>
Receiver-paced Persistence (RPP) - optional mode - the rate of message consumption by receivers <em>does</em> constrain the rate a source can send. Persistent Stores only write message to non-volatile storage if one or more necessary receiver is slow in consuming the messages, and messages are deleted from the Store once all necessary receivers have consumed the message. See <a class="el" href="operationalview.html#rppnormaloperation">RPP Normal Operation</a>. </li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="persistentstoreconcept"></a>
Persistent Store Concept&nbsp;&nbsp;<small><a href="#persistentstoreconcept">&lt;-</a></small></h1>
<p>UM uses a daemon to persist source and receiver state outside the actual sources and receivers themselves. This daemon is the Persistent Store. The store can persist state in memory as well as on disk. State is persisted on a per-topic, per-source basis by the store. Persistent stores need not be a single entity. For fault tolerance purposes, it is possible to configure multiple stores in various ways.</p>
<p>For more information, see:</p>
<ul>
<li>
<a class="el" href="enablingpersistence.html#addingthestoretoasource">Adding the Store to a Source</a>, </li>
<li>
<a class="el" href="designingpersistenceapplications.html#designingpersistentstores">Designing Persistent Stores</a>, </li>
<li>
<a class="el" href="persistencefaulttolerance.html#storeconfigurationconsiderations">Store Configuration Considerations</a>, </li>
<li>
<a class="el" href="manpagesforstore.html#umestoredmanpage">Umestored Man Page</a>, </li>
<li>
<a class="el" href="configurationreferenceforumestored.html">Configuration Reference for Umestored</a>. </li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="registrationidentifierconcept"></a>
Registration Identifier Concept&nbsp;&nbsp;<small><a href="#registrationidentifierconcept">&lt;-</a></small></h1>
<p>UM persistence identifies sources and receivers with Registration Identifiers, also called Registration IDs or RegIDs. A RegID is a 32-bit number that uniquely identifies a source or a receiver to a store. This means that RegIDs are also specific to a store and can be reused between individual stores, if needed. No two active sources or receivers can share a RegID or use the same RegID at the same time. This point is critical: since UM enables your application to use and handle RegIDs very freely, you must use RegIDs carefully to avoid destructive results.</p>
<p>For more information, see:</p>
<ul>
<li>
<a class="el" href="enablingpersistence.html#addingfaultrecoverywithregistrationids">Adding Fault Recovery with Registration IDs</a> </li>
<li>
<a class="el" href="designingpersistenceapplications.html#registrationidentifiers">Registration Identifiers</a> </li>
<li>
<p class="startli">RegIDs can also be managed easily with the use of Session IDs. See <a class="el" href="designingpersistenceapplications.html#managingregidswithsessionids">Managing RegIDs with Session IDs</a>.</p>
<p class="endli"><br />
 </p>
</li>
</ul>
<h1><a class="anchor" id="deliveryconfirmationconcept"></a>
Delivery Confirmation Concept&nbsp;&nbsp;<small><a href="#deliveryconfirmationconcept">&lt;-</a></small></h1>
<p>A persistent receiver provides confirmation (acknowledgement) to the persistent store as it consumes (processes) messages. This is fundamental to the design of UM persistence.</p>
<p>The receiver can optionally provide this confirmation (acknowledgment) to the persistent source. These confirmations are turned off by default, but can be requested through either or both two configuration options: </p><ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeconfirmeddeliverynotificationsource">ume_confirmed_delivery_notification (source)</a> - deliver a source event to the application indicating message consumption. </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeretentionuniqueconfirmationssource">ume_retention_unique_confirmations (source)</a> - include receiver consumption as part of source flight size calculation. </li>
</ul>
<p>These two options are unrelated to each other, except that they both request the receiver to send delivery confirmations. Note that when either or both of the options are set, the persistent source <em>requests</em> that the persistent receiver supply delivery confirmations. The persistent receiver has the option to decline the request by setting the option <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeallowconfirmeddeliveryreceiver">ume_allow_confirmed_delivery (receiver)</a> to 0.</p>
<dl class="section note"><dt>Note</dt><dd><a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/design.tag:../Design/" href="../Design/advancedoptimizations.html#smartsources">Smart Sources</a> do not support either form of delivery confirmation.</dd></dl>
<p>The latter option, <a class="elRef" doxygen="/29W/Amun/home/sford/sfordmac_DEV_HF_6_12/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeretentionuniqueconfirmationssource">ume_retention_unique_confirmations (source)</a>, can provide a form of receiver-pacing; the source will not be allowed to exceed <a class="el" href="operationalview.html#persistenceflightsize">Persistence Flight Size</a> beyond receiving applications. For more information, see: <a class="el" href="designingpersistenceapplications.html#confirmeddelivery">Confirmed Delivery</a></p>
<p><br />
 </p>
<h1><a class="anchor" id="releasepolicy"></a>
Release Policy&nbsp;&nbsp;<small><a href="#releasepolicy">&lt;-</a></small></h1>
<p>Sources and persistent stores retain data according to a release policy, which is a set of rules that specifies when a message can be reclaimed. Each rule would allow any message that complies with the rule to be reclaimed. However, a message must comply with all rules before it can be reclaimed. Conversely, any message not complying with all rules will not be reclaimed. A source or store retains messages until its retention policy dictates the message may be removed. Sources and stores use slightly different retention policies based on their individual roles.</p>
<p>For more information, see <a class="el" href="designingpersistenceapplications.html#sourcemessageretentionandrelease">Source Message Retention and Release</a>.</p>
<p><br />
 </p>
<h1><a class="anchor" id="messagestabilityconcept"></a>
Message Stability Concept&nbsp;&nbsp;<small><a href="#messagestabilityconcept">&lt;-</a></small></h1>
<p>Sources send messages to both receivers and to stores. Messages become stable once the message has been persisted at the store or a set of stores, and those stores acknowledge stability to the sources. Since it takes time to write messages to disk and signal stability, the source is allowed to continue sending messages while waiting for stability acknowledgements. Any messages sent but not yet acknowledged are said to be "&lt;i&gt;in flight&lt;/i&gt;". The number of in-flight messages is normally limited. For more information, see <a class="el" href="operationalview.html#persistenceflightsize">Persistence Flight Size</a>.</p>
<p>In addition, UM informs the application when messages are stabilized. Until that stability acknowledgement is received, the source can not assume the messages will be successfully delivered. The message stability acknowledgement is vital to ensuring that messages will not be lost. For more information, see <a class="el" href="designingpersistenceapplications.html#sourcemessageretentionandrelease">Source Message Retention and Release</a>.</p>
<p><br />
 </p>
<h1><a class="anchor" id="quorumconsensusstorefailover"></a>
Quorum/Consensus Store Failover&nbsp;&nbsp;<small><a href="#quorumconsensusstorefailover">&lt;-</a></small></h1>
<p>Typically, multiple stores are deployed for simultaneous redundant operation. In this configuration, one or more stores (or the hosts they run on) can fail without impacting the message flow from sources to receivers, as long as a <em>quorum</em> of the configured stores is operational. UM defines a quorum as a majority of the configured stores. E.g. if 3 stores are configured, messaging can continue as long as at least 2 are operational. If 5 stores are configured, messaging can continue if at least 3 are operational. (Quorum/Consensus requires that an odd number of stores be configured.) </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
</body>
</html>
