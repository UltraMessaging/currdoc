<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Guide for Persistence: Enabling Persistence</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen_manual.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Guide for Persistence
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('enablingpersistence.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Enabling Persistence </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The following table lists all source files used in this section. The files can be found in the /doc/example directory. You can also access these file via the Sample Source Code tab in the left panel, under C Example Source Code.</p>
<table class="doxtable">
<tr>
<th>Filename </th><th>Content </th></tr>
<tr>
<td><a href="../example/ume-example-src.c">ume-example-src.c</a> </td><td>Source Application </td></tr>
<tr>
<td><a href="../example/ume-example-rcv.c">ume-example-rcv.c</a> </td><td>Receiver Application </td></tr>
<tr>
<td><a href="../example/ume-example-src-2.c">ume-example-src-2.c</a> </td><td>Source Application 2 </td></tr>
<tr>
<td><a href="../example/ume-example-rcv-2.c">ume-example-rcv-2.c</a> </td><td>Receiver Application 2 </td></tr>
<tr>
<td><a href="../example/ume-example-src-3.c">ume-example-src-3.c</a> </td><td>Source Application 3 </td></tr>
<tr>
<td><a href="../example/ume-example-rcv-3.c">ume-example-rcv-3.c</a> </td><td>Receiver Application 3 </td></tr>
<tr>
<td><a href="../example/ume-example-config.xml">ume-example-config.xml</a> </td><td>Persistent Store Configuration File </td></tr>
</table>
<p><br />
 </p>
<h1><a class="anchor" id="startingconfiguration"></a>
Starting Configuration&nbsp;&nbsp;<small><a href="#startingconfiguration">&lt;-</a></small></h1>
<p>We begin with the minimal source and receiver used by the QuickStart Guide. To more easily demonstrate the persistence features we are interested in, we have modified the QuickStart source and receiver in the following ways.</p>
<ul>
<li>
Modified the source to send 20 messages with a one second pause between each message. </li>
<li>
Modified the receiver to anticipate 20 messages instead of just one. </li>
<li>
Assigned the topic, "UME Example", to both the source and receiver. </li>
<li>
Modified the receiver to not exit on unexpected receiver events. </li>
</ul>
<p>The last change allows us to better demonstrate basic operation and evolve our receiver slowly without having to anticipate all the options that UM provides up front.</p>
<p>Example files for our exercise are: </p><table class="doxtable">
<tr>
<th>Filename </th><th>Content </th></tr>
<tr>
<td><a href="../example/ume-example-src.c">ume-example-src.c</a> </td><td>Source Application </td></tr>
<tr>
<td><a href="../example/ume-example-rcv.c">ume-example-rcv.c</a> </td><td>Receiver Application </td></tr>
</table>
<p><br />
 </p>
<h1><a class="anchor" id="addingthestoretoasource"></a>
Adding the Store to a Source&nbsp;&nbsp;<small><a href="#addingthestoretoasource">&lt;-</a></small></h1>
<p>The fundamental component of a persistence solution is the persistent store. To use a store, a source needs to be configured to use one by setting <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umestoresource">ume_store (source)</a> for the source. We can do that with the following piece of code.</p>
<pre class="fragment">err = lbm_src_topic_attr_str_setopt(&amp;attr, "ume_store", "127.0.0.1:14567");
</pre><p>This sets the persistent store for the source to the store running at 127.0.0.1 on port 14567.</p>
<p>Example files for our exercise are: </p><table class="doxtable">
<tr>
<th>Filename </th><th>Content </th></tr>
<tr>
<td><a href="../example/ume-example-src-2.c">ume-example-src-2.c</a> </td><td>Source Application 2 </td></tr>
<tr>
<td><a href="../example/ume-example-rcv-2.c">ume-example-rcv-2.c</a> </td><td>Receiver Application 2 </td></tr>
<tr>
<td><a href="../example/ume-example-config.xml">ume-example-config.xml</a> </td><td>Persistent Store Configuration File </td></tr>
</table>
<p>After adding the ume-store specification to the source, perform the following steps (assumes a Unix command prompt):</p>
<ol>
<li>
Create the cache and state directories. <br />
<code>$ mkdir umestored-cache ; mkdir umestored-state</code> </li>
<li>
Start up the store. <br />
<code>$ umestored ume-example-config.xml</code> </li>
<li>
Start the Receiver. <br />
<code>$ ume-example-rcv</code> </li>
<li>
Start the Source. <br />
<code>$ ume-example-src</code> </li>
</ol>
<p>You should see a message on the source that says:</p>
<pre class="fragment">INFO: Source "UME Example" Late Join not set, but UME store specified. Setting Late Join.
</pre><p>This is an informational message from UM and merely means Late Join was not set and that UM is going to set it.</p>
<p>Notice that the receiver was not configured with any store information. That is because setting it on the source is all that is needed. The receiver learns UM store settings from the source through the normal UM topic resolution process. Receivers don't need to do anything special to leverage the usage of a store by a source.</p>
<p><br />
 </p>
<h1><a class="anchor" id="addingfaultrecoverywithregistrationids"></a>
Adding Fault Recovery with Registration IDs&nbsp;&nbsp;<small><a href="#addingfaultrecoverywithregistrationids">&lt;-</a></small></h1>
<p>If the source or receiver crashes, how does the source and receiver tell the store that they have restarted and wish to resume where they left off? We need to add in some sort of identifiers to the source and receiver so that the store knows which sources and receivers they are.</p>
<p>In persistence, these identifiers are called Registration IDs or RegIDs. UM allows the application to control the use of RegIDs as it wishes. This allows applications to migrate sources and receivers not just between systems, but between locations with true, unprecedented freedom. However, UM requires an application to be careful of how it uses RegIDs. Specifically, an application must not use the same RegID for multiple sources and/or receivers at the same time.</p>
<p>Now let's look at how we can use RegIDs to provide complete fault recovery of sources and receivers. We'll first handle RegIDs in the simplest manner by using static IDs for our source and receiver. For the source, the RegID of 1000 can be added to the existing store specification by changing the string to <code>127.0.0.1:14567:1000</code></p>
<p>This yields the source code in <a href="../example/ume-example-src-2.c">ume-example-src-2.c</a></p>
<p>For the receiver, we accomplish this in two steps.</p>
<ol>
<li>
<p class="startli">Set a callback function to be called when we desire to set the RegID to 1100. This is done by declaring a callback function which will return the RegID value 1100 to UM. The example names the callback <code>app_rcv_regid_callback()</code>.</p>
<p class="endli"></p>
</li>
<li>
Inform the UM configuration for the receiver to use this callback function. That is accomplished by setting the ume_registration_extended_function() similar to example code below. </li>
</ol>
<pre class="fragment">lbm_ume_rcv_regid_ex_func_t id;      /* structure to hold registration function information */
id.func = app_rcv_regid_callback;    /* the callback function to call */
id.clientd = NULL;                   /* the value to pass in the clientd to the function */
err = lbm_rcv_topic_attr_setopt(&amp;attr, "ume_registration_extended_function", &amp;id, sizeof(id));
</pre><p>Once this is done, the receiver has the ability to control what RegID it will use. This yields the source code in <a href="../example/ume-example-rcv-2.c">ume-example-rcv-2.c</a>.</p>
<p>With these in place, you can experiment with killing the receiver and bringing it back (as long as you bring it back before the source is finished), as well as killing the source and bringing it back.</p>
<p>The restriction to this initial approach to RegIDs is that the RegIDs 1000 and 1100 may not be used by any other objects at the same time. If you run additional sources or receivers, they must be assigned new RegIDs, not 1000 or 1100. Let's now take a more sophisticated approach to RegIDs that will allow much more flexibility.</p>
<p><br />
 </p>
<h1><a class="anchor" id="enablingpersistencebetweenthesourceandstore"></a>
Enabling Persistence Between the Source and Store&nbsp;&nbsp;<small><a href="#enablingpersistencebetweenthesourceandstore">&lt;-</a></small></h1>
<p>Let's refine our source to include some desired behavior following a crash. Upon restart, we want our source to resume with the first unsent message. For example, if the source sent 10 messages and crashed, we want our source to resume with the 11th message and continue until it has sent the 20th message.</p>
<p>Accomplishing this graceful resumption requires us to ensure that our source is the only source that uses the RegID assigned to it. The same RegID should be used as long as the source has not sent the 20th message regardless of any crashes that may occur. The sources and receivers are primarily responsible for managing the RegIDs.</p>
<p>The following two sections explain the changes needed for the source and receiver, which become fairly easy due to the events that UM delivers to the application during persistence operation.</p>
<p><br />
 </p>
<h1><a class="anchor" id="enablingpersistenceinthesource"></a>
Enabling Persistence in the Source&nbsp;&nbsp;<small><a href="#enablingpersistenceinthesource">&lt;-</a></small></h1>
<p>With the above mentioned behaviors in mind, let's turn to looking at how they may be implemented with persistence, starting with the source. We can summarize the changes we need by the following list.</p>
<ol>
<li>
At source startup, use any saved RegID information found in the file by setting information in the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umestoresource">ume_store (source)</a> configuration variable. </li>
<li>
After the store registration is successful, if a new RegID was assigned to the source, save the RegID to the file. </li>
<li>
Set the message number to begin sending. Refer to the explanation below. </li>
<li>
Send until message number 20 has been sent. </li>
<li>
After message 20 has been sent, delete the saved RegID file. </li>
</ol>
<p>For Step 3, if the source has just been initialized, the application starts with message number 1. If the source has been restarted after a crash, the application looks to UM to establish the beginning message number because UM will use the next sequence number. For this simple example, we can make the assumption that each message is one sequence number for UM and that UM starts with sequence number 0. Thus the application can set the message number it begins resending with the value of the UM sequence number + 1. These changes yield the source code in <a href="../example/ume-example-src-3.c">ume-example-src-3.c</a></p>
<p><br />
 </p>
<h2><a class="anchor" id="smartsourcesandpersistence"></a>
Smart Sources and Persistence&nbsp;&nbsp;<small><a href="#smartsourcesandpersistence">&lt;-</a></small></h2>
<p>When using the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/design.tag:../Design/" href="../Design/advancedoptimizations.html#smartsources">Smart Sources</a> feature to send persistent messages, there are a few restrictions: </p><ul>
<li>
No support for source-side delivery confirmation. Neither of the forms described in <a class="el" href="persistenceconcepts.html#deliveryconfirmationconcept">Delivery Confirmation Concept</a> are allowed. </li>
<li>
No support for <a class="el" href="designingpersistenceapplications.html#receiverlivenessdetection">Receiver Liveness Detection</a>. </li>
<li>
Application stability notification is only supported per-message. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umemessagestabilitynotificationsource">ume_message_stability_notification (source)</a>. </li>
<li>
The following configuration options have limited or no support with Smart Sources: <ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeconfirmeddeliverynotificationsource">ume_confirmed_delivery_notification (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeretentionuniqueconfirmationssource">ume_retention_unique_confirmations (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umesriflushsrirequestresponsesource">ume_sri_flush_sri_request_response (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umesrirequestresponselatencysource">ume_sri_request_response_latency (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umemessagestabilitynotificationsource">ume_message_stability_notification (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizethresholdsource">retransmit_retention_size_threshold (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeretentionsizethresholdsource">ume_retention_size_threshold (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitretentionsizelimitsource">retransmit_retention_size_limit (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeretentionsizelimitsource">ume_retention_size_limit (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../Config/" href="../Config/grpdeprecated.html#retransmitretentionagethresholdsource">retransmit_retention_age_threshold (source)</a> </li>
</ul>
</li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="enablingpersistenceinthereceiver"></a>
Enabling Persistence in the Receiver&nbsp;&nbsp;<small><a href="#enablingpersistenceinthereceiver">&lt;-</a></small></h1>
<p>Let's also refine the receiver to resume where it left off after a crash. Just as with the source, the receiver can have the store assign it a RegID if the receiver is just beginning. Once the receiver receives the 20th message from the source, it can get rid of the RegID and exit. Because the receiver can receive some messages, crash, and come back, we should only need to look at a message and check if it is the 20th message based on the message contents or sequence number. UM provides all the events to the application that we need to create these behaviors in the receiver.</p>
<p>The receiver changes are summarized below:</p>
<ol>
<li>
<p class="startli">At receiver startup, use any saved RegID information found in the file for callback information when needed.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">When RegID callback is called: Check to see if the source RegID matches the saved source RegID. If it does, return the saved receiver RegID. RegID matches the saved source RegID if so, return the saved receiver RegID.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">After store registration is successful: If not using a previously saved RegID, then save the RegID assigned by the store to the source to a file, as well as the store information and the source RegID.</p>
<p class="endli"></p>
</li>
<li>
After the last message is received (message number 20 or UM sequence number 19), end the application and delete the saved RegID file. </li>
</ol>
<p>RegIDs in UM can be considered to be per source and per topic. Thus the receiver does not want to use the wrong RegID for a different source on the same topic. To avoid this, we save the source RegID and even store information so that the <code>app_rcv_regid_callback()</code> can make sure to use the correct RegID for the given source RegID. These changes yield the source code in <a href="../example/ume-example-rcv-3.c">ume-example-rcv-3.c</a></p>
<p>The above sources and receivers are simplified for illustration purposes and do have some limitations. The receiver will only keep the information for one source at a time saved to the file. This is fine for illustration purposes, but would be lacking in completeness for production applications unless it was assured that a single source for any topic would be in use. To extend the receiver to include several sources is simply a matter of saving each to the file, reading them in at startup, and being able to search for the correct one for each callback invoked. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
</body>
</html>
