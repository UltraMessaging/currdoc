<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Guide for Persistence: Configuring for Persistence and Recovery</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen_manual.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Guide for Persistence
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('configuringforpersistenceandrecovery.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Configuring for Persistence and Recovery </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Deployment decisions play a huge role in the success of any persistent system. Configuration in UM has a number of options that aid in performance, fault recovery, and overall system stability. It is not possible, or at least not wise, to totally divorce configuration from application development for high performance systems. This is true not only for persistent systems, but for practically all distributed systems. When designing systems, deployment considerations need to be taken into account for the following:</p>
<ul>
<li>
<p class="startli"><a class="el" href="configuringforpersistenceandrecovery.html#sourceconsiderations">Source Considerations</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="configuringforpersistenceandrecovery.html#receiverconsiderations">Receiver Considerations</a>.</p>
<p class="endli"></p>
</li>
<li>
<a class="el" href="configuringforpersistenceandrecovery.html#storeconfigurationconsiderations">Store Configuration Considerations</a>. </li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="sourceconsiderations"></a>
Source Considerations&nbsp;&nbsp;<small><a href="#sourceconsiderations">&lt;-</a></small></h1>
<p>Performance of sources is heavily impacted by:</p>
<ul>
<li>
<p class="startli">The <a class="el" href="persistenceconcepts.html#releasepolicy">Retention Policy</a> that the source uses,</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Streaming methods of the source,</p>
<p class="endli"></p>
</li>
<li>
The throughput and latency requirements of the data. </li>
</ul>
<p>Source release settings have a direct impact on memory usage. As messages are retained, they consume memory. You reclaim memory when you release messages. Message stability, delivery confirmation and retention size all interact to create your release policies. UM provides a hard limit on the memory usage. When exceeded, UM delivers a Forced Reclamation event. Thus applications that anticipate forced reclamations can handle them appropriately. See also <a class="el" href="designingpersistentsources.html#sourcemessageretentionandrelease">Source Message Retention and Release</a>.</p>
<p>How the source streams data has a direct impact on latency and throughput. One streaming method sets a maximum, outstanding count of messages. Once reached, the source does not send any more until message stability notifications come in to reduce the number of outstanding messages. The umesrc example program uses this mechanism to limit the speed of a source to something a Store can handle comfortably. This also provides a maximum bound on recovery that can simplify handling of streaming source recovery.</p>
<p>The throughput and latency requirements of the data are normal UM concerns.</p>
<p><br />
 </p>
<h1><a class="anchor" id="receiverconsiderations"></a>
Receiver Considerations&nbsp;&nbsp;<small><a href="#receiverconsiderations">&lt;-</a></small></h1>
<p>In addition to the following, receiver performance shares the same considerations as receivers during normal operation.</p>
<p><br />
 </p>
<h2><a class="anchor" id="receiveracknowledgementgeneration"></a>
Receiver Acknowledgement Generation&nbsp;&nbsp;<small><a href="#receiveracknowledgementgeneration">&lt;-</a></small></h2>
<p>Persistent receivers send a message consumption acknowledgement to Stores and the message source. Some applications may want to control this acknowledgement explicitly themselves. In this case, <a class="elRef" doxygen="/29W/Amun/home/sford/backup_exclude/labbox/sfordw_REL_6_16_1/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umeexplicitackonlyreceiver">ume_explicit_ack_only (receiver)</a> can be used.</p>
<p><br />
 </p>
<h2><a class="anchor" id="controllingretransmission"></a>
Controlling Retransmission&nbsp;&nbsp;<small><a href="#controllingretransmission">&lt;-</a></small></h2>
<p>Receivers send retransmission requests and receive and process retransmissions. Control over this process is crucial when handling very long recoveries, such as hundreds of thousands or millions of messages. A receiver only sends a certain number of retransmission requests at a time.</p>
<p>This means that a receiver will not, unless configured to with <a class="elRef" doxygen="/29W/Amun/home/sford/backup_exclude/labbox/sfordw_REL_6_16_1/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestoutstandingmaximumreceiver">retransmit_request_outstanding_maximum (receiver)</a>, request everything at once. The value of the low sequence number (<a class="el" href="persistentfaultrecovery.html#persistentreceiverrecovery">Persistent Receiver Recovery</a>) has a direct impact on how many requests need to be handled. A receiving application can decide to only handle the last X number of messages instead of recovering them all using the option, <a class="elRef" doxygen="/29W/Amun/home/sford/backup_exclude/labbox/sfordw_REL_6_16_1/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestmaximumreceiver">retransmit_request_maximum (receiver)</a>. The timeout used between requests, if the retransmission does not arrive, is totally controllable with <a class="elRef" doxygen="/29W/Amun/home/sford/backup_exclude/labbox/sfordw_REL_6_16_1/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grplatejoin.html#retransmitrequestintervalreceiver">retransmit_request_interval (receiver)</a>. And the total time given to recover all messages is also controllable.</p>
<p><br />
 </p>
<h2><a class="anchor" id="receiverrecoveryprocess"></a>
Receiver Recovery Process&nbsp;&nbsp;<small><a href="#receiverrecoveryprocess">&lt;-</a></small></h2>
<p>Theoretically, receivers can handle up to roughly 2 billion messages during recovery. This limit is implied from the sequence number arithmetic and not from any other limitation. For recovery, the crucial limiting factor is how a receiver processes and handles retransmissions which come in as fast as UM can request them and a Store can retransmit them. This is perhaps much faster than an application can handle them. In this case, it is crucial to realize that as recovery progresses, the source may still be transmitting new data. This data will be buffered until recovery is complete and then handed to the application. It is prudent to understand application processing load when planning on how much recovery is going to be needed and how it may need to be configured within UM.</p>
<p><br />
 </p>
<h1><a class="anchor" id="storeconfigurationconsiderations"></a>
Store Configuration Considerations&nbsp;&nbsp;<small><a href="#storeconfigurationconsiderations">&lt;-</a></small></h1>
<p>Stores have numerous configuration options. See <a class="el" href="configurationreferenceforumestored.html">Configuration Reference for Umestored</a> for details.</p>
<p><br />
 </p>
<h2><a class="anchor" id="configuringstoreusagepersource"></a>
Configuring Store Usage per Source&nbsp;&nbsp;<small><a href="#configuringstoreusagepersource">&lt;-</a></small></h2>
<p>A Store handles persisted state on a per topic per source basis. Based on the load of topics and sources, it may be prudent to spread the topic space, or just source space, across Stores as a way to handle large loads. As configuration of Store usage is per source, this is extremely easy to do. It is easy to spread CPU load via multi-threading as well as hard disk usage across Stores. A single Store Process can have a set of Store instances within it, each with their own thread.</p>
<p><br />
 </p>
<h2><a class="anchor" id="memoryusebystores"></a>
Memory Use by Stores&nbsp;&nbsp;<small><a href="#memoryusebystores">&lt;-</a></small></h2>
<p>As mentioned previously in <a class="el" href="persistenceconcepts.html#persistentstoreconcept">Persistent Store Concept</a>, Stores can be memory based or disk based. Disk Stores also have the ability to spread hard disk usage across multiple physical disks by using multiple Store instances within a single Store Process. This gives great flexibility on a per source basis for spreading data reception and persistent data load.</p>
<p>Stores provide settings for controlling memory usage and for caching messages for retransmission in memory as well as on disk. All messages in a Store, whether in memory or on disk, have some small memory state. This is roughly about 72 bytes per message. For very large caches of messages, this can become non-trivial in size.</p>
<p><br />
 </p>
<h2><a class="anchor" id="activitytimeouts"></a>
Activity Timeouts&nbsp;&nbsp;<small><a href="#activitytimeouts">&lt;-</a></small></h2>
<p>Stores are NOT archives and are not designed for archival. Stores persist source and receiver state with the aim of providing message recovery in the event of a fault. Central to this is the concept that a source or receiver has an activity timeout attached to it. Once a source or receiver suspends operation or has a failure, it has a set time before the Store will forget about it. This activity timeout needs to be long enough to handle the recovery demands of sources and receivers. However, it can not and should not be infinite. Each source takes up memory and disk space, therefore an appropriate timeout should be chosen that meets the requirements of recovery, but is not excessively long so that the limited resources of the Store are exhausted.</p>
<p><br />
 </p>
<h2><a class="anchor" id="recommendationsforstoreconfiguration"></a>
Recommendations for Store Configuration&nbsp;&nbsp;<small><a href="#recommendationsforstoreconfiguration">&lt;-</a></small></h2>
<ul>
<li>
<p class="startli">Number of Stores in the <a class="el" href="persistenceconcepts.html#quorumconsensusstorefailover">QC group</a>. Informatica recommends a minimum of 3 Stores. A publisher defines the QC Store QC group using the LBM configuration option <a class="elRef" doxygen="/29W/Amun/home/sford/backup_exclude/labbox/sfordw_REL_6_16_1/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umestoresource">ume_store (source)</a>. This option is specified multiple times to define the desired number of Stores in the QC group.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Flight Size - Maximum number of messages sent but not stable in a quorum of Stores. The publishing application should not exceed the flight size. See <a class="el" href="operationalview.html#persistenceflightsize">Persistence Flight Size</a> for configuration details.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="elRef" doxygen="/29W/Amun/home/sford/backup_exclude/labbox/sfordw_REL_6_16_1/29West/lbm/doc/UME/design.tag:../Design/" href="../Design/umfeatures.html#offtransportrecoveryotr">Off-Transport Recovery (OTR)</a>. Informatica recommends that Stores be configured to use OTR to recover lost messages from the Source. Note that the default for <a class="elRef" doxygen="/29W/Amun/home/sford/backup_exclude/labbox/sfordw_REL_6_16_1/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpofftransportrecovery.html#useotrreceiver">use_otr (receiver)</a> is "2", which does NOT enable OTR for the Store. Informatica recommends setting "use_otr" to 1 in the Store's LBM configuration file.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="persistencefaulttolerance.html#proactiveretransmissions">Proactive Retransmissions</a>. Informatica recommends that persistent sources use proactive retransmission to ensure message stability. See <a class="elRef" doxygen="/29W/Amun/home/sford/backup_exclude/labbox/sfordw_REL_6_16_1/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpultramessagingpersistence.html#umemessagestabilitytimeoutsource">ume_message_stability_timeout (source)</a> (on by default).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="elRef" doxygen="/29W/Amun/home/sford/backup_exclude/labbox/sfordw_REL_6_16_1/29West/lbm/doc/UME/design.tag:../Design/" href="../Design/fundamentalconcepts.html#burstloss1">Burst Loss</a>. Informatica strongly recommends disabling "burst loss" by setting the LBM configuration option <a class="elRef" doxygen="/29W/Amun/home/sford/backup_exclude/labbox/sfordw_REL_6_16_1/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpdeliverycontrol.html#deliverycontrolmaximumburstlossreceiver">delivery_control_maximum_burst_loss (receiver)</a> to a very large number, perhaps 10000000. This should be done for both the Store's LBM configuration and for the subscriber's LBM configuration.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="specialconfigurationtopics.html#persistencebuffersizes">Persistence Buffer Sizes</a>. Informatica recommends performing an analysis of expected publisher data rates and worst-case data repair times to properly size the Store's retention buffer and the source's retention buffer (late join buffer). See <a class="el" href="specialconfigurationtopics.html#persistencebuffersizes">Persistence Buffer Sizes</a>.</p>
<p class="endli"></p>
</li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="storeconfigurationpracticestoavoid"></a>
Store Configuration Practices to Avoid&nbsp;&nbsp;<small><a href="#storeconfigurationpracticestoavoid">&lt;-</a></small></h2>
<p>Informatica recommends against the following Store configuration practices:</p>
<ul>
<li>
<p class="startli"><a class="elRef" doxygen="/29W/Amun/home/sford/backup_exclude/labbox/sfordw_REL_6_16_1/29West/lbm/doc/UME/design.tag:../Design/" href="../Design/fundamentalconcepts.html#burstloss1">Burst Loss</a> must be disabled in Stores and persistent receivers. Set <a class="elRef" doxygen="/29W/Amun/home/sford/backup_exclude/labbox/sfordw_REL_6_16_1/29West/lbm/doc/UME/config.tag:../Config/" href="../Config/grpdeliverycontrol.html#deliverycontrolmaximumburstlossreceiver">delivery_control_maximum_burst_loss (receiver)</a> to a very large number (1000000).</p>
<p class="endli"></p>
</li>
<li>
Multiple Store QC groups require special attention. Please <a href="https://ultramessaging.github.io/UM_Support.html">contact Informatica support</a> before using. </li>
</ul>
<p><br />
<br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
 <br />
</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
</body>
</html>
