<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Guide for Persistence: Guide for Persistence</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen_manual.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Guide for Persistence
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title"></div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<img src="infa_logo.png" width="400" height="138" alt="Informatica"/><br/><br/>
<big><b>Ultra Messaging</b></big> <small>(Version 6.12)</small><br/>
<br/><br/><br/>
<center class="mytitle">Guide for Persistence</center>
<center>Copyright (C) 2004-2019, Informatica Corporation.  All Rights Reserved.</center>
<br/><br/><br/>
[&nbsp;<a href="../index.html">Multi-page HTML</a>&nbsp;]&nbsp;&nbsp;|&nbsp;&nbsp;[&nbsp;<a href="../UM_Guide_for_Persistence=en.pdf">PDF</a>&nbsp;]
<br/><br/>
 </p>
<h1><a class="anchor" id="firstsect"></a>
Introduction&nbsp;&nbsp;<small><a href="#firstsect">&lt;-</a></small></h1>
<p>This document describes the Persistence functionality of the UMP and UMQ products.</p>
<dl class="section attention"><dt>Attention</dt><dd><b>See the <a href="../../DocIntro=en.pdf">Documentation Introduction</a> for important information on copyright, patents, information resources (including Knowledge Base, and How To articles), Marketplace, Support, and other information about Informatica and its products.</b></dd></dl>
<p>This document assumes familiarity with the <a href="../../Design/index.html">UM Concepts Guide</a>.</p>
<p>See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/design.tag:../../Design/" href="../../Design/umglossary.html">UM Glossary</a> for Ultra Messaging terminology, abbreviations, and acronyms.</p>
<p><br />
 </p>
<h1><a class="anchor" id="persistenceoverview"></a>
Persistence Overview&nbsp;&nbsp;<small><a href="#persistenceoverview">&lt;-</a></small></h1>
<p>Ultra Messaging provides two different qualities of service (QOS) levels, related to likelihood of successful message delivery: streaming and persistence.</p>
<p>Streaming is the basic QOS level for UM. With Streaming, a published message will be delivered to a receiver reliably if the following requirements are met:</p>
<ul>
<li>
the publisher and subscriber are both running, </li>
<li>
the message was published <em>after</em> the subscriber has had enough time to discover and join the publisher's data stream (note that UM's <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/design.tag:../../Design/" href="../../Design/fundamentalconcepts.html#latejoin">Late Join</a> feature which somewhat relaxes this requirement), and </li>
<li>
the data link between the publisher and subscriber has a low-enough error rate that any lost data has time to be recovered by the Transport protocol within the time allotted for that recovery. </li>
</ul>
<p>With Streaming, if a subscriber exits mid-stream (either intentionally or by failure), when that subscriber restarts, it typically cannot recover the messages that were sent during its absence.</p>
<p>The higher QOS available for UM is Persistence, by which messages can be delivered even in cases where one or more of the above requirements cannot be met. For example, if a publisher sends a message and then exits, and after that a subscriber starts, Persistence is required for that message to be delivered.</p>
<p>UM's Persistence functionality is implemented by components called "Stores" obtaining copies of published messages and writing them to non-volatile storage. These store components can be used by subscribers to recover messages that cannot be recovered by the Transport protocol. In particular:</p>
<ul>
<li>
the publishers and subscribers to not have to be running at the same time, </li>
<li>
messages published prior to the subscriber joining the transport can be can be recovered, and </li>
<li>
even extended periods of data link failure can be recovered from after the data link is restored. </li>
</ul>
<p>With Persistence, if a subscriber exits mid-stream (either intentionally or by failure), when that subscriber restarts, it will automatically recover the messages sent during its absence.</p>
<p>A system using UM Persistence comprises any number of sources, receivers, and Persistent Stores. Ultra Messaging's unique design provides Parallel Persistence, which refers to the ability of a persistent store or stores to run independently of sources and receivers and in parallel with messaging. The persistence store does not interfere with message delivery to receiving applications.</p>
<dl class="section note"><dt>Note</dt><dd>The UMS product offers streaming QOS. The UMP and UMQ products offer both streaming and persistence QOS.</dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="persistenceconcepts"></a>
Persistence Concepts&nbsp;&nbsp;<small><a href="#persistenceconcepts">&lt;-</a></small></h1>
<p>In discussing Persistence, we refer to specific recovery from the failures of sources, receivers, and persistent stores. Failed sources can restart and resume sending data from the point at which they stopped. Receivers can recover from failure and begin receiving data from the point immediately prior to failure. This process is sometimes called durable subscription. Persistent stores can also be restarted and continue providing persistence to the sources and receivers that they serve. Persistence is not designed to address ongoing, corrupting agents. Rather, if one of its components fails, the design of Persistence enables it to continue supporting its ongoing operations at some level.</p>
<p>UM offers persistence in the following two modes:</p>
<ul>
<li>
Source-paced Persistence (SPP) - default mode - the rate of message consumption by receivers does not constrain the rate a source can send. Persistent Stores write all messages to non-volatile storage, and messages are retained until they are overwritten when the allocated storage is filled. See <a class="el" href="index.html#persistencenormaloperation">Persistence Normal Operation</a>. </li>
<li>
Receiver-paced Persistence (RPP) - optional mode - the rate of message consumption by receivers <em>does</em> constrain the rate a source can send. Persistent Stores only write message to non-volatile storage if one or more necessary receiver is slow in consuming the messages, and messages are deleted from the Store once all necessary receivers have consumed the message. See <a class="el" href="index.html#rppnormaloperation">RPP Normal Operation</a>. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="persistentstoreconcept"></a>
Persistent Store Concept&nbsp;&nbsp;<small><a href="#persistentstoreconcept">&lt;-</a></small></h2>
<p>UM uses a daemon to persist source and receiver state outside the actual sources and receivers themselves. This daemon is the Persistent Store. The store can persist state in memory as well as on disk. State is persisted on a per-topic, per-source basis by the store. Persistent stores need not be a single entity. For fault tolerance purposes, it is possible to configure multiple stores in various ways.</p>
<p>For more information, see:</p>
<ul>
<li>
<a class="el" href="index.html#addingthestoretoasource">Adding the Store to a Source</a>, </li>
<li>
<a class="el" href="index.html#designingpersistentstores">Designing Persistent Stores</a>, </li>
<li>
<a class="el" href="index.html#storeconfigurationconsiderations">Store Configuration Considerations</a>, </li>
<li>
<a class="el" href="index.html#umestoredmanpage">Umestored Man Page</a>, </li>
<li>
<a class="el" href="index.html#configurationreferenceforumestored">Configuration Reference for Umestored</a>. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="registrationidentifierconcept"></a>
Registration Identifier Concept&nbsp;&nbsp;<small><a href="#registrationidentifierconcept">&lt;-</a></small></h2>
<p>UM persistence identifies sources and receivers with Registration Identifiers, also called Registration IDs or RegIDs. A RegID is a 32-bit number that uniquely identifies a source or a receiver to a store. This means that RegIDs are also specific to a store and can be reused between individual stores, if needed. No two active sources or receivers can share a RegID or use the same RegID at the same time. This point is critical: since UM enables your application to use and handle RegIDs very freely, you must use RegIDs carefully to avoid destructive results.</p>
<p>For more information, see:</p>
<ul>
<li>
<a class="el" href="index.html#addingfaultrecoverywithregistrationids">Adding Fault Recovery with Registration IDs</a> </li>
<li>
<a class="el" href="index.html#registrationidentifiers">Registration Identifiers</a> </li>
<li>
<p class="startli">RegIDs can also be managed easily with the use of Session IDs. See <a class="el" href="index.html#managingregidswithsessionids">Managing RegIDs with Session IDs</a>.</p>
<p class="endli"><br />
 </p>
</li>
</ul>
<h2><a class="anchor" id="deliveryconfirmationconcept"></a>
Delivery Confirmation Concept&nbsp;&nbsp;<small><a href="#deliveryconfirmationconcept">&lt;-</a></small></h2>
<p>A persistent receiver provides confirmation (acknowledgement) to the persistent store as it consumes (processes) messages. This is fundamental to the design of UM persistence.</p>
<p>The receiver can optionally provide this confirmation (acknowledgment) to the persistent source. These confirmations are turned off by default, but can be requested through either or both two configuration options: </p><ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeconfirmeddeliverynotificationsource">ume_confirmed_delivery_notification (source)</a> - deliver a source event to the application indicating message consumption. </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeretentionuniqueconfirmationssource">ume_retention_unique_confirmations (source)</a> - include receiver consumption as part of source flight size calculation. </li>
</ul>
<p>These two options are unrelated to each other, except that they both request the receiver to send delivery confirmations. Note that when either or both of the options are set, the persistent source <em>requests</em> that the persistent receiver supply delivery confirmations. The persistent receiver has the option to decline the request by setting the option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeallowconfirmeddeliveryreceiver">ume_allow_confirmed_delivery (receiver)</a> to 0.</p>
<dl class="section note"><dt>Note</dt><dd><a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/design.tag:../../Design/" href="../../Design/advancedoptimizations.html#smartsources">Smart Sources</a> do not support either form of delivery confirmation.</dd></dl>
<p>The latter option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeretentionuniqueconfirmationssource">ume_retention_unique_confirmations (source)</a>, can provide a form of receiver-pacing; the source will not be allowed to exceed <a class="el" href="index.html#persistenceflightsize">Persistence Flight Size</a> beyond receiving applications. For more information, see: <a class="el" href="index.html#confirmeddelivery">Confirmed Delivery</a></p>
<p><br />
 </p>
<h2><a class="anchor" id="releasepolicy"></a>
Release Policy&nbsp;&nbsp;<small><a href="#releasepolicy">&lt;-</a></small></h2>
<p>Sources and persistent stores retain data according to a release policy, which is a set of rules that specifies when a message can be reclaimed. Each rule would allow any message that complies with the rule to be reclaimed. However, a message must comply with all rules before it can be reclaimed. Conversely, any message not complying with all rules will not be reclaimed. A source or store retains messages until its retention policy dictates the message may be removed. Sources and stores use slightly different retention policies based on their individual roles.</p>
<p>For more information, see <a class="el" href="index.html#sourcemessageretentionandrelease">Source Message Retention and Release</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="messagestabilityconcept"></a>
Message Stability Concept&nbsp;&nbsp;<small><a href="#messagestabilityconcept">&lt;-</a></small></h2>
<p>Sources send messages to both receivers and to stores. Messages become stable once the message has been persisted at the store or a set of stores, and those stores acknowledge stability to the sources. Since it takes time to write messages to disk and signal stability, the source is allowed to continue sending messages while waiting for stability acknowledgements. Any messages sent but not yet acknowledged are said to be "&lt;i&gt;in flight&lt;/i&gt;". The number of in-flight messages is normally limited. For more information, see <a class="el" href="index.html#persistenceflightsize">Persistence Flight Size</a>.</p>
<p>In addition, UM informs the application when messages are stabilized. Until that stability acknowledgement is received, the source can not assume the messages will be successfully delivered. The message stability acknowledgement is vital to ensuring that messages will not be lost. For more information, see <a class="el" href="index.html#sourcemessageretentionandrelease">Source Message Retention and Release</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="quorumconsensusstorefailover"></a>
Quorum/Consensus Store Failover&nbsp;&nbsp;<small><a href="#quorumconsensusstorefailover">&lt;-</a></small></h2>
<p>Typically, multiple stores are deployed for simultaneous redundant operation. In this configuration, one or more stores (or the hosts they run on) can fail without impacting the message flow from sources to receivers, as long as a <em>quorum</em> of the configured stores is operational. UM defines a quorum as a majority of the configured stores. E.g. if 3 stores are configured, messaging can continue as long as at least 2 are operational. If 5 stores are configured, messaging can continue if at least 3 are operational. (Quorum/Consensus requires that an odd number of stores be configured.)</p>
<p><br />
 </p>
<h1><a class="anchor" id="persistencearchitecture"></a>
Persistence Architecture&nbsp;&nbsp;<small><a href="#persistencearchitecture">&lt;-</a></small></h1>
<p>As shown in the diagram, UM provides messaging functionality as well as persistent operation.</p>
<div class="image">
<img src="persistent_architecture.png" alt="persistent_architecture.png"/>
</div>
 <p>The highlights of this architecture are:</p>
<ul>
<li>
Sources communicate with stores </li>
<li>
Receivers communicate with stores </li>
<li>
Sources communicate with receivers </li>
</ul>
<p>Note that the store is not supported on all platforms. For example, while OpenVMS supports persistent clients (source and receiver), you cannot run a store on an OpenVMS system. However, an OpenVMS-based client can interoperate with a store running an any other supported platform.</p>
<p><br />
 </p>
<h2><a class="anchor" id="persistentstorearchitecture"></a>
Persistent Store Architecture&nbsp;&nbsp;<small><a href="#persistentstorearchitecture">&lt;-</a></small></h2>
<p>The umestored daemon runs the persistent store feature. You can configure multiple stores per daemon using the '<code>&lt;store&gt;</code>' element in the umestored XML configuration file. See <a class="el" href="index.html#configurationreferenceforumestored">Configuration Reference for Umestored</a>. Individual stores can use separate disk cache and disk state directories and be configured to persist messages for multiple sources (topics), which are referred to as, source repositories. UM provides each umestored daemon with a Web Monitor for statistics monitoring. See <a class="el" href="index.html#storewebmonitor">Store Web Monitor</a>.</p>
<div class="image">
<img src="store_architecture.png" alt="store_architecture.png"/>
</div>
 <p><br />
 </p>
<h3><a class="anchor" id="sourcerepositories"></a>
Source Repositories&nbsp;&nbsp;<small><a href="#sourcerepositories">&lt;-</a></small></h3>
<p>Within a store, you configure repositories for individual topics and each can have their own set of '<code>&lt;topic&gt;</code>' level options that affect the repository's type, size, liveness behavior and much more. If you have multiple sources sending on the same topic, UM creates a separate repository for each source. UM uses the repository options configured for the topic to apply to each source's repository. If you specify 48MB for the size of the repository and have 10 sources sending on the topic, the persistent store requires 480MB of storage for that topic.</p>
<p>A repository can be configured as one of the following types:</p>
<ul>
<li>
no cache - the repository does not retain any data, only state information </li>
<li>
memory - the repository maintain both state and data only in memory </li>
<li>
disk - the repository maintains state and data on disk, but also uses a memory cache. </li>
<li>
reduced-fd - the repository maintains state and data on disk, also uses a memory cache but uses significantly fewer File Descriptors. Normally a store uses two File Descriptors per topic in addition to normal UM file descriptors for transports and other objects. The reduced-fd repository type uses 5 File Descriptors for the entire store, regardless of the number of topics, in addition to normal UM file descriptors for transports and other objects. Use of this repository type may impact performance. </li>
</ul>
<p>You can configure any combination of repository types within a single store configuration.</p>
<p><br />
 </p>
<h3><a class="anchor" id="repositorythresholdsandlimits"></a>
Repository Thresholds and Limits&nbsp;&nbsp;<small><a href="#repositorythresholdsandlimits">&lt;-</a></small></h3>
<p>Repositories are designed as circular buffers. When age or size thresholds are met for a topic, the repository removes or overwrites messages in order to prevent reaching its configured limit, which keeps space available for new messages. UM provides UM configuration options and store configuration options to control threshold and limit behavior.</p>
<p>UM configuration options control source repositories for all the sources sending within the context. The default for these options, listed below, are 0 (zero) which makes the like-name option for the repository in the umestored XML configuration file active.</p>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umerepositorydiskfilesizelimitsource">ume_repository_disk_file_size_limit (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umerepositorysizelimitsource">ume_repository_size_limit (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umerepositorysizethresholdsource">ume_repository_size_threshold (source)</a> </li>
</ul>
<p>See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html">Ultra Messaging Persistence Options</a>.</p>
<p>Note: The above configuration options' default values can be altered for individual sources and receivers by calling <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/lbm_8h.html#a96ea052dce2e6376684cbf2003407cbf">lbm_src_topic_attr_setopt()</a> before you allocate the topic.</p>
<p>The umestored configuration options for source/topic repositories explained below can also be used to control threshold and limit behavior. See <a class="el" href="index.html#topicelement">Topic Element</a> for complete information about the following repository options.</p>
<dl class="section note"><dt>Note</dt><dd>Whether you use the UM configuration options mentioned above or the source repository options explained below to control source repository threshold and limit behavior, remember the values you configure apply to a single source sending to the store. If you use the default repository size limit of 48 MB and you have 1,000 sources sending to the store, UM creates a store with 1,000 source repositories of 48 MB each, which requires a store with approximately 48 GB of memory. And if you use the default disk file size limit of 100 MB and you have 1,000 sources sending to the store, UM creates a store with 1,000 source repositories of 100 MB each, which requires a store with disk storage capacity of approximately 100 GB.</dd></dl>
<p><b>Memory Repository</b></p>
<p>A memory type source repository has three configuration options that manage its size relative to its capacity.</p>
<ul>
<li>
<p class="startli"><a class="el" href="index.html#umecfgrepositoryagethreshold">repository-age-threshold</a> - This value determines how long the repository retains messages. The repository deletes any message older than this configured value.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="index.html#umecfgrepositorysizethreshold">repository-size-threshold</a> - The size in bytes that a repository can reach before it begins to delete the oldest retained messages. If the repository size falls below the threshold, it stops deleting old messages.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="index.html#umecfgrepositorysizelimit">repository-size-limit</a> - The maximum size in bytes for the repository. Once this limit is reached, the repository stops accepting new messages. The age and size thresholds should be set at levels that guarantee the size limit is never met. You should consider how fast the source sends messages, the size of the messages and the reliability of the receivers. For example, more reliable receivers mean less recovery instances, which could mean a younger age threshold.</p>
<p><b>Disk or Reduced-fd Repositories</b></p>
<p>A disk or reduced-fd type source repository maintains a memory cache in addition to the actual disk storage. It continually persists messages from the memory cache to the disk, and uses the memory cache for receiver recovery first before performing disk reads to access needed messages. It has four configuration options that manage its size relative to its capacity.</p>
<ul>
<li>
<p class="startli"><a class="el" href="index.html#umecfgrepositoryagethreshold">repository-age-threshold</a> - This value determines how long the disk repository retains messages in its memory cache. The repository deletes any message from memory cache older than this configured value. These messages could have been persisted to disk and may be available for recovery.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="index.html#umecfgrepositorysizethreshold">repository-size-threshold</a> - The size in bytes that a repository can reach before it begins to delete the oldest retained messages. These messages could have been persisted to disk and may be available for recovery. If the disk repository memory cache size falls below the threshold, it stops deleting old messages.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="index.html#umecfgrepositorysizelimit">repository-size-limit</a> - The maximum size in bytes for the disk repository's memory cache. Once this limit is reached, the repository stops accepting new messages. The age and size thresholds should be set at levels that guarantee the size limit is never met. You should consider how fast the source sends messages, the size of the messages and the reliability of the receivers. For example, more reliable receivers mean less recovery instances, which could mean a younger age threshold.</p>
<p class="endli"></p>
</li>
<li>
<a class="el" href="index.html#umecfgrepositorydiskfilesizelimit">repository-disk-file-size-limit</a> - The maximum disk space (in bytes) for the disk repository. Once this limit is reached, the repository overwrites old messages with new messages. Overwriting old messages is not necessarily a negative situation provided you disk file size is adequate. However, if messages needed for recovery are not in either the memory cache or the disk file, you may need to increase the disk file size to ensure that overwritten messages are no longer needed for receiver recovery. </li>
</ul>
<p class="endli"><br />
 </p>
</li>
</ul>
<h3><a class="anchor" id="persistentstorefault"></a>
Tolerance Persistent Store Fault Tolerance&nbsp;&nbsp;<small><a href="#persistentstorefault">&lt;-</a></small></h3>
<p>Sources and receivers register with a store and use individual repositories within the store. Sources can use redundant repositories configured in multiple stores in Quorum/Consensus arrangement for fault tolerance. Be aware that the arrangement of stores into Quorum/Consensus groups is a function of the source. I.e. the individual stores of a Quorum/Consensus group are not aware of each other and do not coordinate their activities.</p>
<p><br />
 </p>
<h3><a class="anchor" id="identifyingpersistentstores"></a>
Identifying Persistent Stores&nbsp;&nbsp;<small><a href="#identifyingpersistentstores">&lt;-</a></small></h3>
<p>You can identify stores with either a domainID:interface:port, interface:port or a name. Using only interface:port is more feasible in smaller implementations where the smaller number of possible IP addresses is easier to manage. Larger implementations, especially those that span topic resolution domains using UM Routers, are better served with stores identified by a name or domainID:interface:port.</p>
<p>UM automatically resolves and maintains a mapping between a store name and a single topic resolution domain, IP address and port. UM also automatically resolves store names if the store is located across one or more UM Routers in a different topic resolution domain.</p>
<p>The following lists other specifics of store identification.</p>
<ul>
<li>
Store sends ads at startup and in response to queries from sources. </li>
<li>
If a store receives a context name advertisement that matches its own store name, umestored issues a warning in the store's log. </li>
<li>
Sources using named stores issue an information message to the application every time a resolved context name changes its DomainID:IPaddress:port. </li>
</ul>
<p><b>Using a Single Interface and Port</b></p>
<p>Configure store for a single interface and port.</p>
<ol>
<li>
<p class="startli">Identify the store with only the interface:port, specified in umestored configuration file. </p><pre class="fragment">&lt;store name="newyork-1" port="14567" interface="10.29.3.16"&gt;
</pre><p class="endli"></p>
</li>
<li>
Add the interface:port to <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umestoresource">ume_store (source)</a> so sources can find and register with the store. <pre class="fragment">source ume_store 10.29.3.16:14567
</pre> </li>
</ol>
<p>To run the store on a different machine for any reason, you must change both the umestored XML configuration file and the UM configuration file.</p>
<p><b>Using a Range of Interfaces</b></p>
<p>Configure a store with a range of IP addresses.</p>
<ol>
<li>
<p class="startli">Identify the store with a range of interfaces specified in the umestored configuration file. </p><pre class="fragment">&lt;store name="newyork-1" port="14567" interface="10.29.3.16/25"&gt;`
</pre><p class="endli"></p>
</li>
<li>
Add the active interface to <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umestoresource">ume_store (source)</a> so sources can find and register with the store. You can only specify one interface in the configuration file. <pre class="fragment">source ume_store 10.29.3.16:14567
</pre> </li>
</ol>
<p>To run the store on a different machine, you must only change the interface specified in the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umestoresource">ume_store (source)</a> UM configuration option, provided you use one of the interfaces in the range specified in in the umestored configuration file.</p>
<p><b>Using a Store (context) Name</b></p>
<p>Configure a store with a name instead of just IP:port. '<code>0.0.0.0</code>' (<code>INADDR_ANY</code>) or no value is the default for the store's interface attribute.</p>
<ol>
<li>
<p class="startli">Identify the store with a <a class="el" href="index.html#umecfgcontextname">context-name</a> option that resolves to the interface and port - or range of interfaces and port - specified in the umestored configuration file:</p>
<pre class="fragment">&lt;store name="newyork-1" port="14567" interface="0.0.0.0"&gt;
&lt;ume-attributes&gt;
   &lt;option name="context-name" type="store" value="NEWYORK-1"/&gt;
&lt;/ume-attributes&gt;
</pre><p>OR</p>
<pre class="fragment">&lt;store name="newyork-1" port="14567" interface="10.29.3.16"&gt;
&lt;ume-attributes&gt;
   &lt;option name="context-name" type="store" value="NEWYORK-1"/&gt;
&lt;/ume-attributes&gt;
</pre><p>OR</p>
<pre class="fragment">&lt;store name="newyork-1" port="14567" interface="10.29.3.16/25"&gt;
&lt;ume-attributes&gt;
   &lt;option name="context-name" type="store" value="NEWYORK-1"/&gt;
&lt;/ume-attributes&gt;
</pre><p class="endli"></p>
</li>
<li>
<p class="startli">Add the store's context name to <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umestorenamesource">ume_store_name (source)</a> so sources can find and register with the store.</p>
<pre class="fragment">source ume_store_name NEWYORK-1
</pre> </li>
</ol>
<p>You do not have to make any configuration changes to run NEWYORK-1 on another machine, provided the new interface matches one of those specified in the umestored configuration file. This includes running the store in a different topic resolution domain.</p>
<p><br />
 </p>
<h1><a class="anchor" id="operationalview"></a>
Operational View&nbsp;&nbsp;<small><a href="#operationalview">&lt;-</a></small></h1>
<p>Sources, receivers, and stores interact in very controlled ways. This section illustrates the flow of network traffic between the components during three modes of operation and also provides a reference of persistence events.</p>
<dl class="section note"><dt>Note</dt><dd>If your application is running with the UM configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpunicastimmediatemessagingnetwork.html#requesttcpbindrequestportcontext">request_tcp_bind_request_port (context)</a> set to zero, UIM port binding (also known as "request port binding") is turned off, which also disables persistence.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="generalpersistenceoperation"></a>
General Persistence Operation&nbsp;&nbsp;<small><a href="#generalpersistenceoperation">&lt;-</a></small></h2>
<p><br />
 </p>
<h3><a class="anchor" id="sourceregistration"></a>
Source Registration&nbsp;&nbsp;<small><a href="#sourceregistration">&lt;-</a></small></h3>
<p>UM sources heavily influence the persistence registration process. Sources send out registration information to enable receivers to register with stores and also monitor store liveness. If stores become unresponsive, or if communication among sources, stores and receivers becomes impaired, the source directs re-registration.</p>
<p>The following outlines the major events in the source registration process with the store:</p>
<ol>
<li>
Source advertises topic over topic resolution transport </li>
<li>
(optional) Source queries for and resolves store name </li>
<li>
Source registers with store by unicast </li>
<li>
Source sends SRI over configured transport </li>
</ol>
<p>The following diagram illustrates network flow during the registration process.</p>
<div class="image">
<img src="source_registration.png" alt="source_registration.png"/>
</div>
 <p>Sources can find the correct store(s) to register with from the values configured for it in <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umestoresource">ume_store (source)</a> or <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umestorenamesource">ume_store_name (source)</a>. The configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umestoresource">ume_store (source)</a> contains the IP address, TCP port, registration ID, and group index for the store(s) to be used by the source. The configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umestorenamesource">ume_store_name (source)</a> contains the names of the stores to be used by the source. <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umestorenamesource">ume_store_name (source)</a> requires that the store name is configured with the <a class="el" href="index.html#umecfgcontextname">context-name</a> option in the store's XML configuration file. See <a class="el" href="index.html#identifyingpersistentstores">Identifying Persistent Stores</a> and the <a class="el" href="index.html#storeelement">Store Element</a>.</p>
<p>Sources unicast registrations to the store. The store unicasts responses back to the source. Registrations are on a per topic per source basis. Stores use RegIDs to identify sources and receivers. After registration sources may send data.</p>
<p>After the source successfully registers with all the stores for which it is configured, the source issues a Registration Complete event and sends a Source Registration Information (SRI) record over the configured UM transport session.</p>
<p>For multiple stores, the source determines when to issue a Registration Complete event based on the settings for the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeretentionintragroupstabilitybehaviorsource">ume_retention_intragroup_stability_behavior (source)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeretentionintergroupstabilitybehaviorsource">ume_retention_intergroup_stability_behavior (source)</a> options.</p>
<p>The source sends the SRI at the rate set by <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umesriintersriintervalsource">ume_sri_inter_sri_interval (source)</a> until it reaches the maximum number of SRIs set by <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umesrimaxnumberofsriperupdatesource">ume_sri_max_number_of_sri_per_update (source)</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Persistence users are advised to follow the recommendations in <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/interrelatedconfigurationoptions.html#preventingstoreregistrationhangs">Preventing Store Registration Hangs</a>.</dd></dl>
<p><br />
 </p>
<h3><a class="anchor" id="sourceregistrationinformationsri"></a>
Source Registration Information (SRI)&nbsp;&nbsp;<small><a href="#sourceregistrationinformationsri">&lt;-</a></small></h3>
<p>An SRI is a control message sent over the UM transport by a source that contains store information that a receiver needs to register with the store.</p>
<p>An SRI contains the following store information. </p><ul>
<li>
Domain ID </li>
<li>
IP address </li>
<li>
TCP port </li>
<li>
store index for all the stores with which the source registered </li>
<li>
group index for all the stores with which the source registered </li>
<li>
the source's Registration ID </li>
<li>
SRI overall version number and a separate version number for each store </li>
</ul>
<p>The SRI contains one overall version number and a separate version number for each store. If stores become unresponsive and the source must re-register when the store returns, the source increases the SRI version number and the version numbers for the stores it re-registered with. The highest SRI version number indicates the most current registration information. If a receiver gets an SRI with a higher version number than the version number it has, the receiver examines the individual store version numbers and re-registers with the those stores that have higher individual version numbers.</p>
<p><br />
 </p>
<h2><a class="anchor" id="receiverregistration"></a>
Receiver Registration&nbsp;&nbsp;<small><a href="#receiverregistration">&lt;-</a></small></h2>
<p>Receivers register with a store or stores after receiving a SRI packet from the source sending on the receiver's topic.</p>
<p>Receiver must receive an SRI before they can register with the store or stores. The following lists the major events in the receiver registration process.</p>
<ol>
<li>
Receiver resolves topic over topic resolution transport. </li>
<li>
If source is not sending SRIs, receiver sends SRI request by unicast. </li>
<li>
Receiver receives SRI over its transport. </li>
<li>
Receiver registers with store(s) by unicast. </li>
</ol>
<p>The following diagram illustrates network flow during the registration process.</p>
<div class="image">
<img src="receiver_registration.png" alt="receiver_registration.png"/>
</div>
 <p><br />
 </p>
<h3><a class="anchor" id="receiverregistrationprocess"></a>
Receiver Registration Process&nbsp;&nbsp;<small><a href="#receiverregistrationprocess">&lt;-</a></small></h3>
<p>Any receivers who have resolved their topic and joined the transport session when the source sends out SRIs can register with the store. Any receivers joining the transport session when the source is not sending SRIs can request an SRI from the source if they find that the persistence flag is set in the source's TIR during topic resolution. The source responds with a SRI record.</p>
<p>Receivers unicast registrations to the store. The store unicasts responses back to the receivers. Stores use RegIDs to identify sources and receivers. After registration, receivers may handle recovery and send acknowledgements.</p>
<p>Note: If a persistent receiver's initial registration fails, it does not become an Ultra Messaging receiver.</p>
<p><br />
 </p>
<h3><a class="anchor" id="persistencenormaloperation"></a>
Persistence Normal Operation&nbsp;&nbsp;<small><a href="#persistencenormaloperation">&lt;-</a></small></h3>
<p>The following diagram illustrates the normal operation of data reception and acknowledgement and also shows how UM attains Parallel Persistence. The source sends message data to receivers and stores in parallel.</p>
<div class="image">
<img src="ump_normal_operation.png" alt="ump_normal_operation.png"/>
</div>
 <p>During normal persistence operation:</p>
<ol>
<li>
Sources transmit data to receivers and stores at the same time over UM multicast or unicast transport protocols. </li>
<li>
As the store receives and persists messages, the store unicasts acknowledgements, (message stability control messages), to the source letting it know of successful reception and storage. </li>
<li>
As receivers process and consume messages they unicast acknowledgments to the store letting the store know of successful consumption of data. </li>
<li>
If the source desires delivery confirmation, the receiver unicasts acknowledgements directly to the source letting the source know of message consumption as well. </li>
</ol>
<p>Normal operation and recovery can proceed at the same time. In addition, as a receiver consumes retransmitted messages, the receiver sends normal acknowledgements for consumption and confirmed delivery (if requested by the source).</p>
<p><br />
 </p>
<h3><a class="anchor" id="persistenceflightsize"></a>
Persistence Flight Size&nbsp;&nbsp;<small><a href="#persistenceflightsize">&lt;-</a></small></h3>
<p>UM supports a flight size mechanism that tracks messages in flight from a persistent source and responds when a send would exceed the configured flight size (<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeflightsizesource">ume_flight_size (source)</a> and/or <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeflightsizebytessource">ume_flight_size_bytes (source)</a>). You can configure <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeflightsizebehaviorsource">ume_flight_size_behavior (source)</a> to either:</p>
<ul>
<li>
block any sends that would exceed the flight size or, </li>
<li>
allow the sends while notifying your application. </li>
</ul>
<p>UM considers a sent message in flight until the following two conditions are met:</p>
<ul>
<li>
The source receives the configured number of stability acknowledgements from the store(s). </li>
<li>
The source has received the configured number of delivery confirmation notifications. (See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeretentionuniqueconfirmationssource">ume_retention_unique_confirmations (source)</a>.) </li>
</ul>
<p>If configuring both <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeflightsizesource">ume_flight_size (source)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeflightsizebehaviorsource">ume_flight_size_behavior (source)</a>, UM uses the smaller of the two flight sizes on a per send basis.</p>
<table class="doxtable">
<tr>
<th><a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeflightsizesource">ume_flight_size (source)</a> </th><th><a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeflightsizebytessource">ume_flight_size_bytes (source)</a> </th><th>Result </th></tr>
<tr>
<td>Exceeded </td><td>Exceeded </td><td><a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeflightsizebehaviorsource">ume_flight_size_behavior (source)</a> executes </td></tr>
<tr>
<td>Exceeded </td><td>Not Exceeded </td><td><a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeflightsizebehaviorsource">ume_flight_size_behavior (source)</a> executes </td></tr>
<tr>
<td>Not Exceeded </td><td>Exceeded </td><td><a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeflightsizebehaviorsource">ume_flight_size_behavior (source)</a> executes </td></tr>
<tr>
<td>Not Exceeded </td><td>Not Exceeded </td><td>No flight size sending restriction </td></tr>
</table>
<p>When using stores in a Quorum/Consensus configuration, intragroup and intergroup stability settings affect whether UM considers a messages in flight. Consider a case with three stores in a single QC group, and two receivers. Given the default configuration, until a source receives a stability notification from two of the three stores, UM considers a given message in-flight. In addition, if you set <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeretentionuniqueconfirmationssource">ume_retention_unique_confirmations (source)</a> to 2, that same message would be considered in flight until the source receives two stability notifications AND two delivery confirmation notifications. See also <a class="el" href="index.html#sourcesusingquorumconsensusstoreconfiguration">Sources Using Quorum/Consensus Store Configuration</a>.</p>
<p><b>Blocking Message Sends That Exceed the Flight Size</b></p>
<p>By default, when a source sends a message that exceeds it's flight size, the call to send blocks. For example, suppose the flight size is set to 1. The first send completes but before the source receives a stability notification or delivery confirmation, it initiates a second call to send. If the source uses a blocking send, the send call blocks until the first message stabilizes. If the source uses a non-blocking send, the send returns an LBM_EWOULD_BLOCK.</p>
<p><b>Notification of Message Sends That Exceed the Flight Size</b></p>
<p>Alternatively, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeflightsizebehaviorsource">ume_flight_size_behavior (source)</a> can be set to notify your application when a message send surpasses the flight size. A send that exceeds the configured flight size succeeds and also triggers a flight size notification, indicating that the flight size has been surpassed. Once the number of in-flight messages falls below the configured flight size, another flight size notification source event is triggered, this time, informing the application that the number of in-flight messages is below the source's flight size.</p>
<p><br />
 </p>
<h3><a class="anchor" id="receiverrecovery"></a>
Receiver Recovery&nbsp;&nbsp;<small><a href="#receiverrecovery">&lt;-</a></small></h3>
<p>Normal loss retransmission over the UM transport operates identically in persistence as it does in streaming, according to the transport protocol. Stores do not participate in this transport-level loss retransmissions.</p>
<p>Persistent stores become involved in message recovery in circumstances where the transport protocol is not able to recover. For example, if an application exits (either intentionally or by failure) and then restarts some time later, the transport is not able to recover messages that were sent during the application's down time. When the receiver restarts and re-registers, the receiver discovers the lowest message sequence number it did not receive, and subsequently requests retransmissions of all messages not received, starting from this low sequence number.</p>
<p>For more on this process see, <a class="el" href="index.html#persistentreceiverrecovery">Persistent Receiver Recovery</a>.</p>
<p>Another circumstance in which the store becomes involved in message recovery is if the transport protocol tries but is unable to recover lost messages. In this case, Off Transport Recovery (OTR) is used. Note that OTR is available in streaming, and is serviced by the source's retention buffer. But for persistent sources, the store services OTR. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/design.tag:../../Design/" href="../../Design/umfeatures.html#offtransportrecoveryotr">Off-Transport Recovery (OTR)</a> for more information.</p>
<p>For more reliable persistence operation, Informatica recommends enabling OTR, especially when using UM Routers.</p>
<p>The following diagram illustrates receiver recovery:</p>
<div class="image">
<img src="receiver_recovery.png" alt="receiver_recovery.png"/>
</div>
 <p>Receivers unicast retransmission requests. If the store has the message, it unicasts the retransmission to the receiver. If it does not have the message and is configured to forward the request to the source, it unicasts the retransmission request to the source. If the source has the message, it unicasts the retransmission directly to the receiver. See also <a class="el" href="index.html#messagelossrecovery">Message Loss Recovery</a>.</p>
<p>UM store sends retransmissions from a thread separate from the main context thread so as not to impede live message data processing. The '<code>&lt;store&gt;</code>' configuration option, <a class="el" href="index.html#umecfgretransmissionrequestprocessingrate">retransmission-request-processing-rate</a>, sets the store's capacity to process retransmission requests. The retransmission thread processes requests off a retransmission queue which is set at 4 times the size of <a class="el" href="index.html#umecfgretransmissionrequestprocessingrate">retransmission-request-processing-rate</a>. The following UM Web Monitor statistics indicate retransmission activity (see <a class="el" href="index.html#storewebmonitor">Store Web Monitor</a>):</p>
<ul>
<li>
Retransmission requests received rate </li>
<li>
Retransmission requests served rate </li>
<li>
Retransmission requests dropped rate </li>
<li>
Total retransmission requests dropped since store startup </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="receiverpacedpersistenceoperations"></a>
Receiver-paced Persistence Operations&nbsp;&nbsp;<small><a href="#receiverpacedpersistenceoperations">&lt;-</a></small></h2>
<p>The Receiver-paced Persistence mode of operation is primarily intended to prevent message loss to critical receivers, even if loss prevention requires blocking sources from sending. To achieve this, message retention in the store is different from Source-paced persistence:</p>
<ul>
<li>
<p class="startli">In Source-paced Persistence (SPP), messages are retained in the store until the space is needed for new messages. I.e. the message repository is a circular buffer which will overwrite when it "wraps". If a slow or stopped receiver falls behind the source by more than the size of the store's repository, that receiver will experience unrecoverable loss.</p>
<p class="endli"></p>
</li>
<li>
In Receiver-paced Persistence (RPP), messages are retained only for as long as registered receivers need them to be retained in order to ensure recoverability of unacknowledged messages. When all necessary receivers have acknowledged a message, that message is removed from the store's repository. If critical receivers are unable to acknowledge messages and the repository has reached its configured capacity, the source is blocked from sending additional messages. Blocking the source prevents sending of messages that would otherwise overwrite unacknowledged messages. </li>
</ul>
<p>Source pacing is typically chosen for applications where outgoing messages are generated by external events or processes that cannot be slowed down or stopped (e.g. market data). Receiver pacing is typically chosen for applications which are able to slow down or even halt the generation of messages (e.g. a user interface which can inhibit user entry).</p>
<p>RPP is enabled with UM configuration options. No special API calls are needed.</p>
<p>RPP differentiates between two types of receivers:</p>
<ul>
<li>
Blocking: A blocking receiver will block the source if additional messages would overwrite retained messages not yet acknowledged by that receiver. </li>
<li>
Non-blocking: A non-blocking receiver will not block the source; the source will be allowed to overwrite retained messages not yet acknowledged by the non-blocking receiver. Thus a non-blocking receiver will experience unrecoverable message loss if it falls behind the source by more than the configured size of the store's repository. (Note that this is the same behavior of source-paced persistence.) </li>
</ul>
<p>Each receiver indicates its desired blocking behavior with the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umereceiverpacedpersistencereceiver">ume_receiver_paced_persistence (receiver)</a> configuration option. Both blocking and non-blocking receivers may register with the same store and subscribe to the same source.</p>
<p>Here are important points when using RPP:</p>
<ul>
<li>
<p class="startli">The repository must be configured to allow RPP, and sources and receivers must be configured to request RPP behavior during registration. Assuming the store is configured to allow RPP, the source determines the pacing behavior (receiver v.s. source) when it registers. If a receiver requests a different behavior, its registration will fail.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The store tracks the number of registered blocking and non-blocking receivers for each message sent by the source. A message is normally retained in the store repository until that number of receivers have acknowledged consumption. Once all receivers acknowledge consumption of a message, that message is removed from the repository.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Sources can modify specific repository configuration options that pertain to RPP.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Due to RPP's message retention policies, late joining RPP receivers cannot recover previously sent messages.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">With RPP, sources are required to configure their flight size in bytes, in addition to message count. (With SPP, only message count flight size is required.) The value set for the source's <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeflightsizebytessource">ume_flight_size_bytes (source)</a> configuration option is checked against a maximum allowed value specified in the store's XML configuration file.</p>
<p class="endli"></p>
</li>
<li>
With RPP, if the store's repository is full with unacknowledged messages by blocking receivers, the store will block the source by withholding stability acknowledgements, resulting in flight size blockage. See <a class="el" href="index.html#persistenceflightsize">Persistence Flight Size</a>. (With SPP, once the repository is full, it will simply start overwriting the oldest messages with new messages from the source.) </li>
</ul>
<p>In addition, a disk write delay interval for the repository, improves performance by preventing unnecessary disk activity.</p>
<p>RPP introduces the capability of a source application to set the following operational options on the store:</p>
<ul>
<li>
<a class="el" href="index.html#umecfgrepositorysizethreshold">repository-size-threshold</a> </li>
<li>
<a class="el" href="index.html#umecfgrepositorysizelimit">repository-size-limit</a> </li>
<li>
<a class="el" href="index.html#umecfgrepositorydiskfilesizelimit">repository-disk-file-size-limit</a> </li>
<li>
<a class="el" href="index.html#umecfgrepositorydiskwritedelay">repository-disk-write-delay</a> </li>
</ul>
<p>With SPP, those parameters are set only by the store's XML configuration file alone. With RPP, the source's configuration can optionally request a different value for those operating parameters, with the store's configured value being used as a maximum allowed threshold.</p>
<p><br />
 </p>
<h3><a class="anchor" id="rppregistration"></a>
RPP Registration&nbsp;&nbsp;<small><a href="#rppregistration">&lt;-</a></small></h3>
<p>A source configures its desired pacing behavior (source paced v.s. receiver paced) with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umereceiverpacedpersistencesource">ume_receiver_paced_persistence (source)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umereceiverpacedpersistencereceiver">ume_receiver_paced_persistence (receiver)</a>. If set to 1, it becomes an RPP source. Assuming the store is configured to allow RPP, when an RPP source registers with the store, the store's repository for that source becomes an RPP repository. The receiver configures its desired pacing behavior with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umereceiverpacedpersistencereceiver">ume_receiver_paced_persistence (receiver)</a>, where 0 is source-paced and 1 or 2 are receiver-paced. The receiver's pacing must match that of the source and store, otherwise the receiver's registration will fail. In addition, the choice of 1 or 2 determines the receiver's desired blocking behavior (1=blocking, 2=non-blocking).</p>
<p>Note that although the configured pacing behavior must match between source and receiver, that does not mean that the numerical setting of the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umereceiverpacedpersistencesource">ume_receiver_paced_persistence (source)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umereceiverpacedpersistencereceiver">ume_receiver_paced_persistence (receiver)</a> options must be equal. If the source is 0 (source paced), then the receiver must also be 0. However, if the source is 1 (receiver paced), then the receiver must be either 1 or 2, depending on the receiver's desired blocking behavior.</p>
<p>As with Source-paced Persistence, RPP sources send Source Registration Information (SRI) packets to RPP receivers over the configured UM transport. RPP Receivers must wait for this information before they can initiate registration requests to the store. See <a class="el" href="index.html#sourceregistration">Source Registration</a> and <a class="el" href="index.html#receiverregistration">Receiver Registration</a> for more information.</p>
<p>A source registration request includes the following:</p>
<ul>
<li>
Designation of an RPP topic </li>
<li>
Reconfigured repository configuration option values. Possible options are the 3 repository size options: <a class="el" href="index.html#umecfgrepositoryallowackonreception">repository-allow-ack-on-reception</a>, <a class="el" href="index.html#umecfgrepositorydiskwritedelay">repository-disk-write-delay</a>, and <a class="el" href="index.html#umecfgsourceflightsizebytesmaximum">source-flight-size-bytes-maximum</a>. </li>
<li>
Re-registration must request the same configuration options as were initially requested, or the store will reject the request. </li>
</ul>
<p>A receiver registration request includes its designation as a RPP receiver.</p>
<p>The repository's registration response to both a source and a receiver acknowledges RPP mode.</p>
<p><b>Late Registering Receiver</b></p>
<p>A late joining receiver that registers after the first RPP topic message has been sent cannot recover any messages sent prior to its initial registration. It is the user's responsibility to synchronize a receiver's initial registration with the start of message transmission. This restriction does not apply to an RPP receiver that initially registered at an earlier time and is now re-registering, as after a failure and restart. In that case, messages that were sent after the receiver's initial registration will be retained by the store for recovery by the receiver.</p>
<p><b>Early Exiting Receiver</b></p>
<p>Each registered receiver has associated with it an activity timeout and a state lifetime. During normal operation, the store monitors the operation of a registered receiver. If the store hears nothing from a receiver for the duration of the activity timeout, the store assumes that the receiver has halted operation. Messages will be retained by the store according to the receiver's configured blocking behavior. This gives the receiver time to restart and re-register. If an inactive receiver re-registers before the state lifetime expires, the receiver will be able to recover all messages that it missed.</p>
<p>However, if a receiver remains halted for the duration of the state lifetime, the store will delete the receiver state information. If the repository is retaining messages for this receiver, those messages will be implicitly acknowledged on behalf of the expired receiver, making them eligible for deletion if no other receivers' acknowledgements are pending. If the source is blocked waiting for this receiver, the store will unblock the source. Finally, if the halted receiver re-register after its state lifetime has expired, the store will treat it as an initial registration, and the messages it missed will not be available.</p>
<p><b>UM Version RPP Compatibility Matrix</b></p>
<p>The following table indicates the result of registration requests across UM versions:</p>
<table class="doxtable">
<tr>
<th>Version/Object </th><th>Pre-ver. 5.3 Store </th><th>Ver. 5.3 RPP Store </th><th><p class="starttd">Ver. 5.3 Non-RPP Store</p>
<p class="endtd"></p>
</th></tr>
<tr>
<td>Pre 5.3 Source </td><td>Granted </td><td>Rejected * </td><td><p class="starttd">Granted *</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>5.3 RPP Source </td><td>Granted - Source Error </td><td>Granted * </td><td><p class="starttd">Rejected *</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>5.3 Non-RPP Source </td><td>Granted </td><td>Rejected * </td><td><p class="starttd">Granted *</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Pre 5.3 Receiver </td><td>Granted </td><td>Rejected </td><td><p class="starttd">Granted</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>5.3 RPP Receiver </td><td>Granted - Receiver Error </td><td>Granted </td><td><p class="starttd">Rejected</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>5.3 Non-RPP Receiver </td><td>Granted </td><td>Rejected </td><td>Granted </td></tr>
</table>
<p>Where:</p>
<ul>
<li>
Granted - Source Error indicates that the store granted the registration but the source detected that RPP behavior was not acknowledged by the store. </li>
<li>
Granted - Receiver Error indicates that the store granted the registration but the receiver detected that RPP behavior was not acknowledged by the store. </li>
<li>
* Refers only to the re-registration of a source with an existing source repository because the source determines the repository's behavior for new registrations. </li>
</ul>
<p><br />
 </p>
<h3><a class="anchor" id="rppnormaloperation"></a>
RPP Normal Operation&nbsp;&nbsp;<small><a href="#rppnormaloperation">&lt;-</a></small></h3>
<p>At a high level, the normal sequence of operations for RPP is the same as it is for SPP:</p>
<ol>
<li>
<p class="startli">Sources transmit messages to receivers and stores at the same time over UM transports. Sources also track stability acknowledgements from the store. A source is allowed to send messages ahead of stability acknowledgements up to the configured flight size. If the flight size of unstabilized messages is reached, the source is blocked from sending more messages pending stability acknowledgements from the store.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Receivers acknowledge consumption of received messages back to stores, and optionally to the sources.</p>
<p class="endli"></p>
</li>
<li>
Stores retain messages as appropriate, send stability acknowledgements to the sources for messages, and tracks receiver consumption acknowledgements. </li>
</ol>
<p>One important way that RPP differs from SPP is in the sending of stability acknowledgements. With SPP, the store normally waits to send a stability acknowledgement until a message is "stable" on the configured storage medium, either disk or memory. With RPP, the sending of stability acknowledgements is affected by receiver consumption acknowledgements in two ways:</p>
<ul>
<li>
<p class="startli">If a message is acknowledged by all registered receivers before the message is written to disk, then there is no need to retain the message at all. The message is deleted and a stability acknowledgement is sent to the source.</p>
<p class="endli"></p>
</li>
<li>
If the repository reaches its capacity limit and there are blocking receivers which have not acknowledged the messages, the store stops sending stability acknowledgements. It is the lack of stability acknowledgements, combined with the configured flight size, which causes the source to block. (To be precise, the store stops sending stability when there is exactly one flight size worth of room available in the repository.) </li>
</ul>
<p>The following also affect stability acknowledgements:</p>
<ul>
<li>
<p class="startli">Acknowledge on Reception - If the source is configured for <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umerepositoryackonreceptionsource">ume_repository_ack_on_reception (source)</a> and the store is configured for <a class="el" href="index.html#umecfgrepositoryallowackonreception">repository-allow-ack-on-reception</a>, the store sends a stability acknowledgement to the source immediately upon reception of a message, even before any receiver acknowledgements are received, and before the message is written to disk. This setting can increase system throughput for some use cases, but also increases the risk of message loss in the event of a store failure.</p>
<div class="image">
<img src="ack_on_reception.png" alt="ack_on_reception.png"/>
</div>
 <p class="endli"></p>
</li>
<li>
Write Delay - The repository option <a class="el" href="index.html#umecfgrepositorydiskwritedelay">repository-disk-write-delay</a> allows the repository to hold messages in memory cache longer before persisting them to disk. This delay increases the probability that all RPP receivers acknowledge message consumption, eliminating the need to persist the message to disk. </li>
</ul>
<p>For memory store repositories, the options <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umerepositoryackonreceptionsource">ume_repository_ack_on_reception (source)</a> and <a class="el" href="index.html#umecfgrepositorydiskwritedelay">repository-disk-write-delay</a> have no effect.</p>
<p><br />
 </p>
<h3><a class="anchor" id="rppmessagerecovery"></a>
RPP Message Recovery&nbsp;&nbsp;<small><a href="#rppmessagerecovery">&lt;-</a></small></h3>
<p>The normal way that RPP receivers recover messages is when they re-register within the state lifetime after a failure. However, just as with SPP, there is the possibility that the transport session of the source is unable to successfully deliver all messages to the receiver. In the event of unrecoverable loss at the transport session, the Off Transport Recovery (OTR) method is also active for RPP receivers. OTR does not require the receiver to restart to recover messages from the store. See the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/design.tag:../../Design/" href="../../Design/umfeatures.html#offtransportrecoveryotr">Off-Transport Recovery (OTR)</a> for more information.</p>
<p><br />
 </p>
<h3><a class="anchor" id="rppderegistration"></a>
RPP Deregistration&nbsp;&nbsp;<small><a href="#rppderegistration">&lt;-</a></small></h3>
<p>You can deregister either sources or receivers using deregistration APIs, (<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/lbm_8h.html#a3a89366ab4e36dfa362e20397778d04a">lbm_src_ume_deregister()</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/lbm_8h.html#a861f4a170ec4caf4533669ee53fbf36f">lbm_rcv_ume_deregister()</a>, and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/lbm_8h.html#adc9f1b15ab516bed8556e7a20666770c">lbm_wrcv_ume_deregister()</a>). UM deletes the state of deregistered objects. If you deregister an RPP receiver, UM automatically decrements the number of receiver acknowledgements required to maintain RPP behavior. The store issues Deregistration Successful events for every source or receiver that deregisters. Note that after deregistering a source or receiver, the object will still exist, but is no longer participating in persistence. An attempt to send to a deregistered source will return an error. A deregistered receiver will continue to deliver messages on the topic, but since it is no longer participating in persistence, it will be unable to acknowledge those messages. If the application wants to re-join persistence, it must delete the source or receiver and re-create it, allowing it to re-register. See <a class="el" href="index.html#persistenceevents">Persistence Events</a>.</p>
<p>Users should be cautious using the deregistration APIs, especially for sources. Source deregistration will immediately delete from the store any messages from that source which might be retained due to lack of receiver acknowledgement. This deletion will render the receivers unable to recover those messages.</p>
<p><br />
 </p>
<h3><a class="anchor" id="implementingrpp"></a>
Implementing RPP&nbsp;&nbsp;<small><a href="#implementingrpp">&lt;-</a></small></h3>
<p>Follow the procedure below to configure Receiver-paced Persistence:</p>
<ol>
<li>
<p class="startli">Set <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umereceiverpacedpersistencesource">ume_receiver_paced_persistence (source)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umereceiverpacedpersistencereceiver">ume_receiver_paced_persistence (receiver)</a> in the UM configurations. If only certain sources or receivers in a context are RPP, use lbm_*setopt() in the source or receiver application or use UM XML configuration files.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Set <a class="el" href="index.html#umecfgrepositoryallowreceiverpacedpersistence">repository-allow-receiver-paced-persistence</a> = 1 for the repository in the umestored XML configuration file.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Coordinate <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeflightsizebytessource">ume_flight_size_bytes (source)</a> between the repository and the source. Set the maximum allowable flight size with the repository option, <a class="el" href="index.html#umecfgsourceflightsizebytesmaximum">source-flight-size-bytes-maximum</a>. Sources can reconfigure its flight size bytes to a value less than or equal to the maximum.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Optional: coordinate the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umerepositoryackonreceptionsource">ume_repository_ack_on_reception (source)</a> between the repository and the source. If the repository has <a class="el" href="index.html#umecfgrepositoryallowackonreception">repository-allow-ack-on-reception</a> enabled (1), the source can choose to keep it enabled or turn it off. If the repository has <a class="el" href="index.html#umecfgrepositoryallowackonreception">repository-allow-ack-on-reception</a> disabled (0), the source cannot turn it on.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Optional: if the repository is a disk repository (<a class="el" href="index.html#umecfgrepositorytype">repository-type</a> = disk or reduced-fd), set the maximum write delay with the repository option, <a class="el" href="index.html#umecfgrepositorydiskwritedelay">repository-disk-write-delay</a>. Sources can set <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umewritedelaysource">ume_write_delay (source)</a> to a value less than or equal to <a class="el" href="index.html#umecfgrepositorydiskwritedelay">repository-disk-write-delay</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Optional: coordinate repository size options between the source and repository. If you wish to use the repository's values, you do not need to configure source configuration values. The repository sets a maximum for these three options. The source can reconfigure the repository's options with values less than or equal to the maximum configured for the repository using the following UM configuration options:</p>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umerepositorysizethresholdsource">ume_repository_size_threshold (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umerepositorysizelimitsource">ume_repository_size_limit (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umerepositorydiskfilesizelimitsource">ume_repository_disk_file_size_limit (source)</a> </li>
</ul>
</li>
</ol>
<p><br />
 </p>
<h3><a class="anchor" id="examplerppconfigurationfiles"></a>
Example RPP Configuration Files&nbsp;&nbsp;<small><a href="#examplerppconfigurationfiles">&lt;-</a></small></h3>
<p>The sample configuration files shown below show how a store configuration file establishes certain RPP option values and the source can reconfigure them via a UM configuration file. Although only two files appear below, this configuration represents two, single-store quorum/consensus groups and one UM context. A second umestored configuration file would be required for the store store1rpp containing options and values identical to store0rpp.</p>
<p><b>UM Configuration File for RPP</b></p>
<p>The following example UM configuration file will work for applications which have sources and/or receivers that must be persisted using RPP. This configuration file is written assuming that the store is configured as shown in the next section.</p>
<ul>
<li>
<p class="startli">The source configures <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeflightsizebytessource">ume_flight_size_bytes (source)</a> to 1,000,000 bytes. For this to work, the repository must set <a class="el" href="index.html#umecfgsourceflightsizebytesmaximum">source-flight-size-bytes-maximum</a> to a value greater than or equal to 1,000,000.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The source uses <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umewritedelaysource">ume_write_delay (source)</a> to override the repository's <a class="el" href="index.html#umecfgrepositorydiskwritedelay">repository-disk-write-delay</a> setting to 1000 ms (1 second). Note that for this to work, the repository must set <a class="el" href="index.html#umecfgrepositorydiskwritedelay">repository-disk-write-delay</a> to a value greater than or equal to 1000 ms.</p>
<p class="endli"></p>
</li>
<li>
To remove clutter from the example, the transport type is allowed to default to TCP. Many persistence users prefer LBT-RM to more quickly and efficiently distribute messages to stores and receivers. </li>
</ul>
<pre class="fragment">##Sample UM Configuration File
# Default to TCP transport
# Multicast Resolver Network Options
context resolver_multicast_address 225.8.17.29
context resolver_multicast_interface 10.29.3.0/24

## Persistence Options ###
source ume_store_name store0rpp
source ume_store_name store1rpp
source ume_store_name store2rpp
source ume_session_id 535353
source ume_store_behavior qc
source ume_flight_size 500
# RPP-oriented configs.
#   If this app creates receivers, have them request RPP mode.
receiver ume_receiver_paced_persistence 1
#   If this app creates sources, have them request RPP mode.
source ume_receiver_paced_persistence 1
source ume_flight_size_bytes 1000000
#   The following parameters override store configurations.
source ume_repository_size_threshold 104857600
source ume_repository_size_limit 209715200
source ume_repository_disk_file_size_limit 1073741824
source ume_repository_ack_on_reception 1
source ume_write_delay 1000
</pre><p><b>umestored Configuration File</b></p>
<p>In the following example store configuration file, RPP options appear in the section for the topic pattern, ABC*. This configuration file is written assuming client applications (sources and receivers) use UM configuration files similar to that shown in the preceding section.</p>
<p>There are actually three stores configured in Q/C. The other two's configurations should differ appropriately. For example, change each instance of "store0" to "store1" and "store2" respectively.</p>
<pre class="fragment">&lt;?xml version="1.0"?&gt;
&lt;ume-store version="1.3"&gt;
  &lt;daemon&gt;
    &lt;log&gt;/configs/stores/umestore0/umestored.log&lt;/log&gt;
    &lt;pidfile&gt;/configs/stores/umestore0/umestored.pid&lt;/pidfile&gt;
    &lt;lbm-license-file&gt;/bin/umq_exp_license.txt&lt;/lbm-license-file&gt;
    &lt;lbm-config&gt;/configs/lbm_store0.cfg&lt;/lbm-config&gt;
    &lt;web-monitor&gt;*:15404&lt;/web-monitor&gt;
  &lt;/daemon&gt;
  &lt;stores&gt;
    &lt;store name="rpp-ump-test-store0" port="14667"&gt;
      &lt;ume-attributes&gt;
        &lt;option type="store" name="disk-cache-directory" value="/stores/store1/cache"/&gt;
        &lt;option type="store" name="disk-state-directory" value="/stores/store1/state"/&gt;
        &lt;option type="store" name="context-name" value="store0rpp"/&gt;
      &lt;/ume-attributes&gt;
      &lt;topics&gt;
        &lt;topic pattern="ABC.*" type="PCRE"&gt;
          &lt;ume-attributes&gt;
             &lt;option type="store" name="repository-allow-receiver-paced-persistence" value="1"/&gt;
             &lt;option type="store" name="repository-type" value="disk"/&gt;
             &lt;option type="store" name="repository-size-threshold" value="104857600"/&gt;
             &lt;option type="store" name="repository-size-limit" value="209715200"/&gt;
             &lt;option type="store" name="repository-disk-file-size-limit" value="1073741824"/&gt;
             &lt;option type="store" name="source-flight-size-bytes-maximum" value="4194304"/&gt;
             &lt;option type="store" name="repository-allow-ack-on-reception" value="1"/&gt;
             &lt;option type="store" name="repository-disk-write-delay" value="1000"/&gt;
          &lt;/ume-attributes&gt;
        &lt;/topic&gt;
      &lt;/topics&gt;
    &lt;/store&gt;
  &lt;/stores&gt;
&lt;/ume-store&gt;
</pre><p><br />
 </p>
<h3><a class="anchor" id="rppcrossfeaturefunctionality"></a>
RPP Cross Feature Functionality&nbsp;&nbsp;<small><a href="#rppcrossfeaturefunctionality">&lt;-</a></small></h3>
<table class="doxtable">
<tr>
<th>UM Feature </th><th>Supported </th><th>Notes </th></tr>
<tr>
<td>Store Proxy Sources </td><td>Yes </td></tr>
<tr>
<td>UM Router </td><td>Yes </td><td></td></tr>
<tr>
<td>UM Transports </td><td>Yes </td><td></td></tr>
<tr>
<td>Multi-Transport Threads </td><td>No </td><td>The Multi-Transport Threads does not support persistence. </td></tr>
<tr>
<td>Off-Transport Recovery </td><td>Yes </td><td></td></tr>
<tr>
<td>Late Join </td><td>No </td><td>A receiver cannot recover messages sent prior to that receiver's initial registration. </td></tr>
<tr>
<td>HF </td><td>Yes </td><td></td></tr>
<tr>
<td>HFX </td><td>Yes </td><td></td></tr>
<tr>
<td>Wildcard Receivers </td><td>Yes </td><td></td></tr>
<tr>
<td>Message Batching </td><td>Yes </td><td></td></tr>
<tr>
<td>Ordered Delivery </td><td>Yes </td><td></td></tr>
<tr>
<td>Request/Response </td><td>Yes </td><td></td></tr>
<tr>
<td>Multicast Immediate Messaging (MIM) </td><td>No </td><td>MIM messages are not persisted and have no impact on RPP. </td></tr>
<tr>
<td>Source Side Filtering </td><td>Yes </td><td></td></tr>
<tr>
<td>Self-Describing Messaging (SDM) </td><td>Yes </td><td></td></tr>
<tr>
<td>Pre-Defined Messaging (PDM) </td><td>Yes </td><td></td></tr>
<tr>
<td>UM Spectrum </td><td>Yes </td><td></td></tr>
<tr>
<td>Monitoring/Statistics </td><td>Yes </td><td></td></tr>
<tr>
<td>Acceleration - DBL </td><td>Yes </td><td></td></tr>
<tr>
<td>Acceleration - UD </td><td>Yes </td><td></td></tr>
<tr>
<td>Implicit/Explicit Acknowledgements </td><td>Yes </td><td></td></tr>
<tr>
<td>Registration ID/Session Management </td><td>Yes </td><td></td></tr>
<tr>
<td>Fault Tolerance - Quorum Consensus </td><td>Yes </td><td></td></tr>
<tr>
<td>UM SNMP Agent </td><td>Yes </td><td></td></tr>
<tr>
<td>Ultra Messaging Manager </td><td>Yes </td><td></td></tr>
<tr>
<td>Ultra Messaging Cache </td><td>Yes </td><td></td></tr>
<tr>
<td>Ultra Messaging Desktop Services </td><td>No </td><td></td></tr>
</table>
<p><br />
 </p>
<h2><a class="anchor" id="persistenceevents"></a>
Persistence Events&nbsp;&nbsp;<small><a href="#persistenceevents">&lt;-</a></small></h2>
<p>The Ultra Messaging API provides a number of events, callbacks, messages, functions, and settings. The API reference (C API, Java API or .NET API) can be used to see the true extent of the API. In order to design successful applications, though, a high level understanding of the events and callbacks is essential.</p>
<ul>
<li>
Events - Source events occur on a per source basis. </li>
<li>
Callbacks - Source and receiver application callbacks called directly from UM internal operation and usually demands a return value be filled in and/or are informational in nature. Typically, applications do very little processing in callbacks. </li>
<li>
Messages - Messages to receivers can simply contain UM information or have impact on operation. </li>
</ul>
<p>Some specific languages, such as C, Java, or C# may have specific nuances for the various events and callbacks. But, by and large, an application should plan on having access to the items listed in the following sections. For details for a particular language, consult the Ultra Messaging API documentation (C API, Java API or .NET API).</p>
<p><br />
 </p>
<h3><a class="anchor" id="persistencesourceevents"></a>
Persistence Source Events&nbsp;&nbsp;<small><a href="#persistencesourceevents">&lt;-</a></small></h3>
<p>The following events and callbacks are available for source applications:</p>
<table class="doxtable">
<tr>
<th>Event Name </th><th>Type </th><th>Description </th></tr>
<tr>
<td>Store Registration Success </td><td>Source Event </td><td><p class="starttd">Delivered once a source has successfully registered with a single store. Event contains flags to show if the source is "old" (i.e. a re-registration) as well as the sequence number that the source should use as its initial sequence number when sending, and the store information</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Store Registration Complete </td><td>Source Event </td><td><p class="starttd">Delivered once a source has completed registration with the required store(s). This indicates the source may send as it desires. Event contains the consensus sequence number.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Store Registration Error </td><td>Source Event </td><td><p class="starttd">Delivered once a source has received an error from the store indicating the requested registration was not granted. Event contains an error message to indicate what happened.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Store Message Stable </td><td>Source Event </td><td><p class="starttd">Delivered once a message is stable at a single store. Event contains the message sequence number and indicates if the message meets Intergroup and/or Intragroup stability requirements. Also includes the store information.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Store Message Not Stable </td><td>Source Event </td><td><p class="starttd">Delivered once a message's <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umemessagestabilitylifetimesource">ume_message_stability_lifetime (source)</a> has expired. The source no longer retransmits the message to the store.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Delivery Confirmation </td><td>Source Event </td><td><p class="starttd">Delivered once a message has been confirmed as delivered and processed by a receiving application. Event contains the message sequence number as well as indications whether the message has met the unique confirmations requirement. Also contains the receiver's Registration ID or Session ID.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Store Unresponsive </td><td>Source Event </td><td><p class="starttd">Delivered once a store is seen to be unresponsive due to failure or network disconnect. Event contains a message with more details suitable for logging. If a majority of a source's configured stores are unresponsive, the application will not be allowed to send messages.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Store Message Reclaimed </td><td>Source Event </td><td><p class="starttd">Delivered once a message has passed through retention and is about to be released from memory or disk. Event contains the message sequence number. (Reclaim refers to storage space reclamation.)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Store Forced Reclaim </td><td>Callback </td><td><p class="starttd">Indicates a message is being forcibly released because the memory size limit (<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grplatejoin.html#retransmitretentionsizelimitsource">retransmit_retention_size_limit (source)</a>) has been exceeded or the message's <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umemessagestabilitylifetimesource">ume_message_stability_lifetime (source)</a> has expired. Event contains the message sequence number.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Flight Size Notification </td><td>Callback </td><td><p class="starttd">Indicates that the number of in-flight messages for a source has exceeded or fallen below the configured flight size limit for a source. The event indicates if the flight size has been exceeded (OVER) by a new message send or that a message recently stabilized has reduced the number of in flight messages to less than the flight size limit (UNDER).</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>RPP Source Registration Success </td><td>Source Event </td><td><p class="starttd">Delivered once a source has successfully registered with a single store as a RPP source. The event contains either the RegID or Session ID, the sequence number of the last message stored for the source and store information.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>RPP Source Registration Failure </td><td>Source Event </td><td><p class="starttd">Delivered once a source has received an error from the store indicating the requested registration was not granted. Event contains an error message to indicate what happened.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>RPP Source Deregistration Success </td><td>Source Event </td><td><p class="starttd">Delivered once a source successfully deregisters from an individual store. The event contains either the RegID or Session ID, the sequence number of the last message stored for the source and store information.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>RPP Source Deregistration Complete </td><td>Source Event </td><td>Delivered once UM receives a successful deregistration event from all stores. </td></tr>
</table>
<p><br />
 </p>
<h3><a class="anchor" id="persistencereceiverevents"></a>
Persistence Receiver Events&nbsp;&nbsp;<small><a href="#persistencereceiverevents">&lt;-</a></small></h3>
<p>The following callbacks and messages are available for receiver applications:</p>
<table class="doxtable">
<tr>
<th>Event Name </th><th>Type </th><th><p class="starttd">Description</p>
<p class="endtd"></p>
</th></tr>
<tr>
<td>Store Registration Success </td><td>Message </td><td><p class="starttd">Delivered once a receiver has successfully registered with a single store. Message contains flags to show if the receiver is "old" (i.e. Not a new registration) as well as the sequence number that the receiver should use as its low sequence number, and the store information. In addition, the event contains the source's Registration ID or Session ID and the receiver's Registration ID or Session ID.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Store Registration Complete </td><td>Message </td><td><p class="starttd">Delivered once a receiver has completed registration with the store(s) required. This indicates the receiver may now receive data. Message contains the consensus sequence number.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>RPP Receiver Registration Success </td><td>Message </td><td><p class="starttd">Delivered once a receiver has successfully registered with a single store as a RPP receiver. Message contains either the RegID or Session ID, the sequence number of the last message stored for the source and store information.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>RPP Receiver Registration Failure </td><td>Message </td><td><p class="starttd">Delivered once a receiver has received an error from the store indicating the requested registration was not granted. Event contains an error message to indicate what happened.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>RPP Receiver Deregistration Success </td><td>Message </td><td><p class="starttd">Delivered once a receiver successfully deregisters from an individual store. The message contains either the RegID or Session ID for the receiver and the source, the sequence number of the last message stored for the source and store information.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>RPP Receiver Deregistration Complete </td><td>Message </td><td><p class="starttd">Delivered once UM receives a successful deregistration event from all stores.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Store Registration Error </td><td>Message </td><td><p class="starttd">Delivered once a receiver has received an error from the store indicating the requested registration was not granted. Message contains an error message to indicate what happened.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Store Registration Change </td><td>Message </td><td><p class="starttd">Delivered once a change in store information is received from the source. The extent of the change is included in a message suitable for logging.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Store Retransmission </td><td>Message </td><td><p class="starttd">Retransmissions from recovery come in as normal messages with a flag indicating their status as a retransmission.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Store Registration Function </td><td>Callback </td><td><p class="starttd">Called once a receiver receives store information from a source and UM desires to know the RegID to use for the receiver. Callback passes the source RegID, the store information, and the source transport name. The return value is the RegID that UM should request to use from the store.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Store Recovery Sequence Number Function </td><td>Callback </td><td>Called once registration is about to complete and the low sequence number must be determined. Callback passes the highest sequence number seen from the source and the consensus sequence number from the stores. </td></tr>
</table>
<p><br />
 </p>
<h3><a class="anchor" id="persistencecontextevents"></a>
Persistence Context Events&nbsp;&nbsp;<small><a href="#persistencecontextevents">&lt;-</a></small></h3>
<p>The following events are available for the context of source and receiver applications.</p>
<table class="doxtable">
<tr>
<td>Event Name </td><td>Type </td><td>Description </td></tr>
<tr>
<td>Flight Size Notification </td><td>Context Event </td><td>Indicates that the number of in-flight Multicast Immediate Messages has exceeded or fallen below the configured flight size limit. The event indicates if the flight size has been exceeded (OVER) by a new message send or that a message recently stabilized has reduced the number of in flight messages to less than the flight size limit (UNDER). </td></tr>
</table>
<p><br />
 </p>
<h1><a class="anchor" id="enablingpersistence"></a>
Enabling Persistence&nbsp;&nbsp;<small><a href="#enablingpersistence">&lt;-</a></small></h1>
<p>The following table lists all source files used in this section. The files can be found in the /doc/example directory. You can also access these file via the Sample Source Code tab in the left panel, under C Example Source Code.</p>
<table class="doxtable">
<tr>
<th>Filename </th><th>Content </th></tr>
<tr>
<td><a href="../../example/ume-example-src.c">ume-example-src.c</a> </td><td>Source Application </td></tr>
<tr>
<td><a href="../../example/ume-example-rcv.c">ume-example-rcv.c</a> </td><td>Receiver Application </td></tr>
<tr>
<td><a href="../../example/ume-example-src-2.c">ume-example-src-2.c</a> </td><td>Source Application 2 </td></tr>
<tr>
<td><a href="../../example/ume-example-rcv-2.c">ume-example-rcv-2.c</a> </td><td>Receiver Application 2 </td></tr>
<tr>
<td><a href="../../example/ume-example-src-3.c">ume-example-src-3.c</a> </td><td>Source Application 3 </td></tr>
<tr>
<td><a href="../../example/ume-example-rcv-3.c">ume-example-rcv-3.c</a> </td><td>Receiver Application 3 </td></tr>
<tr>
<td><a href="../../example/ume-example-config.xml">ume-example-config.xml</a> </td><td>Persistent Store Configuration File </td></tr>
</table>
<p><br />
 </p>
<h2><a class="anchor" id="startingconfiguration"></a>
Starting Configuration&nbsp;&nbsp;<small><a href="#startingconfiguration">&lt;-</a></small></h2>
<p>We begin with the minimal source and receiver used by the QuickStart Guide. To more easily demonstrate the persistence features we are interested in, we have modified the QuickStart source and receiver in the following ways.</p>
<ul>
<li>
Modified the source to send 20 messages with a one second pause between each message. </li>
<li>
Modified the receiver to anticipate 20 messages instead of just one. </li>
<li>
Assigned the topic, "UME Example", to both the source and receiver. </li>
<li>
Modified the receiver to not exit on unexpected receiver events. </li>
</ul>
<p>The last change allows us to better demonstrate basic operation and evolve our receiver slowly without having to anticipate all the options that UM provides up front.</p>
<p>Example files for our exercise are: </p><table class="doxtable">
<tr>
<th>Filename </th><th>Content </th></tr>
<tr>
<td><a href="../../example/ume-example-src.c">ume-example-src.c</a> </td><td>Source Application </td></tr>
<tr>
<td><a href="../../example/ume-example-rcv.c">ume-example-rcv.c</a> </td><td>Receiver Application </td></tr>
</table>
<p><br />
 </p>
<h2><a class="anchor" id="addingthestoretoasource"></a>
Adding the Store to a Source&nbsp;&nbsp;<small><a href="#addingthestoretoasource">&lt;-</a></small></h2>
<p>The fundamental component of a persistence solution is the persistent store. To use a store, a source needs to be configured to use one by setting <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umestoresource">ume_store (source)</a> for the source. We can do that with the following piece of code.</p>
<pre class="fragment">err = lbm_src_topic_attr_str_setopt(&amp;attr, "ume_store", "127.0.0.1:14567");
</pre><p>This sets the persistent store for the source to the store running at 127.0.0.1 on port 14567.</p>
<p>Example files for our exercise are: </p><table class="doxtable">
<tr>
<th>Filename </th><th>Content </th></tr>
<tr>
<td><a href="../../example/ume-example-src-2.c">ume-example-src-2.c</a> </td><td>Source Application 2 </td></tr>
<tr>
<td><a href="../../example/ume-example-rcv-2.c">ume-example-rcv-2.c</a> </td><td>Receiver Application 2 </td></tr>
<tr>
<td><a href="../../example/ume-example-config.xml">ume-example-config.xml</a> </td><td>Persistent Store Configuration File </td></tr>
</table>
<p>After adding the ume-store specification to the source, perform the following steps (assumes a Unix command prompt):</p>
<ol>
<li>
Create the cache and state directories. <br />
<code>$ mkdir umestored-cache ; mkdir umestored-state</code> </li>
<li>
Start up the store. <br />
<code>$ umestored ume-example-config.xml</code> </li>
<li>
Start the Receiver. <br />
<code>$ ume-example-rcv</code> </li>
<li>
Start the Source. <br />
<code>$ ume-example-src</code> </li>
</ol>
<p>You should see a message on the source that says:</p>
<pre class="fragment">INFO: Source "UME Example" Late Join not set, but UME store specified. Setting Late Join.
</pre><p>This is an informational message from UM and merely means Late Join was not set and that UM is going to set it.</p>
<p>Notice that the receiver was not configured with any store information. That is because setting it on the source is all that is needed. The receiver learns UM store settings from the source through the normal UM topic resolution process. Receivers don't need to do anything special to leverage the usage of a store by a source.</p>
<p><br />
 </p>
<h2><a class="anchor" id="addingfaultrecoverywithregistrationids"></a>
Adding Fault Recovery with Registration IDs&nbsp;&nbsp;<small><a href="#addingfaultrecoverywithregistrationids">&lt;-</a></small></h2>
<p>If the source or receiver crashes, how does the source and receiver tell the store that they have restarted and wish to resume where they left off? We need to add in some sort of identifiers to the source and receiver so that the store knows which sources and receivers they are.</p>
<p>In persistence, these identifiers are called Registration IDs or RegIDs. UM allows the application to control the use of RegIDs as it wishes. This allows applications to migrate sources and receivers not just between systems, but between locations with true, unprecedented freedom. However, UM requires an application to be careful of how it uses RegIDs. Specifically, an application must not use the same RegID for multiple sources and/or receivers at the same time.</p>
<p>Now let's look at how we can use RegIDs to provide complete fault recovery of sources and receivers. We'll first handle RegIDs in the simplest manner by using static IDs for our source and receiver. For the source, the RegID of 1000 can be added to the existing store specification by changing the string to <code>127.0.0.1:14567:1000</code></p>
<p>This yields the source code in <a href="../../example/ume-example-src-2.c">ume-example-src-2.c</a></p>
<p>For the receiver, we accomplish this in two steps.</p>
<ol>
<li>
<p class="startli">Set a callback function to be called when we desire to set the RegID to 1100. This is done by declaring a callback function which will return the RegID value 1100 to UM. The example names the callback <code>app_rcv_regid_callback()</code>.</p>
<p class="endli"></p>
</li>
<li>
Inform the UM configuration for the receiver to use this callback function. That is accomplished by setting the ume_registration_extended_function() similar to example code below. </li>
</ol>
<pre class="fragment">lbm_ume_rcv_regid_ex_func_t id;      /* structure to hold registration function information */
id.func = app_rcv_regid_callback;    /* the callback function to call */
id.clientd = NULL;                   /* the value to pass in the clientd to the function */
err = lbm_rcv_topic_attr_setopt(&amp;attr, "ume_registration_extended_function", &amp;id, sizeof(id));
</pre><p>Once this is done, the receiver has the ability to control what RegID it will use. This yields the source code in <a href="../../example/ume-example-rcv-2.c">ume-example-rcv-2.c</a>.</p>
<p>With these in place, you can experiment with killing the receiver and bringing it back (as long as you bring it back before the source is finished), as well as killing the source and bringing it back.</p>
<p>The restriction to this initial approach to RegIDs is that the RegIDs 1000 and 1100 may not be used by any other objects at the same time. If you run additional sources or receivers, they must be assigned new RegIDs, not 1000 or 1100. Let's now take a more sophisticated approach to RegIDs that will allow much more flexibility.</p>
<p><br />
 </p>
<h2><a class="anchor" id="enablingpersistencebetweenthesourceandstore"></a>
Enabling Persistence Between the Source and Store&nbsp;&nbsp;<small><a href="#enablingpersistencebetweenthesourceandstore">&lt;-</a></small></h2>
<p>Let's refine our source to include some desired behavior following a crash. Upon restart, we want our source to resume with the first unsent message. For example, if the source sent 10 messages and crashed, we want our source to resume with the 11th message and continue until it has sent the 20th message.</p>
<p>Accomplishing this graceful resumption requires us to ensure that our source is the only source that uses the RegID assigned to it. The same RegID should be used as long as the source has not sent the 20th message regardless of any crashes that may occur. The sources and receivers are primarily responsible for managing the RegIDs.</p>
<p>The following two sections explain the changes needed for the source and receiver, which become fairly easy due to the events that UM delivers to the application during persistence operation.</p>
<p><br />
 </p>
<h2><a class="anchor" id="enablingpersistenceinthesource"></a>
Enabling Persistence in the Source&nbsp;&nbsp;<small><a href="#enablingpersistenceinthesource">&lt;-</a></small></h2>
<p>With the above mentioned behaviors in mind, let's turn to looking at how they may be implemented with persistence, starting with the source. We can summarize the changes we need by the following list.</p>
<ol>
<li>
At source startup, use any saved RegID information found in the file by setting information in the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umestoresource">ume_store (source)</a> configuration variable. </li>
<li>
After the store registration is successful, if a new RegID was assigned to the source, save the RegID to the file. </li>
<li>
Set the message number to begin sending. Refer to the explanation below. </li>
<li>
Send until message number 20 has been sent. </li>
<li>
After message 20 has been sent, delete the saved RegID file. </li>
</ol>
<p>For Step 3, if the source has just been initialized, the application starts with message number 1. If the source has been restarted after a crash, the application looks to UM to establish the beginning message number because UM will use the next sequence number. For this simple example, we can make the assumption that each message is one sequence number for UM and that UM starts with sequence number 0. Thus the application can set the message number it begins resending with the value of the UM sequence number + 1. These changes yield the source code in <a href="../../example/ume-example-src-3.c">ume-example-src-3.c</a></p>
<p><br />
 </p>
<h3><a class="anchor" id="smartsourcesandpersistence"></a>
Smart Sources and Persistence&nbsp;&nbsp;<small><a href="#smartsourcesandpersistence">&lt;-</a></small></h3>
<p>When using the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/design.tag:../../Design/" href="../../Design/advancedoptimizations.html#smartsources">Smart Sources</a> feature to send persistent messages, there are a few restrictions: </p><ul>
<li>
No support for source-side delivery confirmation. Neither of the forms described in <a class="el" href="index.html#deliveryconfirmationconcept">Delivery Confirmation Concept</a> are allowed. </li>
<li>
No support for <a class="el" href="index.html#receiverlivenessdetection">Receiver Liveness Detection</a>. </li>
<li>
Application stability notification is only supported per-message. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umemessagestabilitynotificationsource">ume_message_stability_notification (source)</a>. </li>
<li>
The following configuration options have limited or no support with Smart Sources: <ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeconfirmeddeliverynotificationsource">ume_confirmed_delivery_notification (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeretentionuniqueconfirmationssource">ume_retention_unique_confirmations (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umesriflushsrirequestresponsesource">ume_sri_flush_sri_request_response (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umesrirequestresponselatencysource">ume_sri_request_response_latency (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umemessagestabilitynotificationsource">ume_message_stability_notification (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grplatejoin.html#retransmitretentionsizethresholdsource">retransmit_retention_size_threshold (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeretentionsizethresholdsource">ume_retention_size_threshold (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grplatejoin.html#retransmitretentionsizelimitsource">retransmit_retention_size_limit (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeretentionsizelimitsource">ume_retention_size_limit (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpdeprecated.html#retransmitretentionagethresholdsource">retransmit_retention_age_threshold (source)</a> </li>
</ul>
</li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="enablingpersistenceinthereceiver"></a>
Enabling Persistence in the Receiver&nbsp;&nbsp;<small><a href="#enablingpersistenceinthereceiver">&lt;-</a></small></h2>
<p>Let's also refine the receiver to resume where it left off after a crash. Just as with the source, the receiver can have the store assign it a RegID if the receiver is just beginning. Once the receiver receives the 20th message from the source, it can get rid of the RegID and exit. Because the receiver can receive some messages, crash, and come back, we should only need to look at a message and check if it is the 20th message based on the message contents or sequence number. UM provides all the events to the application that we need to create these behaviors in the receiver.</p>
<p>The receiver changes are summarized below:</p>
<ol>
<li>
<p class="startli">At receiver startup, use any saved RegID information found in the file for callback information when needed.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">When RegID callback is called: Check to see if the source RegID matches the saved source RegID. If it does, return the saved receiver RegID. RegID matches the saved source RegID if so, return the saved receiver RegID.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">After store registration is successful: If not using a previously saved RegID, then save the RegID assigned by the store to the source to a file, as well as the store information and the source RegID.</p>
<p class="endli"></p>
</li>
<li>
After the last message is received (message number 20 or UM sequence number 19), end the application and delete the saved RegID file. </li>
</ol>
<p>RegIDs in UM can be considered to be per source and per topic. Thus the receiver does not want to use the wrong RegID for a different source on the same topic. To avoid this, we save the source RegID and even store information so that the <code>app_rcv_regid_callback()</code> can make sure to use the correct RegID for the given source RegID. These changes yield the source code in <a href="../../example/ume-example-rcv-3.c">ume-example-rcv-3.c</a></p>
<p>The above sources and receivers are simplified for illustration purposes and do have some limitations. The receiver will only keep the information for one source at a time saved to the file. This is fine for illustration purposes, but would be lacking in completeness for production applications unless it was assured that a single source for any topic would be in use. To extend the receiver to include several sources is simply a matter of saving each to the file, reading them in at startup, and being able to search for the correct one for each callback invoked.</p>
<p><br />
 </p>
<h1><a class="anchor" id="demonstratingpersistence"></a>
Demonstrating Persistence&nbsp;&nbsp;<small><a href="#demonstratingpersistence">&lt;-</a></small></h1>
<p>The following files are used in this section:</p>
<table class="doxtable">
<tr>
<th>Filename </th><th>Content </th></tr>
<tr>
<td><a href="../../example/ume-example-src-3.c">ume-example-src-3.c</a> </td><td>Source Application 3 </td></tr>
<tr>
<td><a href="../../example/ume-example-rcv-3.c">ume-example-rcv-3.c</a> </td><td>Receiver Application 3 </td></tr>
<tr>
<td><a href="../../example/ume-example-config.xml">ume-example-config.xml</a> </td><td>Persistent Store Configuration File </td></tr>
</table>
<p>Perform the following tasks first:</p>
<ol>
<li>
<p class="startli">Build ume-example-rcv-3.c and ume-example-src-3.c. Instructions for building them are at the beginning of the source files.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Create default directories, umestored-cache and umestored-state in the /doc/UME directory where the other ume-example files are located. Our sample XML store configuration file, ume-example-config.xml, doesn't specify directories for the store's cache and state files, so those will be placed in the default directories.</p>
<p class="endli"></p>
</li>
<li>
Start the store. <br />
<code>$ umestored ume-example-config.xml</code> </li>
</ol>
<p>You should see no output if the store started successfully. However, you should find a new log file, ume-example-stored.log, in the directory you ran the store in. The first couple lines should look similar to below.</p>
<pre class="fragment">Fri Feb 01 07:34:28 2009 [INFO]: Latency Busters Persistent Store version 2.0
Fri Feb 01 07:34:28 2009 [INFO]: LBM 3.3 [UME-2.0] Build: Jan 31 2009, 02:10:43
( DEBUG license LBT-RM LBT-RU ) WC[PCRE 6.7 04-Jul-2006, appcb]
</pre><p>You'll also be able to view the store's web monitor. Open a web browser and go to: <code><a href="http://127.0.0.1:15304/">http://127.0.0.1:15304/</a></code></p>
<p>You should see the store's web monitor page, which is a diagnostic and monitoring tool for the UM store. See <a class="el" href="index.html#storewebmonitor">Store Web Monitor</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="runningpersistentexampleapplications"></a>
Running Persistent Example Applications&nbsp;&nbsp;<small><a href="#runningpersistentexampleapplications">&lt;-</a></small></h2>
<p>With the store running, let's try our example source and receiver applications.</p>
<ol>
<li>
Start the Receiver. <br />
<code>$ ume-example-rcv-3.exe</code> </li>
<li>
Start the Source. <br />
<code>$ ume-example-src-3.exe</code> </li>
</ol>
<p>You should see output for the source similar to the following: </p><pre class="fragment">saving RegID info to "UME-example-src-RegID" - 127.0.0.1:14567:2795623327
</pre><p>You should see output for the receiver similar to the following:</p>
<pre class="fragment">UME Store 0: 127.0.0.1:14567 [TCP:169.254.97.160:14371][2795623327] Requesting RegID: 0
saving RegID info to "UME-example-rcv-RegID" - 127.0.0.1:14567:2795623327:2795623328
Received 15 bytes on topic UME Example (sequence number 0) 'UME Message 01'
Received 15 bytes on topic UME Example (sequence number 1) 'UME Message 02'
Received 15 bytes on topic UME Example (sequence number 2) 'UME Message 03'
Received 15 bytes on topic UME Example (sequence number 3) 'UME Message 04'
...
</pre><p>The example source sends 20 messages. After the 20th messages, both the source and receiver exit and print:<code> &lt;br&gt;</code>removing saved RegID file...` <br />
So what just happened? Let's walk through the output line by line.</p>
<p><b>Source</b></p>
<pre class="fragment">saving RegID info to "UME-example-src-RegID" - 127.0.0.1:14567:2795623327
</pre><p>The source successfully registered with the store using its pre-configured store address and port of 127.0.0.1:14567. It didn't ask for a specific RegID from the store, so the store automatically assigned one to it. In this case, the store assigned the ID, 2795623327. Your source's ID will likely be different because stores assign random RegIDs.</p>
<p>If you run the test again, you'll notice the source application has written a file named '<code>UME-example-src-RegID</code>' that contains the same information the source printed on startup, namely the IP address and port of the store it registered with, along with its RegID assigned by the store.</p>
<p><b>Receiver</b></p>
<pre class="fragment">UME Store 0: 127.0.0.1:14567 [TCP:169.254.97.160:14371][2795623327] Requesting RegID: 0
saving RegID info to "UME-example-rcv-RegID" - 127.0.0.1:14567:2795623327:2795623328
</pre><p>The receiver has been informed of how to connect to the store by the source, and it also successfully registered with the store. The store's IP address and port are shown, followed by the source's unique identifier string (in this case, it's a TCP source on port 14371), and the source's RegID. The receiver then requests RegID 0 from the store, which is a special value that means pick an ID for me (Although not displayed, the source requested ID 0 when it started up as well).</p>
<p>In parallel with the source application, the receiver application writes its RegID with this store to the file, <code>UME-example-rcv-RegID</code>.</p>
<p>After sending 20 messages under normal, stable conditions, the source and receiver applications exit and remove their RegID files.</p>
<p><br />
 </p>
<h2><a class="anchor" id="singlereceiverfailsandrecovers"></a>
Single Receiver Fails and Recovers&nbsp;&nbsp;<small><a href="#singlereceiverfailsandrecovers">&lt;-</a></small></h2>
<p>Perform the following procedure with the store running to see what happens when a receiver fails and recovers:</p>
<ol>
<li>
<p class="startli">Start the Receiver. <br />
<code>$ ume-example-rcv-3.exe</code></p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Start the source. Let it run for a few seconds so the receiver gets a few messages.</p>
<pre class="fragment">$ ume-example-src-3.exe
UME Store 0: 127.0.0.1:14567 [TCP:169.254.97.160:14371][3735579353] Requesting RegID: 0
saving RegID info to "UME-example-rcv-RegID" - 127.0.0.1:14567:3735579353:3735579354
Received 15 bytes on topic UME Example (sequence number 0) 'UME Message 01'
Received 15 bytes on topic UME Example (sequence number 1) 'UME Message 02'
Received 15 bytes on topic UME Example (sequence number 2) 'UME Message 03'
</pre><p class="endli"></p>
</li>
<li>
<p class="startli">Stop the receiver (Ctrl/C) and leave the source running. Wait a few more seconds so that the source sends some messages while the receiver was down.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Restart the Receiver and let it run to completion.</p>
<pre class="fragment">$ ume-example-rcv-3.exe
read in saved RegID info from "UME-example-rcv-RegID" - 127.0.0.1:14567 RegIDs
source 3735579353, receiver 3735579354
UME Store 0: 127.0.0.1:14567 [TCP:169.254.97.160:14371][3735579353]
Requesting RegID: 3735579354
Received 15 bytes on topic UME Example (sequence number 3) 'UME Message 04'
Received 15 bytes on topic UME Example (sequence number 4) 'UME Message 05'
Received 15 bytes on topic UME Example (sequence number 5) 'UME Message 06'
Received 15 bytes on topic UME Example (sequence number 6) 'UME Message 07'
Received 15 bytes on topic UME Example (sequence number 7) 'UME Message 08'
Received 15 bytes on topic UME Example (sequence number 8) 'UME Message 09'
Received 15 bytes on topic UME Example (sequence number 9) 'UME Message 10'
Received 15 bytes on topic UME Example (sequence number 10) 'UME Message 11'
</pre><p class="endli"></p>
</li>
</ol>
<p>Notice that the receiver picked up the message stream right where it had left off - after message 3. The first few messages (which the source had sent while the receiver was down) appear to come in much faster than the source's normal rate of one per second. That's because they are being served to the receiver from the store. The remaining messages continue to come in at the normal one-per-second rate because they're being received from the source's live message stream. This is durable subscription at work.</p>
<p><br />
 </p>
<h2><a class="anchor" id="singlesourcefailsandrecovers"></a>
Single Source Fails and Recovers&nbsp;&nbsp;<small><a href="#singlesourcefailsandrecovers">&lt;-</a></small></h2>
<p>Perform the following procedure with the store running to see what happens when a source fails and recovers.</p>
<ol>
<li>
<p class="startli">Start the Receiver. <br />
<code>$ ume-example-rcv-3.exe</code></p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Start the source. <br />
<code>$ ume-example-src-3.exe</code> <br />
Let it run for a few seconds so the receiver gets a few messages.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Stop the Source (Ctrl/C).</p>
<p class="endli"></p>
</li>
<li>
Restart the Source and let it run to completion. <br />
<code>$ ume-example-rcv-3.exe</code> </li>
</ol>
<p><b>Source</b></p>
<p>You should see output similar to the following on the second run of the source:</p>
<pre class="fragment">read in saved RegID info from "UME-example-src-RegID" - 127.0.0.1:14567:2118965523
will start with message number 5
removing saved RegID file "UME-example-src-RegID"
</pre><p><b>Receiver</b></p>
<p>The receiver's output looks like the following:</p>
<pre class="fragment">UME Store 0: 127.0.0.1:14567 [TCP:169.254.97.160:14371][2118965523] Requesting RegID: 0
saving RegID info to "UME-example-rcv-RegID" - 127.0.0.1:14567:2118965523:2118965524
Received 15 bytes on topic UME Example (sequence number 0) 'UME Message 01'
Received 15 bytes on topic UME Example (sequence number 1) 'UME Message 02'
Received 15 bytes on topic UME Example (sequence number 2) 'UME Message 03'
Received 15 bytes on topic UME Example (sequence number 3) 'UME Message 04'
UME Store 0: 127.0.0.1:14567 [TCP:169.254.97.160:14371][2118965523] Requesting RegID: 2118965524
saving RegID info to "UME-example-rcv-RegID" - 127.0.0.1:14567:2118965523:2118965524
Received 15 bytes on topic UME Example (sequence number 4) 'UME Message 05'
Received 15 bytes on topic UME Example (sequence number 5) 'UME Message 06'
Received 15 bytes on topic UME Example (sequence number 6) 'UME Message 07'
Received 15 bytes on topic UME Example (sequence number 7) 'UME Message 08'
...
</pre><p>When the source was restarted, it read in its previously saved RegID and requested the same ID when registering with the store. The store informed the source that it had left off at sequence number 3 (UME Message 04), and the next sequence number it should send is 4 (UME Message 05). Bringing the source back up also caused the receiver to re-register with the store. Receivers can only find out about stores from sources they are listening to. Once the receiver re-registered with the store, it continued receiving messages from the source where it had left off.</p>
<p><br />
 </p>
<h2><a class="anchor" id="singlestorefails"></a>
Single Store Fails&nbsp;&nbsp;<small><a href="#singlestorefails">&lt;-</a></small></h2>
<p>Perform the following procedure with the store running to see what happens when the store itself fails.</p>
<ol>
<li>
<p class="startli">Start the Receiver. <br />
<code>$ ume-example-rcv-3.exe</code></p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Start the source. <br />
<code>$ ume-example-src-3.exe</code> <br />
Let it run for a few seconds so the receiver gets a few messages.</p>
<p class="endli"></p>
</li>
<li>
Stop the Store (Ctrl/C). </li>
</ol>
<p>Notice that with this simple example program, the source simply prints the following and exits.</p>
<pre class="fragment">saving RegID info to "UME-example-src-RegID" - 127.0.0.1:14567:4095035673
Store unresponsive: store 0 [127.0.0.1:14567] unresponsive
Store unresponsive: store 0 [127.0.0.1:14567] unresponsive - no registration response.
line 318: not currently registered with enough UMP stores
</pre><p>When a source application tries to send a message without being registered with a store, the send call returns an error. Messages sent while not registered with a store cannot be persisted. See <a class="el" href="index.html#designingpersistentstores">Designing Persistent Stores</a> for information about using multiple stores.</p>
<p>Your source application(s) should assume an unresponsive store is a temporary problem and wait before sending the message again. See <code>umesrc.c</code>, <code>umesrc.java</code>, or <code>umesrc.cs</code> for examples of this behavior.</p>
<p><br />
 </p>
<h1><a class="anchor" id="designingpersistenceapplications"></a>
Designing Persistence Applications&nbsp;&nbsp;<small><a href="#designingpersistenceapplications">&lt;-</a></small></h1>
<p>A persistent system is composed of sources, receivers, and stores managed by one or more applications. Sources and receivers are the endpoints of communication and the store(s) provide fault recovery and persistence of state information. Your application can leverage UM's flexible methods of persistence to add fault tolerance. With this flexibility, your applications assume new responsibilities not normally required in other persistent messaging systems. This section identifies the important considerations for your messaging applications when implementing the following persistence features:</p>
<ul>
<li>
<a class="el" href="index.html#registrationidentifiers">Registration Identifiers</a> </li>
<li>
<a class="el" href="index.html#designingpersistentsources">Designing Persistent Sources</a> </li>
<li>
<a class="el" href="index.html#designingpersistentreceivers">Designing Persistent Receivers</a> </li>
<li>
<a class="el" href="index.html#designingpersistentstores">Designing Persistent Stores</a> </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="registrationidentifiers"></a>
Registration Identifiers&nbsp;&nbsp;<small><a href="#registrationidentifiers">&lt;-</a></small></h2>
<p>As mentioned in <a class="el" href="index.html#registrationidentifierconcept">Registration Identifier Concept</a> and <a class="el" href="index.html#addingfaultrecoverywithregistrationids">Adding Fault Recovery with Registration IDs</a>, stores use RegIDs to identify sources and receivers. UM offers three main methods for managing RegIDs:</p>
<ul>
<li>
<p class="startli"><b>Recommended</b>: use Session IDs to enable the Store to both assign and manage RegIDs. See <a class="el" href="index.html#managingregidswithsessionids">Managing RegIDs with Session IDs</a>. Note: while the use of Session IDs is recommended, an understanding of the underlying registration IDs is often helpful to understanding persistence.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Your applications assign static RegIDs and ensure that the same RegID is not assigned to multiple sources and/or receivers. See <a class="el" href="index.html#usestaticregids">Use Static RegIDs</a>.</p>
<p class="endli"></p>
</li>
<li>
You can allow Stores to assign RegIDs and then save the assigned RegIDs for subsequent reuse. See <a class="el" href="index.html#saveassignedregids">Save Assigned RegIDs</a>. </li>
</ul>
<p>Your applications can manage RegIDs for the lifetime of a source or receiver as long as multiple applications do not reuse RegIDs simultaneously on the same store. RegIDs only need to be unique on the same store and may be reused between stores as desired. You can use a static mapping of RegIDs to applications or use some simple service to assign them.</p>
<p><br />
 </p>
<h3><a class="anchor" id="usestaticregids"></a>
Use Static RegIDs&nbsp;&nbsp;<small><a href="#usestaticregids">&lt;-</a></small></h3>
<p>For very small deployments, the simplest method uses static RegIDs for individual applications. This method requires every persistent source connecting to a given store have a unique RegID from every other persistent source attaching to the same store. This includes publishing applications that have multiple persistent topics; each topic's source object must have a unique RegID. (The use of session IDs greatly simplifies the management of these RegIDs.)</p>
<p>The following source code examples assign a static RegID to a source by adding the RegID, 1000, to the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umestoresource">ume_store (source)</a> attribute. See also <a href="../../example/ume-example-src-2.c">ume-example-src-2.c</a></p>
<p><b>C API</b></p>
<pre class="fragment">lbm_src_topic_attr_t * sattr;

if (lbm_src_topic_attr_create(&amp;sattr) == LBM_FAILURE) {
  fprintf(stderr, "lbm_src_topic_attr_create: %s\n", lbm_errmsg());
  exit(1);
}
if (lbm_src_topic_attr_str_setopt(sattr, "ume_store", "127.0.0.1:14567:1000")
== LBM_FAILURE) {
  fprintf(stderr, "lbm_src_topic_attr_str_setopt: %s\n", lbm_errmsg());
  exit(1);
}
</pre><p><b>JAVA API</b></p>
<pre class="fragment">LBMSourceAttributes sattr = null;
try {
  sattr = new LBMSourceAttributes();
  sattr.setValue("ume_store", "127.0.0.1:14567:1000");
}
catch (LBMException ex) {
  System.err.println("Error creating source attribute: " + ex.toString());
  System.exit(1);
}
</pre><p><b>.NET API</b></p>
<pre class="fragment">LBMSourceAttributes sattr = null;
try {
  sattr = new LBMSourceAttributes();
  sattr.setValue("ume_store", "127.0.0.1:14567:1000");
}
catch (LBMException ex) {
  System.Console.Error.WriteLine ("Error creating source attribute: " + ex.toString());
  System.Environment.Exit(1);
}
</pre><p><br />
 </p>
<h3><a class="anchor" id="saveassignedregids"></a>
Save Assigned RegIDs&nbsp;&nbsp;<small><a href="#saveassignedregids">&lt;-</a></small></h3>
<p>When using RegIDs, your application can request that the store assign it a new and unique RegID when it registers for the first time. That RegID is made available to the application, which can then save it to local storage. Thus, the next time the application starts (or restarts) and wants to use the same registration, it reads the value written to local storage. This method of managing RegIDs is not common. For example, what if the application needs to be restarted on a different server due to hardware failure? If it cannot re-register with its earlier RegID, it will not be able to recover only those messages it had not yet acknowledged. (The use of Session IDs simplifies this greatly by essentially saving the registration IDs for you on the store itself.)</p>
<p>The following minimal source code example saves the RegID assigned to a source to a file. See also <a href="../../example/ume-example-src-3.c">ume-example-src-3.c</a></p>
<p><b>C API</b></p>
<pre class="fragment">/* Callback invoked by UM for source events. */
int app_src_callback(lbm_src_t *src, int event, void *eventd, void *clientd)
{
  ...
  switch (event) {
  ...
  case LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX:
    /* Get the registration information. */
    lbm_src_event_ume_registration_ex_t *reginfo = (lbm_src_event_ume_registration_ex_t *)eventd;

    /* Might want to do the following conditionally only if we are requesting a new RegID. */
    FILE *fp = fopen("UME-example-src-RegID", "w");  /* Error checking omitted for clarity. */
    fprintf(fp, "%s:%u", reginfo-&gt;store, reginfo-&gt;registration_id);
    fclose(fp);
  ...
  }  /* switch */
  ...
}  /* app_src_callback */

...

err = lbm_src_create(&amp;src, ctx, topic, app_src_callback, ...);  /* Error checking omitted. */
</pre><p><br />
 </p>
<h3><a class="anchor" id="managingregidswithsessionids"></a>
Managing RegIDs with Session IDs&nbsp;&nbsp;<small><a href="#managingregidswithsessionids">&lt;-</a></small></h3>
<p>The RegIDs used by stores to identify sources and receivers must be unique. Rather than maintaining RegIDs (either statically or dynamically), applications can use a Session ID, which is simply a 64-bit value that uniquely identifies any set of sources with unique topics and receivers with unique topics. A single Session ID allows UM stores to correctly identify all the sources and receivers for a particular application.</p>
<p>In practice, a Session ID is often thought of as an application identifier, although it is more accurately thought of as a context identifier. (For applications that only have a single context with persistent sources and/or receivers, the two are effectively the same.) However, be aware that many application systems run multiple instances of a given program, perhaps for horizontal scaling. Each instance needs its own Session ID.</p>
<p>It is also possible for a single context to host multiple Session IDs, although this is rarely done. The UM configuration options <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umesessionidsource">ume_session_id (source)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umesessionidreceiver">ume_session_id (receiver)</a> can be used to arrange individual source and/or receiver objects into registration groupings. However, it is more common to use the option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umesessionidcontext">ume_session_id (context)</a> to group all sources and receivers created within a context into a single session ID. (If both a context and a source or receiver option is specified, the source or receiver option will override the context option.)</p>
<p><b>How Stores Associate Session IDs and RegIDs</b></p>
<p>Session IDs do not replace the use of RegIDs by UM but rather simplify RegID management. Using Session IDs equates to your application specifying a 0 (zero) RegID for all sources and receivers. However, instead of your application persisting the RegID assigned by the store, the store maintains the RegID for you.</p>
<p>When a store receives a registration request from a source or receiver with a particular Session ID, it checks to see if it already has a source or receiver for that topic/Session ID. If it does, then it responds with that source's or receiver's RegID.</p>
<p>If it does not find a source or receiver for that topic/Session ID pair, the store:</p>
<ol>
<li>
Assigns a new RegID. </li>
<li>
Associates the topic/Session ID with the new RegID. </li>
<li>
Responds to the source or receiver with the new RegID. </li>
</ol>
<p>The source can then advertise with the RegID supplied by the store. Receivers include the source's RegID in their registration request.</p>
<p>All of the above steps happen within UM itself without any intervention by the application. However, the application does have access to the underlying registration ID, if it desires it.</p>
<p><br />
 </p>
<h2><a class="anchor" id="designingpersistentsources"></a>
Designing Persistent Sources&nbsp;&nbsp;<small><a href="#designingpersistentsources">&lt;-</a></small></h2>
<p>The major concerns of sources revolve around RegID management and message retention.</p>
<p><br />
 </p>
<h3><a class="anchor" id="neworreregistration"></a>
New or Re-Registration&nbsp;&nbsp;<small><a href="#neworreregistration">&lt;-</a></small></h3>
<p>Any source needs to know at start-up if it is a new registration or a re-registration. The answer determines how a source registers with the store. The UM library can not answer this question. Therefore, it is essential that the developer consider what identifies the lifetime of a source and how a source determines the appropriate value to use as the RegID when it is ready to register. RegIDs are per source per topic per store, thus a single RegID per store is needed.</p>
<p>The following source code examples look for an existing RegID from a file and uses a new RegID assigned from the store if it finds no existing RegID. See also <a href="../../example/ume-example-src-3.c">ume-example-src-3.c</a></p>
<p><b>C API</b></p>
<pre class="fragment">    err = lbm_context_create(&amp;ctx, NULL, NULL, NULL);
    if (err) {printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);}

    srcinfo.message_num = 1;
    srcinfo.existing_regid = 0;

    err = read_src_regid_from_file(SRC_REGID_SAVE_FILENAME, store_info, sizeof(store_info));
    if (!err) { srcinfo.existing_regid = 1; }

        err = lbm_src_topic_attr_create(&amp;attr);
        if (err) {printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);}

        err = lbm_src_topic_attr_str_setopt(attr, "ume_store", store_info);
        if (err) {printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);}
</pre><p>The use of Session IDs allows UM, as opposed to your application, to accomplish the same RegID management. See <a class="el" href="index.html#managingregidswithsessionids">Managing RegIDs with Session IDs</a> Managing RegIDs with Session IDs.</p>
<p><br />
 </p>
<h3><a class="anchor" id="sourcesmustbeabletoresumesending"></a>
Sources Must Be Able to Resume Sending&nbsp;&nbsp;<small><a href="#sourcesmustbeabletoresumesending">&lt;-</a></small></h3>
<p>A source sends messages unless UM prevents it, in which case, the send function returns an error. A source may lose the ability to send messages temporarily if the store(s) in use become unresponsive, e.g. the store(s) die or become disconnected from the source. Once the store(s) are responsive again, sending can continue. Thus source applications need to take into account that sending may fail temporarily under specific failure cases and be able to resume sending when the failure is removed.</p>
<p>The following source code examples demonstrate how a failed send function can sleep for a second and try again:</p>
<p><b>C API</b></p>
<pre class="fragment">while (lbm_src_send(src, message, len, 0) == LBM_FAILURE) {
    If (lbm_errnum() == LBM_EUMENOREG) {
        printf("Send unsuccessful. Waiting...\n");
        sleep(1);
        continue;
    }
    fprintf(stderr, "lbm_src_send: %s\n", lbm_errmsg());
    exit(1);
}
</pre><p><b>Java API</b></p>
<p>for (;;) { try { src.send(message, len, 0); } catch (UMENoRegException ex) { System.out.println("Send unsuccessful. Waiting..."); try { Thread.sleep(1000); } catch (InterruptedException e) { } continue; } catch (LBMException ex) { System.err.println("Error sending message: " + ex.toString()); System.exit(1); } break; }</p>
<p><b>.NET API</b></p>
<pre class="fragment">for (;;) {
    try {
        src.send(message, len, 0);
    }
    catch (UMENoRegException ex) {
        System.Console.Out.WriteLine("Send unsuccessful. Waiting...");
        System.Threading.Thread.Sleep(1000);
        continue;
    }
    catch (LBMException ex) {
        System.Console.Out.WriteLine ("Error sending message: " + ex.toString());
        System.exit(1);
    }
    break;
}
</pre><p><br />
 </p>
<h3><a class="anchor" id="sourcemessageretentionandrelease"></a>
Source Message Retention and Release&nbsp;&nbsp;<small><a href="#sourcemessageretentionandrelease">&lt;-</a></small></h3>
<p>UM allows streaming of messages from a source without regard to message stability at a store, which is one reason for UM's performance advantage over other persistent messaging systems. Sources retain all messages until notified by the active store(s) that they are stable. This provides a method for stores to be brought up to date when restarted or started anew.</p>
<p>When messages are considered stable at the store, the source can release them which frees up source retention memory for new messages. Generally, the source releases older stable messages first. To release the oldest retained message, all the following conditions must be met:</p>
<ul>
<li>
<p class="startli">Message must meet stability requirements of the source, which can range from a single stability notice from the active store to stability notices from a group of stores (See <a class="el" href="index.html#sourcesusingquorumconsensusstoreconfiguration">Sources Using Quorum/Consensus Store Configuration</a>).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Message must have been confirmed as delivered by a configured number of receivers (<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeretentionuniqueconfirmationssource">ume_retention_unique_confirmations (source)</a>).</p>
<p class="endli"></p>
</li>
<li>
The aggregate amount of buffered messages exceeds <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grplatejoin.html#retransmitretentionsizethresholdsource">retransmit_retention_size_threshold (source)</a> bytes in payload and headers. </li>
</ul>
<p>Some things to note:</p>
<ul>
<li>
<p class="startli">If <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grplatejoin.html#retransmitretentionsizethresholdsource">retransmit_retention_size_threshold (source)</a> is not met, no messages will be released regardless of stability.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If the source registered with a "no-cache" store (See <a class="el" href="index.html#persistentstoreconcept">Persistent Store Concept</a>) or <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umemessagestabilitynotificationsource">ume_message_stability_notification (source)</a> is turned off, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeretentionuniqueconfirmationssource">ume_retention_unique_confirmations (source)</a> is the only way to allow the source to release messages before retention size options come into play.</p>
<p class="endli"></p>
</li>
<li>
With a quorum/consensus store configuration, when a quorum of stores report stability for a message, remaining stores may or may not send additional stability acks for that message. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/design.tag:../../Design/" href="../../Design/advancedoptimizations.html#smartsources">Smart Sources</a> simplify matters somewhat by pre-allocating retention buffers. They are not dynamically allocated or deallocated during operation. See <a class="el" href="index.html#smartsourcesandpersistence">Smart Sources and Persistence</a> for more information.</dd></dl>
<p><br />
 </p>
<h3><a class="anchor" id="forcedreclaims"></a>
Forced Reclaims&nbsp;&nbsp;<small><a href="#forcedreclaims">&lt;-</a></small></h3>
<p>If the aggregate amount of buffered messages exceeds <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grplatejoin.html#retransmitretentionsizelimitsource">retransmit_retention_size_limit (source)</a> bytes in payload and headers, then UM forcibly releases the oldest retained message even if it does not meet one or more of the conditions stated in Source Message Retention and Release. This condition should be avoided and Informatica suggests increasing the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grplatejoin.html#retransmitretentionsizelimitsource">retransmit_retention_size_limit (source)</a>.</p>
<p>A second condition that produces a forced reclaim is when a message remains unstabilized when the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umemessagestabilitylifetimesource">ume_message_stability_lifetime (source)</a> expires.</p>
<p>Whenever UM performs a Forced Reclaim, it notifies the application in the following ways:</p>
<ul>
<li>
<p class="startli">The source event callback's RECLAIMED_EX event (see <a class="el" href="index.html#persistencesourceevents">Persistence Source Events</a>) includes a "FORCED" flag on the event. (UM uses the same RECLAIMED_EX event, without the FORCED flag, for normal reclaims.)</p>
<p class="endli"></p>
</li>
<li>
Through the separate forced reclaim callback, if registered. You set this separate forced reclaim callback with the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeforcereclaimfunctionsource">ume_force_reclaim_function (source)</a> configuration option. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>UM retains the separate callback for backwards compatibility purposes and may be deprecated in future releases. The source event FORCED flag is the recommended method of tracking forced reclaims.</dd></dl>
<p>The following sample code, from <a href="../../example/umesrc.c">umesrc.c</a>, implements the extended reclaim source event with the 'Forced' flag set if the reclamation is a forced reclaim.</p>
<p><b>C API</b></p>
<pre class="fragment">case LBM_SRC_EVENT_UME_MESSAGE_RECLAIMED_EX:
{
    lbm_src_event_ume_ack_ex_info_t *ackinfo = (lbm_src_event_ume_ack_ex_info_t *)ed;
    if (opts-&gt;verbose) {
        printf("UME message reclaimed (ex) - sequence number %x (cd %p). Flags 0x%x ",
               ackinfo-&gt;sequence_number, (char*)(ackinfo-&gt;msg_clientd) - 1, ackinfo-&gt;flags);
        if (ackinfo-&gt;flags &amp; LBM_SRC_EVENT_UME_MESSAGE_RECLAIMED_EX_FLAG_FORCED) {
            printf("FORCED");
        }
        printf("\n");
    }
}
break;
</pre><p><b>Java API</b></p>
<pre class="fragment">case LBM.SRC_EVENT_UME_MESSAGE_RECLAIMED_EX:
    UMESourceEventAckInfo reclaiminfo = sourceEvent.ackInfo();
    if (_verbose &gt; 0) {
        if (reclaiminfo.clientObject() != null) {
            System.out.print("UME message reclaimed (ex) - sequence number "
                               + Long.toHexString(reclaiminfo.sequenceNumber())
                               + " (cd "
                               + Long.toHexString(((Long)reclaiminfo.clientObject()).longValue())
                               + "). Flags 0x"
                               + reclaiminfo.flags());
        } else {
            System.out.print("UME message reclaimed (ex) - sequence number "
                               + Long.toHexString(reclaiminfo.sequenceNumber())
                               + " Flags 0x"
                               + reclaiminfo.flags());
        }
        if ((reclaiminfo.flags() &amp; LBM.SRC_EVENT_UME_MESSAGE_RECLAIMED_EX_FLAG_FORCED) != 0) {
            System.out.print(" FORCED");
        }
        System.out.println();
    }
    break;
</pre><p><b>.NET API</b></p>
<pre class="fragment">case LBM.SRC_EVENT_UME_MESSAGE_RECLAIMED_EX:
    UMESourceEventAckInfo reclaiminfo = sourceEvent.ackInfo();
    if (_verbose &gt; 0) {
        System.Console.Out.Write("UME message reclaimed (ex) - sequence number "
                                   + reclaiminfo.sequenceNumber()
                                   + " (cd "
                                   + ((uint)reclaiminfo.clientObject()).ToString("x")
                                   + "). Flags "
                                   + reclaiminfo.flags());
        if ((reclaiminfo.flags() &amp; LBM.SRC_EVENT_UME_MESSAGE_RECLAIMED_EX_FLAG_FORCED) != 0) {
            System.Console.Out.Write(" FORCED");
        }
        System.Console.Out.WriteLine();
    }
    break;
</pre><p><br />
 </p>
<h3><a class="anchor" id="sourcereleasepolicyoptions"></a>
Source Release Policy Options&nbsp;&nbsp;<small><a href="#sourcereleasepolicyoptions">&lt;-</a></small></h3>
<p>Sources use a set of configuration options to release messages that, in effect, specify the source's release policy. The following configuration options directly impact when the source may release retained messages:</p>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umemessagestabilitynotificationsource">ume_message_stability_notification (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeretentionuniqueconfirmationssource">ume_retention_unique_confirmations (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grplatejoin.html#retransmitretentionsizethresholdsource">retransmit_retention_size_threshold (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grplatejoin.html#retransmitretentionsizelimitsource">retransmit_retention_size_limit (source)</a> </li>
</ul>
<p><br />
 </p>
<h3><a class="anchor" id="confirmeddelivery"></a>
Confirmed Delivery&nbsp;&nbsp;<small><a href="#confirmeddelivery">&lt;-</a></small></h3>
<p>The configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeretentionuniqueconfirmationssource">ume_retention_unique_confirmations (source)</a> requires a message to have a minimum number of unique confirmations from different receivers before the message may be released. This retains messages that have not been confirmed as being received and processed and keeps them available to fulfill any retransmission requests. This provides a form of receiver-pacing; the source will not be allowed to exceed <a class="el" href="index.html#persistenceflightsize">Persistence Flight Size</a> beyond receiving applications.</p>
<p>For example, a topic might have 2 receivers which are considered essential to keep up, and which should therefore contribute to flight size calculation. There might be any number of less-essential receivers which can be allowed to lag behind. In this case, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeretentionuniqueconfirmationssource">ume_retention_unique_confirmations (source)</a> would be set to 2, and the non-essential receivers would set <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeallowconfirmeddeliveryreceiver">ume_allow_confirmed_delivery (receiver)</a> to 0.</p>
<dl class="section note"><dt>Note</dt><dd><a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/design.tag:../../Design/" href="../../Design/advancedoptimizations.html#smartsources">Smart Sources</a> do not support delivery confirmation.</dd></dl>
<p>The following code samples show how to require a message to have 10 unique receiver confirmations</p>
<p><b>C API</b></p>
<pre class="fragment">lbm_src_topic_attr_t * sattr;

if (lbm_src_topic_attr_create(&amp;sattr) == LBM_FAILURE) {
    fprintf(stderr, "lbm_src_topic_attr_create: %s\n", lbm_errmsg());
    exit(1);
}
if (lbm_src_topic_attr_str_setopt(sattr, "ume_retention_unique_confirmations",
                                  "10") == LBM_FAILURE) {
    fprintf(stderr, "lbm_src_topic_attr_str_setopt: %s\n", lbm_errmsg());
    exit(1);
}
</pre><p><b>JAVA API</b></p>
<pre class="fragment">LBMSourceAttributes sattr = null;
try {
    sattr = new LBMSourceAttributes();
    sattr.setValue("ume_retention_unique_confirmations", "10");
}
catch (LBMException ex) {
    System.err.println("Error creating source attribute: " + ex.toString());
    System.exit(1);
}
</pre><p><b>.NET API</b></p>
<pre class="fragment">LBMSourceAttributes sattr = null;
try {
    sattr = new LBMSourceAttributes();
    sattr.setValue("ume_retention_unique_confirmations", "10");
}
catch (LBMException ex) {
    System.Console.Error.WriteLine ("Error creating source attribute: " + ex.toString());
    System.Environment.Exit(1);
}
</pre><p><br />
 </p>
<h3><a class="anchor" id="sourceeventhandler"></a>
Source Event Handler&nbsp;&nbsp;<small><a href="#sourceeventhandler">&lt;-</a></small></h3>
<p>The Source Event Handler is a function callback initialized at source creation to provide source events to your application related to the operation of the source. The following source code examples illustrate the use of a source event handler for registration events. To accept other source events, additional case statements would be required, one for each additional source event. See also <a class="el" href="index.html#persistenceevents">Persistence Events</a>.</p>
<p><b>C API</b></p>
<pre class="fragment">int handle_src_event(lbm_src_t *src, int event, void *ed, void *cd)
{
    switch (event) {
    case LBM_SRC_EVENT_UME_REGISTRATION_ERROR:
    {
        const char *errstr = (const char *)ed;
        printf("Error registering source with UME store: %s\n", errstr);
    }
    break;

    case LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX:
    {
        lbm_src_event_ume_registration_ex_t *reg =
            (lbm_src_event_ume_registration_ex_t *)ed;

        printf("UME store %u: %s registration success. RegID %u. Flags %x ",
               reg-&gt;store_index, reg-&gt;store, reg-&gt;registration_id, reg-&gt;flags);
        if (reg-&gt;flags &amp; LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD)
            printf("OLD[SQN %x] ", reg-&gt;sequence_number);
        if (reg-&gt;flags &amp; LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_NOACKS)
            printf("NOACKS ");
        printf("\n");
    }
    break;

    case LBM_SRC_EVENT_UME_REGISTRATION_COMPLETE_EX:
    {
        lbm_src_event_ume_registration_complete_ex_t *reg =
            (lbm_src_event_ume__complete_ex_t *)ed;
        printf("UME registration complete. SQN %x. Flags %x ",
               reg-&gt;sequence_number, reg-&gt;flags);
        if (reg-&gt;flags &amp; LBM_SRC_EVENT_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM)
            printf("QUORUM ");
        printf("\n");
    }
    break;

    case LBM_SRC_EVENT_UME_STORE_UNRESPONSIVE:
    {
        const char *infostr = (const char *)ed;
        printf("UME store: %s\n", infostr);
    }
    break;

    default:
        printf("Unknown source event %d\n", event);
        break;
    }
    return 0;
}
</pre><p><b>JAVA API</b></p>
<pre class="fragment">public int onSourceEvent(Object arg, LBMSourceEvent sourceEvent)
{
    switch (sourceEvent.type()) {
    case LBM.SRC_EVENT_UME_REGISTRATION_ERROR:
        System.out.println("Error registering source with UME store: "
            + sourceEvent.dataString());
        break;

    case LBM.SRC_EVENT_UME_REGISTRATION_SUCCESS_EX:
        UMESourceEventRegistrationSuccessInfo reg =
            sourceEvent.registrationSuccessInfo();
        System.out.print("UME store " + reg.storeIndex() + ": " + reg.store()
            + " registration success. RegID " + reg.registrationId() + ". Flags "
            + reg.flags() + " ");
        if (((reg.flags() &amp; LBM.SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD)) != 0) {
            System.out.print("OLD[SQN " + reg.sequenceNumber() + "] ");
        }
        if (((reg.flags() &amp; LBM.SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_NOACKS)) != 0) {
            System.out.print("NOACKS ");
        }
        System.out.println();
        break;

    case LBM.SRC_EVENT_UME_REGISTRATION_COMPLETE_EX:
        UMESourceEventRegistrationCompleteInfo regcomp =
            sourceEvent.registrationCompleteInfo();
        System.out.print("UME registration complete. SQN " + regcomp.sequenceNumber()
            + ". Flags " + regcomp.flags() + " ");
        if ((regcomp.flags() &amp; LBM.SRC_EVENT_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM) != 0) {
            System.out.print("QUORUM ");
        }
        System.out.println();
        break;

    case LBM.SRC_EVENT_UME_STORE_UNRESPONSIVE:
        System.out.println("UME store: " + sourceEvent.dataString());
        break;
    ...
    default:
        System.out.println("Unknown source event " + sourceEvent.type());
        break;
    }
    return 0;
}
</pre><p><b>.NET API</b></p>
<pre class="fragment">public int onSourceEvent(Object arg, LBMSourceEvent sourceEvent)
{
    switch (sourceEvent.type()) {
    case LBM.SRC_EVENT_UME_REGISTRATION_ERROR:
        System.Console.Out.WriteLine("Error registering source with UME store: "
            + sourceEvent.dataString());
        break;

    case LBM.SRC_EVENT_UME_REGISTRATION_SUCCESS_EX:
        UMESourceEventRegistrationSuccessInfo reg = sourceEvent.registrationSuccessInfo();
        System.Console.Out.Write("UME store " + reg.storeIndex() + ": " + reg.store()
            + " registration success. RegID " + reg.registrationId() + ". Flags "
            + reg.flags() + " ");
        if (((reg.flags() &amp; LBM.SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD)) != 0) {
            System.Console.Out.Write("OLD[SQN " + reg.sequenceNumber() + "] ");
        }
        if (((reg.flags() &amp; LBM.SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_NOACKS)) != 0) {
            System.Console.Out.Write("NOACKS ");
        }
        System.Console.Out.WriteLine();
        break;

    case LBM.SRC_EVENT_UME_REGISTRATION_COMPLETE_EX:
        UMESourceEventRegistrationCompleteInfo regcomp =
            sourceEvent.registrationCompleteInfo();
        System.Console.Out.Write("UME registration complete. SQN " +
            regcomp.sequenceNumber() + ". Flags " + regcomp.flags() + " ");
        if ((regcomp.flags() &amp; LBM.SRC_EVENT_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM) != 0) {
            System.Console.Out.Write("QUORUM ");
        }
        System.Console.Out.WriteLine();
        break;

    case LBM.SRC_EVENT_UME_STORE_UNRESPONSIVE:
        System.Console.Out.WriteLine("UME store: " + sourceEvent.dataString());
        break;
    ...
    default:
        System.Console.Out.WriteLine("Unknown source event " + sourceEvent.type());
        break;
    }
    return 0;
}
</pre><p><br />
 </p>
<h3><a class="anchor" id="sourceeventhandlerstabilityconfirmationandrelease"></a>
Source Event Handler - Stability, Confirmation and Release&nbsp;&nbsp;<small><a href="#sourceeventhandlerstabilityconfirmationandrelease">&lt;-</a></small></h3>
<p>As shown in Source Event Handler above, the Source Event Handler can be expanded to handle more source events by adding additional case statements. The following source code examples show case statements to handle message stability events, delivery confirmation events and message release (reclaim) events. See also <a class="el" href="index.html#persistenceevents">Persistence Events</a>.</p>
<p><b>C API</b></p>
<pre class="fragment">case LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX:
/* requires that source ume_message_stability_notification attribute is enabled */
{
    lbm_src_event_ume_ack_ex_info_t *info = (lbm_src_event_ume_ack_ex_info_t *)ed;

    printf("UME store %u: %s message stable. SQN %x (msgno %d). Flags %x ",
        info-&gt;store_index, info-&gt;store, info-&gt;sequence_number,
        (int)info-&gt;msg_clientd - 1, info-&gt;flags);
    if (info-&gt;flags &amp; LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_INTRAGROUP_STABLE)
        printf("IA "); /* Stable within store group */
    if (info-&gt;flags &amp; LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_INTERGROUP_STABLE)
        printf("IR "); /* Stable amongst all stores */
    if (info-&gt;flags &amp; LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_STABLE)
        printf("STABLE ");  /* Just plain stable */
    if (info-&gt;flags &amp; LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_STORE)
        printf("STORE ");   /* Stability reported by UME Store */
    printf("\n");
}
break;

case LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX:
/* requires that source ume_confirmed_delivery_notification attribute is enabled */
{
    lbm_src_event_ume_ack_ex_info_t *info = (lbm_src_event_ume_ack_ex_info_t *)ed;

    printf("UME delivery confirmation. SQN %x, Receiver RegID %u (msgno %d). Flags %x ",
        info-&gt;sequence_number, info-&gt;rcv_registration_id,
        (int)info-&gt;msg_clientd - 1, info-&gt;flags);
    if (info-&gt;flags &amp; LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_UNIQUEACKS)
        printf("UNIQUEACKS "); /* Satisfied number of unique ACKs requirement */
    if (info-&gt;flags &amp; LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_UREGID)
        printf("UREGID "); /* Confirmation contains receiver application registration ID */
    if (info-&gt;flags &amp; LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_OOD)
        printf("OOD "); /* Confirmation received from arrival order receiver */
    if (info-&gt;flags &amp; LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_EXACK)
        printf("EXACK "); /* Confirmation explicitly sent by receiver */
    printf("\n");
}
break;

case LBM_SRC_EVENT_UME_MESSAGE_RECLAIMED:
/* requires that source ume_confirmed_delivery_notification or ume_message_stability_notification
attributes are enabled */
{
    lbm_src_event_ume_ack_info_t *ackinfo = (lbm_src_event_ume_ack_info_t *)ed;

    printf("UME message released - sequence number %x (msgno %d)\n",
        ackinfo-&gt;sequence_number, (int)ackinfo-&gt;msg_clientd - 1);
}
break;
</pre><p><b>JAVA API</b></p>
<pre class="fragment">case LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX:
    // requires that source ume_message_stability_notification attribute is enabled
    UMESourceEventAckInfo staInfo = sourceEvent.ackInfo();
    System.out.print("UME store " + staInfo.storeIndex() + ": "
                    + staInfo.store() + " message stable. SQN " + staInfo.sequenceNumber()
                    + " (msgno " + staInfo.clientObject() + "). Flags "
                    + staInfo.flags() + " ");
    if ((staInfo.flags() &amp; LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_INTRAGROUP_STABLE) != 0) {
        System.out.print("IA "); // Stable within store group
    }
    if ((staInfo.flags() &amp; LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_INTERGROUP_STABLE) != 0) {
        System.out.print("IR ");  // Stable amongst all stores
    }
    if ((staInfo.flags() &amp; LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_STABLE) != 0) {
        System.out.print("STABLE ");  // Just plain stable
    }
    if ((staInfo.flags() &amp; LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_STORE) != 0) {
        System.out.print("STORE ");   // Stability reported by UME Store
    }
    System.out.println();
    break;

case LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX:
    // requires that source ume_confirmed_delivery_notification attribute is enabled
    UMESourceEventAckInfo cdelvinfo = sourceEvent.ackInfo();
    System.out.print("UME delivery confirmation. SQN " + cdelvinfo.sequenceNumber()
                    + ", RcvRegID " + cdelvinfo.receiverRegistrationId() + " (msgno "
                    + cdelvinfo.clientObject() + "). Flags " + cdelvinfo.flags() + " ");
    if ((cdelvinfo.flags() &amp; LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_UNIQUEACKS) != 0) {
        System.out.print("UNIQUEACKS "); // Satisfied number of unique ACKs requirement
    }
    if ((cdelvinfo.flags() &amp; LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_UREGID) != 0) {
        System.out.print("UREGID ");    // Confirmation contains receiver application reg ID
    }
    if ((cdelvinfo.flags() &amp; LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_OOD) != 0) {
        System.out.print("OOD ");      // Confirmation received from arrival order receiver
    }
    if ((cdelvinfo.flags() &amp; LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_EXACK) != 0) {
        System.out.print("EXACK ");    // Confirmation explicitly sent by receiver
    }
    System.out.println();
    break;

case LBM.SRC_EVENT_UME_MESSAGE_RECLAIMED:
    // requires that source ume_confirmed_delivery_notification or
    // ume_message_stability_notification attributes are enabled
    System.out.println("UME message released - sequence number "
                + Long.toHexString(sourceEvent.sequenceNumber())
                + " (msgno "
                + Long.toHexString(((Integer)sourceEvent.clientObject()).longValue())
                + ")");
    break;
</pre><p><b>.NET API</b></p>
<pre class="fragment">case LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX:
    // requires that source ume_message_stability_notification attribute is enabled
    UMESourceEventAckInfo staInfo = sourceEvent.ackInfo();
    System.Console.Out.Write("UME store " + staInfo.storeIndex() + ": "
                        + staInfo.store() + " message stable. SQN " + staInfo.sequenceNumber()
                        + " (msgno " + ((int)staInfo.clientObject()).ToString("x") + ").
                        Flags " + staInfo.flags() + " ");
    if ((staInfo.flags() &amp; LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_INTRAGROUP_STABLE) != 0) {
        System.Console.Out.Write("IA ");  // Stable within store group
    }
    if ((staInfo.flags() &amp; LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_INTERGROUP_STABLE) != 0) {
        System.Console.Out.Write("IR ");  // Stable amongst all stores
    }
    if ((staInfo.flags() &amp; LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_STABLE) != 0) {
        System.Console.Out.Write("STABLE ");  // Just plain stable
    }
    if ((staInfo.flags() &amp; LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_STORE) != 0) {
        System.Console.Out.Write("STORE ");  // Stability reported by UME Store
    }
    System.Console.Out.WriteLine();
    break;

case LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX:
    // requires that source ume_confirmed_delivery_notification attribute is enabled

    UMESourceEventAckInfo cdelvinfo = sourceEvent.ackInfo();

    System.Console.Out.Write("UME delivery confirmation. SQN " +
    cdelvinfo.sequenceNumber()
                        + ", RcvRegID " + cdelvinfo.receiverRegistrationId() + " (msgno "
                        + ((int)cdelvinfo.clientObject()).ToString("x") + "). Flags " +
                        cdelvinfo.flags() + " ");
    if ((cdelvinfo.flags() &amp; LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_UNIQUEACKS) != 0) {
        System.Console.Out.Write("UNIQUEACKS ");  // Satisfied number of unique ACKs requirement
    }
    if ((cdelvinfo.flags() &amp; LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_UREGID) != 0) {
        System.Console.Out.Write("UREGID ");  // Confirmation contains receiver application reg ID
    }
    if ((cdelvinfo.flags() &amp; LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_OOD) != 0) {
        System.Console.Out.Write("OOD ");  // Confirmation received from arrival order receiver
    }
    if ((cdelvinfo.flags() &amp; LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_EXACK) != 0) {
        System.Console.Out.Write("EXACK ");  // Confirmation explicitly sent by receiver
    }
    System.Console.Out.WriteLine();
    break;

case LBM.SRC_EVENT_UME_MESSAGE_RECLAIMED:
    // requires that source ume_confirmed_delivery_notification or
    // ume_message_stability_notification attributes are enabled

    System.Console.Out.WriteLine("UME message released - sequence number "
                               + sourceEvent.sequenceNumber().ToString("x")
                               + " (msgno "
                               + ((int)sourceEvent.clientObject()).ToString("x")
                               + ")");
    break;
</pre><p><br />
 </p>
<h3><a class="anchor" id="mappingyourmessagenumberstosequencenumbers"></a>
Mapping Your Message Numbers to Sequence Numbers&nbsp;&nbsp;<small><a href="#mappingyourmessagenumberstosequencenumbers">&lt;-</a></small></h3>
<p>The C API function <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/lbm_8h.html#a4d883eaaa22baf81abf21d495f471c8b">lbm_src_sendv_ex()</a> allows you to create a pointer to an object or structure. This pointer will be returned to your application along with all source events. You can then update the object or structure with source event information. For example, if your messages exceed 8K - which requires fragmentation your application's message into more than one UM message - receiving sequence number events with this pointer allows you to determine all the UM sequence numbers for the message and, therefore, how many release (reclaim) events to expect. The following two source code examples show how to:</p>
<ul>
<li>
Enable message sequence number information. </li>
<li>
Handle sequence number source events to determine the application message number in the Source Event Handler. </li>
</ul>
<p><b>C API - Enable Message Information</b></p>
<pre class="fragment">lbm_src_send_ex_info_t exinfo;

/* Enable message sequence number info to be returned */
exinfo.flags = LBM_SRC_SEND_EX_FLAG_UME_CLIENTD | LBM_SRC_SEND_EX_FLAG_SEQUENCE_NUMBER_INFO;
exinfo.ume_msg_clientd = (void *)(msgno + 1);
/* msgno set to application message number (can't evaluate to NULL) */
while (lbm_src_send_ex(src, message, msglen, 0, &amp;exinfo) == LBM_FAILURE) {
    if (lbm_errnum() == LBM_EUMENOREG) {
        printf("Send unsuccessful. Waiting...\n");
                SLEEP_MSEC(1000);    /* Sleep for 1 second */
    }
    else {
         fprintf(stderr, "lbm_src_send: %s\n", lbm_errmsg());
        break;
    }
}
</pre><p><b>C API - Sequence Number Event Handler</b></p>
<pre class="fragment">int handle_src_event(lbm_src_t *src, int event, void *ed, void *cd)
{
    switch (event) {
    case LBM_SRC_EVENT_SEQUENCE_NUMBER_INFO:
        {
            lbm_src_event_sequence_number_info_t *info =
                (lbm_src_event_sequence_number_info_t *)ed;

            if (info-&gt;first_sequence_number != info-&gt;last_sequence_number) {
                printf("SQN [%x,%x] (msgno %d)\n", info-&gt;first_sequence_number,
                        info-&gt;last_sequence_number, (int)info-&gt;msg_clientd - 1);
            }
            else {
                printf("SQN %x (msgno %d)\n", info-&gt;last_sequence_number,
                        (int)info-&gt;msg_clientd - 1);
            }
        }
        break;
    ...
    }
    return 0;
}
</pre><p><b>JAVA API - Enable Message Information</b></p>
<pre class="fragment">LBMSourceSendExInfo exinfo = new LBMSourceSendExInfo();
exinfo.setClientObject(new Integer(msgno));  // msgno set to application message number
exinfo.setFlags(LBM.SRC_SEND_EX_FLAG_SEQUENCE_NUMBER_INFO);
// Enable message sequence number info to be returned
for (;;)
{
    try {
        src.send(message, msglen, 0, exinfo);
    }
    catch(UMENoRegException ex) {
        try {
            Thread.sleep(1000);
        }
        catch (InterruptedException e) { }
        continue;
    }
    catch (LBMException ex) {
        System.err.println("Error sending message: " + ex.toString());
    }
    break;
}
</pre><p><b>JAVA API - Sequence Number Event Handler</b></p>
<pre class="fragment">public int onSourceEvent(Object arg, LBMSourceEvent sourceEvent)
{
    switch (sourceEvent.type())
    {
    case LBM.SRC_EVENT_SEQUENCE_NUMBER_INFO:
        LBMSourceEventSequenceNumberInfo info = sourceEvent.sequenceNumberInfo();
        if (info.firstSequenceNumber() != info.lastSequenceNumber()) {
            System.out.println("SQN [" + info.firstSequenceNumber()
                            + "," + info.lastSequenceNumber() + "] (msgno "
                            + info.clientObject() + ")");
        }
        else {
            System.out.println("SQN " + info.lastSequenceNumber()
                            + " (msgno " + info.clientObject() + ")");
        }
        break;
    ...
    }
    return 0;
}
</pre><p><b>.NET API - Enable Message Information</b></p>
<pre class="fragment">LBMSourceSendExInfo exinfo = new LBMSourceSendExInfo();
exinfo.setClientObject(msgno);  // msgno set to application message number
exinfo.setFlags(LBM.SRC_SEND_EX_FLAG_SEQUENCE_NUMBER_INFO);
// Enable message sequence number info to be returned
for (;;)
{
    try {
        src.send(message, msglen, 0, exinfo);
    }
    catch(UMENoRegException ex) {
        System.Threading.Thread.Sleep(100);
        continue;
    }
    catch (LBMException ex) {
        System.Console.Out.WriteLine("Error sending message: " + ex.Message());
    }
    break;
}
</pre><p><b>.NET API - Sequence Number Event Handler</b></p>
<pre class="fragment">public void onSourceEvent(Object arg, LBMSourceEvent sourceEvent)
{
    switch (sourceEvent.type())
    {
    case LBM.SRC_EVENT_SEQUENCE_NUMBER_INFO:
        LBMSourceEventSequenceNumberInfo info = sourceEvent.sequenceNumberInfo();
        if (info.firstSequenceNumber() != info.lastSequenceNumber()) {
            System.Console.Out.WriteLine("SQN [" + info.firstSequenceNumber()
                              + "," + info.lastSequenceNumber() + "] (cd "
                              + ((int)info.clientObject()).ToString("x") + ")");
        }
        else {
            System.Console.Out.WriteLine("SQN " + info.lastSequenceNumber()
                + " (msgno " + ((int)info.clientObject()).ToString("x") + ")");
        }
        break;
    ...

    }
    return 0;
}
</pre><p><br />
 </p>
<h3><a class="anchor" id="receiverlivenessdetection"></a>
Receiver Liveness Detection&nbsp;&nbsp;<small><a href="#receiverlivenessdetection">&lt;-</a></small></h3>
<p>As an extension to Confirmed Delivery, you can set receivers to send a keepalive to a source during a measured absence of delivery confirmations (due to traffic lapse). In the event that neither message reaches the source within a designated interval, or if the delivery confirmation TCP connection breaks down, the receiver is assumed to have "died". UM then notifies the publishing application via context event callback. This lets the publisher assign a new subscriber.</p>
<p>To use this feature, set these five configuration options: </p><ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umesourcelivenesstimeoutcontext">ume_source_liveness_timeout (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umereceiverlivenessintervalcontext">ume_receiver_liveness_interval (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeconfirmeddeliverynotificationsource">ume_confirmed_delivery_notification (source)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeuserreceiverregistrationidcontext">ume_user_receiver_registration_id (context)</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umesessionidcontext">ume_session_id (context)</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umesessionidsource">ume_session_id (source)</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umesessionidreceiver">ume_session_id (receiver)</a> </li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/design.tag:../../Design/" href="../../Design/advancedoptimizations.html#smartsources">Smart Sources</a> do not support liveness detection.</dd></dl>
<p>This specialized feature is not recommended for general use. If you are considering it, please note the following caveats: </p><ul>
<li>
Do not use in conjunction with a UM Router. </li>
<li>
There is a variety of potential network occurrences that can break or reset the TCP connection and falsely indicate the death of a receiver. </li>
<li>
In cases where a receiver object is deleted while its context is not, the publisher may still falsely assume the receiver to be alive. </li>
</ul>
<p>Other false receiver-alive assumptions could be caused by the following: </p><ul>
<li>
TCP connections can enter a half-open or otherwise corrupted state. </li>
<li>
Failed TCP connections sometimes do not fully close, or experience objectionable delays before fully closing. </li>
<li>
A switch or router failure along the path does not affect the TCP connection state. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="designingpersistentreceivers"></a>
Designing Persistent Receivers&nbsp;&nbsp;<small><a href="#designingpersistentreceivers">&lt;-</a></small></h2>
<p>Receivers are predominantly interested in RegID management and recovery management.</p>
<p><br />
 </p>
<h3><a class="anchor" id="receiverregidmanagement"></a>
Receiver RegID Management&nbsp;&nbsp;<small><a href="#receiverregidmanagement">&lt;-</a></small></h3>
<p>RegIDs are slightly more involved for receivers than for sources. Since RegIDs are per source per topic per store and a topic may have several sources, a receiver may have to manage several RegIDs per store in use. Fortunately, receivers in UM can leverage the RegID of the source with the use of a callback as discussed in Adding Fault Recovery with Registration IDs and shown in ume-example-rcv-2.c. Your application can determine the correct RegID to use and return it to UM. You can also use Session IDs to enable UM to manage receiver RegIDs. See <a class="el" href="index.html#managingregidswithsessionids">Managing RegIDs with Session IDs</a>.</p>
<p>Much like sources, receivers typically have a lifetime based on an amount of work, perhaps an infinite amount. And just like sources, it may be helpful to consider that a RegID is "assigned" at the start of that work and is out of use at the end. In between, the RegID is in use by the instance of the receiver application. However, the nature of RegIDs being per source means that the expected lifetime of a source should play a role in how RegIDs on the receiver are managed. Thus, it may be helpful for the application developer to consider the source application lifetime when deciding how best to handle RegIDs on the receiver.</p>
<p><b>Receiver Message and Event Handler</b></p>
<p>The Receiver Message and Event Handler is an application callback, defined at receiver initialization, to deliver received messages to your application. The following source code examples illustrate the use of a receiver message and event handler for registration messages. To accept other receiver events, additional case statements would be required, one for each additional event. See also <a class="el" href="index.html#persistenceevents">Persistence Events</a></p>
<p><b>C API</b></p>
<pre class="fragment">int rcv_handle_msg(lbm_rcv_t *rcv, lbm_msg_t *msg, void *clientd)
{
    switch (msg-&gt;type) {
    case LBM_MSG_UME_REGISTRATION_ERROR:
        printf("[%s][%s] UME registration error: %s\n", msg-&gt;topic_name,
                msg-&gt;source, msg-&gt;data);
        exit(0);
        break;

    case LBM_MSG_UME_REGISTRATION_SUCCESS:
        {
            lbm_msg_ume_registration_t *reg =
                (lbm_msg_ume_registration_t *)(msg-&gt;data);

            printf("[%s][%s] UME registration successful. "
                "SrcRegID %u RcvRegID %u\n",
                msg-&gt;topic_name, msg-&gt;source,
                reg-&gt;src_registration_id, reg-&gt;rcv_registration_id);
        }
        break;

    case LBM_MSG_UME_REGISTRATION_SUCCESS_EX:
        {
            lbm_msg_ume_registration_ex_t *reg =
                (lbm_msg_ume_registration_ex_t *)(msg-&gt;data);

            printf("[%s][%s] store %u: %s UME registration successful. "
                "SrcRegID %u RcvRegID %u. Flags %x ",
                msg-&gt;topic_name, msg-&gt;source, reg-&gt;store_index, reg-&gt;store,
                reg-&gt;src_registration_id, reg-&gt;rcv_registration_id, reg-&gt;flags);
            if (reg-&gt;flags &amp; LBM_MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD)
                printf("OLD[SQN %x] ", reg-&gt;sequence_number);
            if (reg-&gt;flags &amp; LBM_MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_NOCACHE)
                printf("NOCACHE ");
            printf("\n");
        }
        break;

    case LBM_MSG_UME_REGISTRATION_COMPLETE_EX:
        {
            lbm_msg_ume_registration_complete_ex_t *reg =
                (lbm_msg_ume_registration_complete_ex_t *)(msg-&gt;data);

            printf("[%s][%s] UME registration complete. SQN %x. Flags %x ",
                msg-&gt;topic_name, msg-&gt;source, reg-&gt;sequence_number, reg-&gt;flags);
            if (reg-&gt;flags &amp; LBM_MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM)
                printf("QUORUM ");
            if (reg-&gt;flags &amp; LBM_MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_RXREQMAX)
                printf("RXREQMAX ");
            printf("\n");
        }
        break;

    case LBM_MSG_UME_REGISTRATION_CHANGE:
        printf("[%s][%s] UME registration change: %s\n", msg-&gt;topic_name,
            msg-&gt;source, msg-&gt;data);
        break;
    ...

    default:
        printf("Unknown lbm_msg_t type %x [%s][%s]\n", msg-&gt;type,
            msg-&gt;topic_name, msg-&gt;source);
        break;
    }
    return 0;
}
</pre><p><b>JAVA API</b></p>
<pre class="fragment">public int onReceive(Object cbArg, LBMMessage msg)
{
    case LBM.MSG_UME_REGISTRATION_ERROR:
        System.out.println("[" + msg.topicName() + "][" + msg.source()
                    + "] UME registration error: " + msg.dataString());
        break;

    case LBM.MSG_UME_REGISTRATION_SUCCESS_EX:
        UMERegistrationSuccessInfo reg = msg.registrationSuccessInfo();
        System.out.print("[" + msg.topicName() + "][" + msg.source()
                    + "] store " + reg.storeIndex() + ": "
                    + reg.store() + " UME registration successful. SrcRegID "
                    + reg.sourceRegistrationId() + " RcvRegID "
                    + reg.receiverRegistrationId()
                    + ". Flags " + reg.flags() + " ");
        if ((reg.flags() &amp; LBM.MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD) != 0) {
            System.out.print("OLD[SQN " + reg.sequenceNumber() + "] ");
        }
        if ((reg.flags() &amp; LBM.MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_NOCACHE) != 0) {
            System.out.print("NOCACHE ");
        }
        System.out.println();
        break;

    case LBM.MSG_UME_REGISTRATION_COMPLETE_EX:
        UMERegistrationCompleteInfo regcomplete = msg.registrationCompleteInfo();
        System.out.print("[" + msg.topicName() + "][" + msg.source()
            + "] UME registration complete. SQN " + regcomplete.sequenceNumber()
            + ". Flags " + regcomplete.flags() + " ");
        if ((regcomplete.flags() &amp; LBM.MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM) != 0) {
            System.out.print("QUORUM ");
        }
        if ((regcomplete.flags() &amp; LBM.MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_RXREQMAX) != 0) {
            System.out.print("RXREQMAX ");
        }
        System.out.println();
        break;

    case LBM.MSG_UME_REGISTRATION_CHANGE:
        System.out.println("[" + msg.topicName() + "][" + msg.source()
                    + "] UME registration change: " + msg.dataString());
        break;
    ...

    default:
        System.err.println("Unknown lbm_msg_t type " + msg.type() + " ["
                    + msg.topicName() + "][" + msg.source() + "]");
        break;
    }
    return 0;
}
</pre><p><b>.NET API</b></p>
<pre class="fragment">public int onReceive(Object cbArg, LBMMessage msg)
{
    case LBM.MSG_UME_REGISTRATION_ERROR:
        System. Console.Out.WriteLine("[" + msg.topicName() + "]["
            + msg.source() + "] UME registration error: " + msg.dataString());
        break;

    case LBM.MSG_UME_REGISTRATION_SUCCESS_EX:
        UMERegistrationSuccessInfo reg = msg.registrationSuccessInfo();
        System.Console.Out.Write("[" + msg.topicName() + "][" + msg.source()
                    + "] store " + reg.storeIndex() + ": "
                    + reg.store() + " UME registration successful. SrcRegID "
                    + reg.sourceRegistrationId() + " RcvRegID "
                    + reg.receiverRegistrationId()
                    + ". Flags " + reg.flags() + " ");
        if ((reg.flags() &amp; LBM.MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD) != 0) {
            System.Console.Out.Write ("OLD[SQN " + reg.sequenceNumber() + "] ");
        }
        if ((reg.flags() &amp; LBM.MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_NOCACHE) != 0) {
            System.Console.Out.Write ("NOCACHE ");
        }
        System.Console.Out.WriteLine();
        break;

    case LBM.MSG_UME_REGISTRATION_COMPLETE_EX:
        UMERegistrationCompleteInfo regcomplete = msg.registrationCompleteInfo();
        System.Console.Out.Write("[" + msg.topicName() + "][" + msg.source()
                    + "] UME registration complete. SQN "
                    + regcomplete.sequenceNumber()
                    + ". Flags " + regcomplete.flags() + " ");
        if ((regcomplete.flags() &amp; LBM.MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM) != 0) {
            System.Console.Out.Write("QUORUM ");
        }
        if ((regcomplete.flags() &amp; LBM.MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_RXREQMAX) != 0) {
            System.Console.Out.Write("RXREQMAX ");
        }
        System.Console.Out.WriteLine();
        break;

    case LBM.MSG_UME_REGISTRATION_CHANGE:
        System.Console.Out.WriteLine("[" + msg.topicName() + "][" + msg.source()
                    + "] UME registration change: " + msg.dataString());
        break;
    ...

    default:
        System.Console.Out.WriteLine("Unknown lbm_msg_t type " + msg.type()
                    + " [" + msg.topicName() + "][" + msg.source() + "]");
        break;
    }
    return 0;
}
</pre><p><br />
 </p>
<h3><a class="anchor" id="recoverymanagement"></a>
Recovery Management&nbsp;&nbsp;<small><a href="#recoverymanagement">&lt;-</a></small></h3>
<p>Recovery management for failed and restarted receivers is fairly simple. UM requests any missed messages from the store(s) and delivers them to the restarted receiver. However, your application can override that default behavior either by configuring a <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grplatejoin.html#retransmitrequestmaximumreceiver">retransmit_request_maximum (receiver)</a> value, or by configuring a <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umerecoverysequencenumberinfofunctionreceiver">ume_recovery_sequence_number_info_function (receiver)</a> application callback, or both.</p>
<p>For example, let's say a source sends 7 messages with sequence numbers 0-6 which are stabilized at the store. A C-based receiver, configured with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grplatejoin.html#retransmitrequestmaximumreceiver">retransmit_request_maximum (receiver)</a> set to 2, and an application callback <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umerecoverysequencenumberinfofunctionreceiver">ume_recovery_sequence_number_info_function (receiver)</a>, consumes (and acknowledges) message 0, goes down, then restarts right after message 6.</p>
<p>During receiver registration, the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/lbm_8h.html#ac318ae4d0d80e5595ce572558102c7b5">lbm_ume_rcv_recovery_info_ex_func_t</a> application callback is called with the following values in the passed-in structure <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/lbm_8h.html#a864aeb7e5113d0d496950cf75ae3cda9">lbm_ume_rcv_recovery_info_ex_func_info_t</a>&#160;*info:</p>
<pre class="fragment">info-&gt;high_sequence_number == 6
info-&gt;low_rxreq_max_sequence_number == 4
info-&gt;low_sequence_number == 1
</pre><p>Where: </p><ul>
<li>
<p class="startli"><a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/structlbm__ume__rcv__recovery__info__ex__func__info__t__stct.html#a6365dff87b32b8f4e6e7e985d01acb75">lbm_ume_rcv_recovery_info_ex_func_info_t::high_sequence_number</a> - the most recent message sent by the source,</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/structlbm__ume__rcv__recovery__info__ex__func__info__t__stct.html#ab8e05918a9c715b8edbd1e834815eb10">lbm_ume_rcv_recovery_info_ex_func_info_t::low_rxreq_max_sequence_number</a> - high_sequence_number (above) minus the number configured for <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grplatejoin.html#retransmitrequestmaximumreceiver">retransmit_request_maximum (receiver)</a> (2 in this example), and</p>
<p class="endli"></p>
</li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/structlbm__ume__rcv__recovery__info__ex__func__info__t__stct.html#a730df0455e0c47ec41434c5f0664e0be">lbm_ume_rcv_recovery_info_ex_func_info_t::low_sequence_number</a> - the first sequence number missed by the receiver after it went down. </li>
</ul>
<p>Normally, UM would start delivering messages at 1, but <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grplatejoin.html#retransmitrequestmaximumreceiver">retransmit_request_maximum (receiver)</a> is set to 2, which overrides UM's normal behavior. So in this example, the first message delivered will be number 4.</p>
<p>Finally, the application can, at run-time, further override the starting sequence number. The callback function can modify the contents of the passed-in structure <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/lbm_8h.html#a864aeb7e5113d0d496950cf75ae3cda9">lbm_ume_rcv_recovery_info_ex_func_info_t</a>&#160;*info; specifically it can update the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/structlbm__ume__rcv__recovery__info__ex__func__info__t__stct.html#a730df0455e0c47ec41434c5f0664e0be">lbm_ume_rcv_recovery_info_ex_func_info_t::low_sequence_number</a> field. When the callback returns, UM examines that field to see if it was modified by the callback. If so, UM overrides the effect of <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grplatejoin.html#retransmitrequestmaximumreceiver">retransmit_request_maximum (receiver)</a> and starts at the requested sequence number.</p>
<p>Notice that this design does not allow the callback to override the effect of <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grplatejoin.html#retransmitrequestmaximumreceiver">retransmit_request_maximum (receiver)</a> by setting the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/structlbm__ume__rcv__recovery__info__ex__func__info__t__stct.html#a730df0455e0c47ec41434c5f0664e0be">lbm_ume_rcv_recovery_info_ex_func_info_t::low_sequence_number</a> field to its original value, 1 in this example. Upon return, UM will see the value unchanged, and will allow <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grplatejoin.html#retransmitrequestmaximumreceiver">retransmit_request_maximum (receiver)</a> to override the starting sequence number. This is only an issue if <em>both</em> <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grplatejoin.html#retransmitrequestmaximumreceiver">retransmit_request_maximum (receiver)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umerecoverysequencenumberinfofunctionreceiver">ume_recovery_sequence_number_info_function (receiver)</a> are used. If the application wants to use the sequence number remembered by the store, it should not configure <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grplatejoin.html#retransmitrequestmaximumreceiver">retransmit_request_maximum (receiver)</a>.</p>
<p><br />
 </p>
<h3><a class="anchor" id="duplicatmessagedelivery"></a>
Duplicate Message Delivery&nbsp;&nbsp;<small><a href="#duplicatmessagedelivery">&lt;-</a></small></h3>
<p>In a distributed system, it is not possible to <em>guarantee</em> "once-and-only-once" delivery of messages in the face of unpredictable system or component failure. Regardless of the algorithms and handshaking, there is always the possibility of messages sent that are never received, as well as messages received and then received again if the receiving application fails and restarts.</p>
<p>UM's persistence design is based on the principle of being close to once-and-only-once, but when that is not possible, UM prefers to fail on the side of duplicate message delivery. Due to other design goals (low latency and high throughput), the possibility of receiving duplicate messages is significant after an application failure and restart.</p>
<p>It is therefore important for persistent applications to be designed to tolerate duplicate message reception, either by making message processing idempotent, or by including logic in the receiving application to detect duplicates and only process the messages which have not been previously processed.</p>
<p>To assist the application in implementing "de-duplication", all messages retransmitted to a receiver are marked as retransmissions via a flag in the message structure. Thus it is easy for an application to determine if a message is a new "live" message from the source, or a retransmission, which may or may not have been processed before the failure. The presence or absence of the retransmit flag gives the application a hint of how best to handle the message with regard to it being processed previously or not.</p>
<p>Informatica recommends that you always check the data or other message properties of messages with the retransmit flag set to be sure the message has not been already processed. Relying on UM sequence numbers is not a 100% reliable method for detecting duplicate messages.</p>
<p><br />
 </p>
<h3><a class="anchor" id="settingcallbackfunctiontosetrecoverysequencenumber"></a>
Setting Callback Function to Set Recovery Sequence Number&nbsp;&nbsp;<small><a href="#settingcallbackfunctiontosetrecoverysequencenumber">&lt;-</a></small></h3>
<p>Whereas the UM persistence design attempts to choose the correct starting sequence number for a recovering receiver, there are cases where the application wishes to override UM's choice.</p>
<p>The sample code below demonstrates how to use the recovery sequence number info function to determine the stored message with which to restart a receiver. This example retrieves the low sequence number from the recovery sequence number structure and adds an offset to determine the beginning sequence number. The offset is a value completely under the control of your application. For example, if a receiver was down for a "long" period and you only want the receiver to receive the last 10 messages, use an offset to start the receiver with the 10th most recent message. If you wish not to receive any messages, set the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/structlbm__ume__rcv__recovery__info__ex__func__info__t__stct.html#a730df0455e0c47ec41434c5f0664e0be">lbm_ume_rcv_recovery_info_ex_func_info_t::low_sequence_number</a> to the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/structlbm__ume__rcv__recovery__info__ex__func__info__t__stct.html#a6365dff87b32b8f4e6e7e985d01acb75">lbm_ume_rcv_recovery_info_ex_func_info_t::high_sequence_number</a> plus one.</p>
<p><b>C API</b></p>
<pre class="fragment">lbm_ume_rcv_recovery_info_ex_func_t cb;

cb.func = ume_rcv_seqnum_ex;  /* declared below */
cb.clientd = NULL;
if (lbm_rcv_topic_attr_setopt(&amp;rcv_attr,
                              "ume_recovery_sequence_number_info_function",
                              &amp;cb, sizeof(cb)) == LBM_FAILURE) {
    fprintf(stderr,
        "lbm_rcv_topic_attr_setopt:ume_recovery_sequence_number_info_function: %s\n",
        lbm_errmsg());
    exit(1);
}
printf("Will use seqnum info with low offset %u.\n", seqnum_offset);

...

int ume_rcv_seqnum_ex(lbm_ume_rcv_recovery_info_ex_func_info_t *info, void *clientd)
{
    lbm_uint_t new_lo = info-&gt;low_sequence_number + seqnum_offset;

    printf("[%s] SQNs Low %x (will set to %x), Low rxreqmax %x, High %x (CD %p)\n",
        info-&gt;source, info-&gt;low_sequence_number,
        new_lo, info-&gt;low_rxreq_max_sequence_number,
        info-&gt;high_sequence_number, info-&gt;source_clientd);
    info-&gt;low_sequence_number = new_lo;
    return 0;
}
</pre><p><b>JAVA API</b></p>
<pre class="fragment">UMERcvRecInfo umerecinfocb = new UMERcvRecInfo(seqnum_offset);
rcv_attr.setRecoverySequenceNumberCallback(umerecinfocb, null);
System.out.println("Will use seqnum info with low offset " + seqnum_offset);

class UMERcvRecInfo implements UMERecoverySequenceNumberCallback {
    private long _seqnum_offset = 0;

    public UMERcvRecInfo(long seqnum_offset) {
        _seqnum_offset = seqnum_offset;
    }

    public int setRecoverySequenceNumberInfo(Object cbArg,
    UMERecoverySequenceNumberCallbackInfo cbInfo)
    {
        long new_low = cbInfo.lowSequenceNumber() + _seqnum_offset;
        System.out.println("SQNs Low " + cbInfo.lowSequenceNumber() + " (will set to "
            + new_low + "), Low rxreqmax " + cbInfo.lowRxReqMaxSequenceNumber()
            + ", High " + cbInfo.highSequenceNumber());
        try {
            cbInfo.setLowSequenceNumber(new_low);
        }
        catch (LBMEInvalException e) {
            System.err.println(e.getMessage());
        }
        return 0;
     }
 }
</pre><p><b>.NET API</b></p>
<pre class="fragment">UMERcvRecInfo umerecinfocb = new UMERcvRecInfo(seqnum_offset);
rcv_attr.setRecoverySequenceNumberCallback(umerecinfocb, null);
System.Console.Out.WriteLine("Will use seqnum info with low offset " + seqnum_offset);

class UMERcvRecInfo implements UMERecoverySequenceNumberCallback {
    private long _seqnum_offset = 0;

    public UMERcvRecInfo(long seqnum_offset) {
        _seqnum_offset = seqnum_offset;
    }

    public int setRecoverySequenceNumberInfo(Object cbArg,
        UMERecoverySequenceNumberCallbackInfo cbInfo)
    {
        long new_low = cbInfo.lowSequenceNumber() + _seqnum_offset;
        System.Console.Out.WriteLine ("SQNs Low " + cbInfo.lowSequenceNumber() + " (will set to "
            + new_low + "), Low rxreqmax " + cbInfo.lowRxReqMaxSequenceNumber()
            + ", High " + cbInfo.highSequenceNumber());
        try {
            cbInfo.setLowSequenceNumber(new_low);
        }
        catch (LBMEInvalException e) {
            System.Console.Out.WriteLine (e.getMessage());
        }
        return 0;
    }
}
</pre><p><br />
 </p>
<h3><a class="anchor" id="persistencemessageconsumption"></a>
Persistence Message Consumption&nbsp;&nbsp;<small><a href="#persistencemessageconsumption">&lt;-</a></small></h3>
<p>Receivers use message consumption, defined as message deletion, to indicate that UM should notify the store(s) that the application consumed the message. This notification takes the form of an acknowledgement, or ACK, to the store(s) in use, and optionally to the source if you configure the source for delivery confirmation.</p>
<p>In many applications, the message receiver application callback will fully process the received message. When the application callback returns, the message should be deleted and acknowledged.</p>
<p>However, there are other application designs where a received message cannot be fully processed inside the receiver application callback. For example, the message might need to be passed to a worker thread for longer-term processing. Or the acknowledgement must be delayed until some other event happens, like a handshake with another application. In these cases, the message deletion and/or message acknowledgement must not be done when the receiver callback returns.</p>
<p>Finally, for high-throughput applications, an application can completely suppress the acknowledgement of each individual message in favor of acknowledgement batching (acknowledging multiple messages in one operation). This is done to reduce the per-message overhead. Note that acknowledgement batching increases the chances that a restarted application will receive duplicate messages (messages that had been previously process but not yet acknowledged). See <a class="el" href="index.html#duplicatmessagedelivery">Duplicate Message Delivery</a> for more information.</p>
<p><br />
 </p>
<h3><a class="anchor" id="immediatemessageconsumption"></a>
Immediate Message Consumption&nbsp;&nbsp;<small><a href="#immediatemessageconsumption">&lt;-</a></small></h3>
<p>In many applications, the message receiver application callback will fully process the received message. When the receive callback returns, the message should be deleted and acknowledged. This is handled differently between the C API vs. the Java and .NET APIs.</p>
<p><b>C API</b></p>
<p>The default behavior for a C receiver application callback is for the message to be deleted and acknowledged when the receiver callback returns. No special coding is needed for this use case.</p>
<p><b>Java and .NET</b></p>
<p>With Java and .NET, the UM library is not able to differentiate between a message that is passed to a different part of the application vs. a message which is simply dereferenced for eventual garbage collection. So the default behavior of the UM library is different &ndash; it is assumed that the message should <em>not</em> be deleted and acknowledged when the receiver application callback returns. Instead, the application is expected to explicitly dispose of received messages when processing is complete.</p>
<p>In the case where message processing is completed in the receiver callback, the application must call the "dispose()" method of the message object before returning. This triggers acknowledgement as well as cleanup of the message's resources.</p>
<p><br />
 </p>
<h3><a class="anchor" id="delayedmessageprocessing"></a>
Delayed Message Processing&nbsp;&nbsp;<small><a href="#delayedmessageprocessing">&lt;-</a></small></h3>
<p>There are application designs where a received message cannot be fully processed inside the receiver application callback. For example, the message might need to be passed to a worker thread for longer-term processing. Or the acknowledgement must be delayed until some other event happens, like a handshake with another application.</p>
<p>This is handled differently between the C API vs. the Java and .NET APIs.</p>
<p><b>C API</b></p>
<p>In the C API, the application's receiver callback function must call the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/lbm_8h.html#a2b7788ff58f9e78bc89ea890dad0cccf">lbm_msg_retain()</a> function for the received message. This suppresses the automatic deletion of the received message when the receiver callback returns, and allows the message buffer to be handed to some other part of the application for processing and deletion at a later time.</p>
<p>When the application subsequently completes all processing of the message and is ready for the message to be deleted and acknowledged, it calls <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/lbm_8h.html#aa5fc1eb324a55b8c800c31460b0f0116">lbm_msg_delete()</a>.</p>
<p><b>Java and .NET</b></p>
<p>With Java and .NET, the UM library assumes that the message should <em>not</em> be deleted and acknowledged when the receiver application callback returns. The callback can simply pass the message to some other part of the application for subsequent processing.</p>
<p>When the application has completed all processing on the message, the message's "dispose()" method should be called. This releases resources held by the object and also triggers the acknowledgement.</p>
<p><br />
 </p>
<h3><a class="anchor" id="batchingacknowledgments"></a>
Batching Acknowledgments&nbsp;&nbsp;<small><a href="#batchingacknowledgments">&lt;-</a></small></h3>
<p>For high-throughput applications, it is often desired to reduce the per-message overhead. Sending acknowledgements to the Store and optionally to the source normally involves multiple socket operations, which can limit the maximum sustainable throughput of a persistent receiver.</p>
<p>A significant reduction in per-message overhead can be achieved by batching acknowledgements. In this use case, the sending of acknowledgements is delayed until multiple messages have been received and processed. Then an acknowledgement is sent which covers all messages processed so far.</p>
<dl class="section warning"><dt>Warning</dt><dd>While ACK batching provides significant improvements in receiver throughput, it also increases the probability that a failed and restarted receiver will be sent <a class="el" href="index.html#duplicatmessagedelivery">duplicate messages</a> (i.e. messages that the application has already received and processed).</dd></dl>
<p>ACK Batching can be done implicitly or explicitly. For implicit ACK batching, use the configuration options <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeuseackbatchingreceiver">ume_use_ack_batching (receiver)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeackbatchingintervalcontext">ume_ack_batching_interval (context)</a>. Note that implicit ACK batching also supports out-of-order acknowledgements. See <a class="el" href="index.html#ackordering">ACK Ordering</a>.</p>
<p>Explicit ACK batching gives the application precise control over when acknowledgements are sent via API calls. This mode of operation is enabled with the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeexplicitackonlyreceiver">ume_explicit_ack_only (receiver)</a> configuration option. If enabled, acknowledgements are only sent as a result of the application explicitly calling an API. This allows the application to use application-level knowledge to optimize when to send acknowledgements, potentially minimizing the time that processed messages are left unacknowledged (and therefore minimizing the number of potential <a class="el" href="index.html#duplicatmessagedelivery">duplicate messages</a>).</p>
<p>See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/lbm_8h.html#a2b5aa9394b4911eb8e39768a57d5b49e">lbm_ume_ack_send_explicit_ack()</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/lbm_8h.html#ad920e7ab51a45099390091dd36d26a34">lbm_msg_ume_send_explicit_ack()</a> for the C API. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/javaapi.tag:../../JavaAPI/" href="../../JavaAPI/classcom_1_1latencybusters_1_1lbm_1_1LBMMessage.html#ac367c5298b0db98072b89d4572069db0">com::latencybusters::lbm::LBMMessage::sendExplicitAck()</a> for Java and .NET. See <a class="el" href="index.html#explicitacknowledgments">Explicit Acknowledgments</a> for details on explicit ACKs.</p>
<p><br />
 </p>
<h3><a class="anchor" id="ackordering"></a>
ACK Ordering&nbsp;&nbsp;<small><a href="#ackordering">&lt;-</a></small></h3>
<p>The Persistent Store does not support "out of order" acknowledgement of messages. If the Store receives an acknowledgement of sequence number N, that implicitly acknowledges all sequence numbers less than N. If a receiving application has the ability to complete processing of messages out of order, it must ensure that an acknowledgement is sent for a given message until all previously-received messages have been completely processed.</p>
<p>Normally, the only way that a receiving application <em>can</em> process messages out of order is to retain those messages and complete processing of them outside of the receiver application callback function. This normally requires "retaining" the messages so that they aren't deleted (and therefore acknowledged) automatically when the receiver callback returns. In this usage, when a message is completely processed, that message is deleted by the application, triggering the acknowledgement of that message. However, if the application design allows those messages to be processed out of order, then the risk exists that the acknowledgement of a given message will implicitly acknowledge previous message which have not been completely processed. This will prevent those incompletely processed messages from being recovered if the receiving application fails and restarts.</p>
<p>ACK Batching can provide a solution, implicitly or explicitly.</p>
<p>The implicit form of ACK batching provides, as a convenience, the ability to postpone the sending of a message ACK until all previous received messages have also been processed. When the UM context wakes up every <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeackbatchingintervalcontext">ume_ack_batching_interval (context)</a> milliseconds, it checks for unacknowledged messages that have been deleted, either implicitly from the receiver callback returning, or explicitly by API calls to retain and then delete the message. UM will only acknowledge up to the highest <em>continuous</em> sequence number.</p>
<p>For example, let's say the application deletes messages with sequence numbers 0, 1, 5, 2, 4. Messages 3 and 6 are still being processed. If the context wakes up at this point, it will send an acknowledgement for sequence 2. If the application fails at this point and restarts, the Store will re-send messages 3, 4, 5, and 6. The receiving application must handle the fact that 3 and 6 were incompletely processed, whereas 4 and 5 were completely processed (see <a class="el" href="index.html#duplicatmessagedelivery">Duplicate Message Delivery</a>).</p>
<p>Instead of using implicit batching for this, the application can be coded to use <a class="el" href="index.html#explicitacknowledgments">Explicit Acknowledgments</a>. However, in this case, the application has the responsibility to implement a similar algorithm as the implicit ACK batcher described above. I.e. even though the messages 4 and 5 were fully processed, the application would need to postpone sending an acknowledgement until message 3 is also completed, at which point a single acknowledgement for sequence 5 can be sent.</p>
<p><br />
 </p>
<h3><a class="anchor" id="explicitacknowledgments"></a>
Explicit Acknowledgments&nbsp;&nbsp;<small><a href="#explicitacknowledgments">&lt;-</a></small></h3>
<p>UM supports Explicit acknowledgement which suppresses UM's default acknowledgement behavior, allowing your application complete control of message consumption notification.</p>
<p>There are two common use cases for Explicit Acknowledgements: </p><ul>
<li>
Deferred Acknowledgement. </li>
<li>
Application-level ACK batching. </li>
</ul>
<p>Deferred Acknowledgement means that the receiving application is not able to fully process a message within the message receiver application callback. For example, the message may require processing in a separate thread. By default, UM will acknowledge a persisted message when the receiver callback returns.</p>
<p>Application-level ACK batching means that the application chooses not to acknowledge every received message. Instead, it implements its own logic to decide which messages to acknowledge. Note that acknowledging a given message implicitly acknowledges all earlier messages. For example, acknowledging messages 5, 10, and 15 tells the Store that <em>all</em> messages 0-15 are acknowledged.</p>
<p>Also note that this imposes the restriction that messages be acknowledged in ascending order. See <a class="el" href="index.html#ackordering">ACK Ordering</a> for more information.</p>
<p>Explicit acknowledgement is enabled using the configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeexplicitackonlyreceiver">ume_explicit_ack_only (receiver)</a>.</p>
<p><br />
 </p>
<h3><a class="anchor" id="objectfreeexplicitacknowledgments"></a>
Object-free Explicit Acknowledgments&nbsp;&nbsp;<small><a href="#objectfreeexplicitacknowledgments">&lt;-</a></small></h3>
<p>When using explicit ACKs, you can extract ACK information from messages. This allows the received message buffer to be deleted when the receiver callback is done, while still allowing the application to save the ACK structure for persistent acknowledgement to the Store at a future time. This can improve receiver performance when used with the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/design.tag:../../Design/" href="../../Design/advancedoptimizations.html#receivebufferrecycling">Receive Buffer Recycling</a> feature to reduce the per-message use of dynamic memory (malloc/free) with a persistent receiver. Extracting ACKs can also additionally improve performance of Java and .NET applications by allowing the use of <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/design.tag:../../Design/" href="../../Design/fundamentalconcepts.html#zeroobjectdelivery">Zero Object Delivery</a>.</p>
<p>The following source code examples show how to extract ACK information and send an explicit ACK.</p>
<p><b>C API</b></p>
<pre class="fragment">int rcv_handle_msg(lbm_rcv_t *rcv, lbm_msg_t *msg, void *clientd)
{
  lbm_ume_rcv_ack_t *ack = NULL;
...

  ack = lbm_msg_extract_ume_ack(msg);
  defer_ack(ack);  /* Pass the "ack" to another thread or work queue. */
...
  return 0;
}

int worker()
{
  lbm_ume_rcv_ack_t *ack = NULL;
...
  ack = get_deferred_ack();  /* Get "ack" that was saved above. */

  /* Some applications improve throughput by not ACKing every message. */
  if (ack_this_message) {
    lbm_ume_ack_send_explicit_ack(ack, msg-&gt;sequence_number);
  }

  lbm_ume_ack_delete(ack);  /* Extracted ack *must* be deleted. */
...

}
</pre><p><b>JAVA API or .NET API</b></p>
<pre class="fragment">public int onReceive(Object cbArg, LBMMessage msg)
{
  UMEMessageAck ack;
...

  ack = msg.extractUMEAck();
  defer_ack(ack);  /* Pass the "ack" to another thread or work queue. */
...
  return 0;
}

int worker()
{
  UMEMessageAck ack;

  ack = get_deferred_ack();  /* Get "ack" that was saved above. */

  /* Some applications improve throughput by not ACKing every message. */
  if (ack_this_message) {
    ack.sendExplicitAck(msg.sequenceNumber());
  }
  ack.dispose();  /* Extracted ack *must* be deleted. */
}
</pre><p><br />
 </p>
<h2><a class="anchor" id="designingpersistentstores"></a>
Designing Persistent Stores&nbsp;&nbsp;<small><a href="#designingpersistentstores">&lt;-</a></small></h2>
<p>As mentioned in <a class="el" href="index.html#persistentstoreconcept">Persistent Store Concept</a>, the persistent stores, also just called stores, actually persist the source and receiver state and use RegIDs to identify sources and receivers. Each source to which a store provides persistence may have zero or more receivers. The store maintains each receiver's state along with the source's state and the messages the source has sent.</p>
<p>The store can be configured with its own set of options to persist this state information on disk or simply in memory. The term disk store is used to signify a store that persists state to disk, and the term memory store is used to signify a store that persists state only in memory. A store may also be configured not to cache the source's data, but to simply persist the source and receiver state in memory. This is called a no-cache store.</p>
<p>A source does not send data to the store and then have the store forward it to the receivers. In UM, the source sends to receivers and the stores in parallel. See <a class="el" href="index.html#persistencenormaloperation">Persistence Normal Operation</a>. Thus, UM can provide extremely low latency to receiving applications.</p>
<p>The store(s) that a source uses are part of the source's configuration settings. Sources must be configured to use specific store(s) in a Quorum/Consensus arrangement.</p>
<p>Receivers, on the other hand, do not need to be configured with store information a priori. The source provides store information to receivers via a Source Registration Information (SRI) message after the source registers with a store. Thus the receivers learn about stores from the source, without needing to be configured themselves. Because receivers learn about the store or stores with which they must register via a SRI record, the source must be available to receivers. However, the source does not have to be actively sending data to do this.</p>
<p><br />
 </p>
<h3><a class="anchor" id="storelogfile"></a>
Store Log File&nbsp;&nbsp;<small><a href="#storelogfile">&lt;-</a></small></h3>
<p>The store daemon generates log messages that are used to monitor its health and operation. You can configure these to be directed to "console" (standard output) or a specified log "file", via the <a class="el" href="index.html#logelement">&lt;log&gt;</a> configuration element. Normally "console" is only used during testing, as a persistent log file is preferred for production use. The store does not over-write log files on startup, but instead appends them.</p>
<p><br />
 </p>
<h3><a class="anchor" id="storerollinglogs"></a>
Store Rolling Logs&nbsp;&nbsp;<small><a href="#storerollinglogs">&lt;-</a></small></h3>
<p>To prevent unbounded disk file growth, the store supports rolling log files. When the log file rolls, the file is renamed according to the model: <br />
&#160;&#160;<em>CONFIGUREDNAME</em><code>_</code><em>PID</em><code>.</code><em>DATE</em><code>.</code><em>SEQNUM</em> <br />
where: </p><ul>
<li>
<em>CONFIGUREDNAME</em> - Root name of log file, as configured by user. </li>
<li>
<em>PID</em> - Process ID of the store daemon process. </li>
<li>
<em>DATE</em> - Date that the log file was rolled, in YYYY-MM-DD format. </li>
<li>
<em>SEQNUM</em> - Sequence number, starting at 1 when the process starts, and incrementing each time the log file rolls. </li>
</ul>
<p>For example: <code>umestorelog_9867.2017-08-20.2</code></p>
<p>The user can configure when the log file is eligible to roll over by either or both of two criteria: size and frequency. The size criterion is in millions of bytes. The frequency criterion can be daily or hourly. Once one or both criteria are met, the next message written to the log will trigger a roll operation. These criteria are supplied as attributes to the <a class="el" href="index.html#logelement">&lt;log&gt;</a> configuration element.</p>
<p>If both criteria are supplied, then the first one to be reached will trigger a roll. For example, consider the setting: </p><pre class="fragment">  &lt;log type="file" size="23" frequency="daily"&gt;store.log&lt;/log&gt;
</pre><p> Let say that the log file grows at 1 million bytes per hour. At 11:00 pm, the log file will reach 23 million bytes, and will roll. Then, at 12:00 midnight, the log file will roll again, even though it is only 1 million bytes in size.</p>
<dl class="section note"><dt>Note</dt><dd>The rolling logs cannot be configured to automatically overwrite old logs. Thus, the amount of disk space consumed by log files will grow without bound. The user must implement a desired process of archiving or deleting older log files according to the user's preference.</dd></dl>
<p><br />
 </p>
<h3><a class="anchor" id="quorumconsensusstoreusage"></a>
Quorum/Consensus Store Usage&nbsp;&nbsp;<small><a href="#quorumconsensusstoreusage">&lt;-</a></small></h3>
<p>To provide the highest degree of resiliency in the face of failures, UM provides the Quorum/Consensus failover strategy which allows a source to provide UM with a number of stores to be used at the same time. Multiple stores can fail and messaging can continue operation unhindered as long as a majority of configured stores are operational.</p>
<p>Quorum/Consensus, also called QC, allows a source and the associated receivers to have their persisted state maintained at several stores at the same time. Central to QC is the concept of a group of stores, which is a logical grouping of stores that are intended to signify a single entity of resilience. Within the group, individual stores may fail but for the group as a whole to be viable and provide resiliency, a quorum must be available. In UM, a quorum is a simple majority. For example, in a group of five stores, three stores are required to maintain a quorum. One or two stores may fail and the group continues to provide resiliency. UM requires a source to have a quorum of stores available in the group in order to send messages. A group can consist of a single store.</p>
<p>QC also provides the ability to use multiple groups. As long as a single group maintains quorum, then UM allows a source to proceed. Groups are logical in nature and can be combined in any way imaginable, such as by store location, store type, etc. In addition, QC provides the ability to specify backup stores within groups. Backups may be used if or when a store in the group becomes unresponsive to the source. Quorum/Consensus allows a source many different failure scenarios simply not available in other persistent messaging systems.</p>
<p><br />
 </p>
<h3><a class="anchor" id="sourcesusingquorumconsensusstoreconfiguration"></a>
Sources Using Quorum/Consensus Store Configuration&nbsp;&nbsp;<small><a href="#sourcesusingquorumconsensusstoreconfiguration">&lt;-</a></small></h3>
<p>In the case of Quorum/Consensus store behavior, a message is considered stable after it has been successfully stored within a group of stores or among groups of stores according to the two settings, intergroup behavior and intragroup behavior, described below.</p>
<ul>
<li>
<p class="startli">The intragroup behavior specifies the requirements needed to stabilize a message among the stores within a group. A message is stable for the group once it is successfully stored at a quorum (majority) of the group's stores or successfully stored in all the stores in the group.</p>
<p class="endli"></p>
</li>
<li>
The intergroup behavior specifies the requirements needed to stabilize a message among groups of stores. A message is stable among the groups if it is successfully stored at any group, a majority of groups, all groups, or all active groups. </li>
</ul>
<p>Notice that a message needs to meet intragroup stability requirements before it can meet intergroup stability requirements. These options provide a number of possibilities for retention of messages for the source.</p>
<p>The following figure displays a 3-group Quorum/Consensus configuration with each group in a different location. A message is considered stable when it has been successfully stored at a quorum of stores in all the active groups.</p>
<p><b>Quorum/Consensus - Single Location Groups</b></p>
<div class="image">
<img src="qc_config_one_locn.png" alt="qc_config_one_locn.png"/>
</div>
 <p>The source application's UM configuration file appears below.</p>
<pre class="fragment">source ume_store 10.29.3.77:10313:101000:0
source ume_store 10.29.3.77:11313:110000:0
source ume_store 10.29.3.77:12313:120000:0
source ume_store 10.29.3.77:13313:130000:0
source ume_store 10.29.3.77:14313:140000:0
source ume_store 10.29.3.78:15313:150000:1
source ume_store 10.29.3.78:16313:160000:1
source ume_store 10.29.3.78:17313:170000:1
source ume_store 10.29.3.79:18313:180000:2
source ume_store 10.29.3.79:19313:190000:2
source ume_store 10.29.3.79:29313:290000:2
source ume_store 10.29.3.79:39313:390000:2
source ume_store 10.29.3.79:49313:490000:2

source ume_message_stability_notification 1
source ume_store_behavior qc

source ume_store_group 0:5
source ume_store_group 1:3
source ume_store_group 2:5

source ume_retention_intragroup_stability_behavior quorum
source ume_retention_intergroup_stability_behavior all-active
</pre><p><br />
 </p>
<h2><a class="anchor" id="persistentfaultrecovery"></a>
Persistent Fault Recovery&nbsp;&nbsp;<small><a href="#persistentfaultrecovery">&lt;-</a></small></h2>
<p>Recovery from source and receiver failure is the real heart of persistent operation. For a source, this means continuing operation from where it stopped. For a receiver, this means essentially the same thing, but with the retransmission of missed messages. Application developers can easily leverage the information in UM to make their applications recover from failure in graceful ways.</p>
<p><a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/design.tag:../../Design/" href="../../Design/fundamentalconcepts.html#latejoin">Late Join</a> is the mechanism of persistent recovery as well as an UM streaming feature. If Late Join is turned off on a source (<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grplatejoin.html#latejoinsource">late_join (source)</a>) or receiver (<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grplatejoin.html#uselatejoinreceiver">use_late_join (receiver)</a>), it also turns off persistent recovery. In order to control Late Join behavior, UM provides a mechanism for a receiver to control the low sequence number. See <a class="el" href="index.html#recoverymanagement">Recovery Management</a>.</p>
<p>Not all failures are recoverable. For application developers it usually pays in the long run to identify what types of errors are non-recoverable and how best to handle them when possible. Such an exercise establishes the precise boundaries of expected versus abnormal operating conditions.</p>
<p><br />
 </p>
<h3><a class="anchor" id="persistentsourcerecovery"></a>
Persistent Source Recovery&nbsp;&nbsp;<small><a href="#persistentsourcerecovery">&lt;-</a></small></h3>
<p>The following shows the basic steps of source recovery:</p>
<ol>
<li>
Re-register with the store. </li>
<li>
Determine the highest sequence number that the store has from the source. </li>
<li>
Resume sending with the next sequence number. </li>
</ol>
<p>Because UM allows you to stream messages and not wait until a message is stable at the persistent store before sending the next message, the main task of source recovery is to determine what messages the persistent store(s) have and what they don't. Therefore, when a source re-registers with a store during recovery, the store tells the source what sequence number it has as the most recent from the source. The registration event informs the application of this sequence number. See <a class="el" href="index.html#sourceeventhandler">Source Event Handler</a>.</p>
<p>In addition, a mechanism exists (LBM_SRC_EVENT_SEQUENCE_NUMBER_INFO) that allows the application to know the sequence number assigned to every piece of data it sends. The combination of registration and sequence number information allows an application to know exactly what a store does have and what it does not and where it should pick up sending. An application designed to stream data in this way should consider how best to maintain this information.</p>
<p>When QC is in use, UM uses the consensus of the group(s) to determine what sequence number to use in the first message it will send. This is necessary as not all stores can be expected to be in total agreement about what was sent in a distributed system. The application can configure the source with the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeconsensussequencenumberbehaviorsource">ume_consensus_sequence_number_behavior (source)</a> to use the lowest sequence number of the latest group of sequence numbers seen from any store, the highest, or the majority. In most cases, the majority, which is the default, makes the most sense as the consensus. The lowest is a very conservative setting. And the highest is somewhat optimistic. Your application has the flexibility to handle this in any way needed.</p>
<p>If streaming is not what an application desires due to complexity, then it is very simple to use the <a class="el" href="index.html#persistenceevents">Persistence Events</a> delivered to the application to mimic the behavior of restricting a source to having only one unstable message at a time.</p>
<p><br />
 </p>
<h3><a class="anchor" id="persistentreceiverrecovery"></a>
Persistent Receiver Recovery&nbsp;&nbsp;<small><a href="#persistentreceiverrecovery">&lt;-</a></small></h3>
<p>The following shows the basic steps of receiver recovery:</p>
<ol>
<li>
Re-register with the store. </li>
<li>
Determine the low sequence number. </li>
<li>
Request retransmission of messages starting with the low sequence number. </li>
</ol>
<p>UM provides extensive options for controlling how receivers handle recovery. By default, receivers want to restart after the last piece of data that was consumed prior to failure or graceful suspension. Since UM persists receiver state at the store, receivers request this state from the store as part of re-registration and recovery. Receiving applications experiencing unrecoverable loss can potentially retrieve missed messages from the stores by deleting and recreating the receiver object.</p>
<p>The actual sequence number that a receiver uses as the first topic level message to resume reception with is called the "low sequence number". UM provides a means of modifying this sequence number if desired. An application can decide to use the sequence number as is, to use an even older sequence number, to use a more recent sequence number, or to simply use the most recent sequence number from the source. See <a class="el" href="index.html#recoverymanagement">Recovery Management</a> and <a class="el" href="index.html#settingcallbackfunctiontosetrecoverysequencenumber">Setting Callback Function to Set Recovery Sequence Number</a>. This allows receivers great flexibility on a per source basis when recovering. New receivers, receivers with no pre-existing registration, also have the same flexibility in determining the sequence number to begin data reception.</p>
<p>Like sources, when QC is in use, UM uses the consensus of the group(s) to determine the low sequence number. And as with sources, this is necessary as not all stores can be expected to be in total agreement about what was acknowledged. The application can configure the receiver with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeconsensussequencenumberbehaviorreceiver">ume_consensus_sequence_number_behavior (receiver)</a> to use the lowest sequence number of the latest group of sequence numbers seen from any store, the highest, or the majority. In most cases, the majority, which is the default, makes the most sense as the consensus. The lowest is a very conservative setting. And the highest is somewhat optimistic. In addition, this sequence number may be modified by the application after the consensus is determined.</p>
<p>For QC, UM load balances receiver retransmission requests among the available stores. In addition, if requests are unanswered, retransmissions of the actual requests will use different stores. This means that as long as a single store has a message, then it is possible for that message to be retransmitted to a requesting receiver.</p>
<p><br />
 </p>
<h2><a class="anchor" id="callablestore"></a>
Callable Store&nbsp;&nbsp;<small><a href="#callablestore">&lt;-</a></small></h2>
<p>It is possible for an application to start an instance of the store to run as an independent set of threads within the application process. However, there are several restrictions:</p>
<ol>
<li>
<p class="startli">The application may not make use of messaging. I.e. an application which intends to start a store instance must not create contexts, sources, or receivers, or make any use of UM except starting (and optionally stopping) the store. For applications that need to use messaging, it is suggested that the application create a child process from which to invoke the store. The parent process can then use messaging freely. See the example program <a href="../../example/umestored_example.c">umestored_example.c</a> for an example of how this can be done.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Only a C API is provided at this time. Two API functions are available: <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umestored__main_8h.html#ae0f0d211a889aee9ea3f4f57d4c75e3a">umestored_main()</a> to start the store threads running, and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umestored__main_8h.html#a974d80bb5206243675c3e0646cbd88d4">umestored_main_shutdown()</a> to request the store threads to stop gracefully.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umestored__main_8h.html#ae0f0d211a889aee9ea3f4f57d4c75e3a">umestored_main()</a> API will not return until the store exits, either by processing a signal, or by the application calling <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umestored__main_8h.html#a974d80bb5206243675c3e0646cbd88d4">umestored_main_shutdown()</a>. When <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umestored__main_8h.html#ae0f0d211a889aee9ea3f4f57d4c75e3a">umestored_main()</a> does return, the store is in a safe state for the application to exit.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Only a single instance of the store may be started. This means that an application may not have two stores running concurrently, and it also means that an application may not start a store, shut it down, and then start it again. The store API is "single use".</p>
<p class="endli"></p>
</li>
<li>
The application may not set signal handlers for SIGPIPE, SIGUSR1, SIGINT, or SIGTERM. The store uses those signals. For applications that need to handle those signals, it is suggested that the application create a child process, as mentioned above (#1). </li>
</ol>
<p>For an example of how to use the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umestored__main_8h.html#ae0f0d211a889aee9ea3f4f57d4c75e3a">umestored_main()</a> API, see the example program <a href="../../example/umestored_example.c">umestored_example.c</a>. Note that while the callable store APIs are usable on all supported platforms, this example program is restricted to Linux due to its use of <code>prctl()</code>, a Linux-only function.</p>
<p><br />
 </p>
<h1><a class="anchor" id="persistencefaulttolerance"></a>
Persistence Fault Tolerance&nbsp;&nbsp;<small><a href="#persistencefaulttolerance">&lt;-</a></small></h1>
<p><br />
 </p>
<h2><a class="anchor" id="messagelossrecovery"></a>
Message Loss Recovery&nbsp;&nbsp;<small><a href="#messagelossrecovery">&lt;-</a></small></h2>
<p>Persistence offers the following message recovery mechanisms:</p>
<table class="doxtable">
<tr>
<th>Method </th><th>Product </th><th>Transports </th><th><p class="starttd">Description</p>
<p class="endtd"></p>
</th></tr>
<tr>
<td>Negative Acknowledgments (NAKs) </td><td>UMS, UMP, UMQ </td><td>LBT-RM, LBT-RU </td><td><p class="starttd">Recovers lost transport datagrams from the source which may contain many small topic messages or fragments of a large message. Receivers send unicast NAKs to the source for missed transport datagrams. Source retransmits datagrams over the configured UM transport.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Late Join </td><td>UMS, UMP, UMQ </td><td>All </td><td><p class="starttd">Retransmits messages via unicast to receivers joining the stream after the messages were originally sent. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/design.tag:../../Design/" href="../../Design/umfeatures.html#usinglatejoin">Using Late Join</a>.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Durable Receiver Recovery </td><td>UMP, UMQ </td><td>All </td><td><p class="starttd">Recovers messages persisted while a durable receiver was off line. UM initiates recovery when a durable receiver joins a persistent stream. The receiver then requests retransmission from the store starting with the low sequence number, defined as the last message it acknowledged to the store plus one. The store unicasts retransmissions. See <a class="el" href="index.html#persistentreceiverrecovery">Persistent Receiver Recovery</a>.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Off Transport Recovery </td><td>UMS, UMP, UMQ </td><td>All </td><td><p class="starttd">Recovers lost topic messages. Receiver detects lost sequence number and requests retransmission from the source or persistent stores (if applicable). UM unicasts retransmissions. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/design.tag:../../Design/" href="../../Design/umfeatures.html#offtransportrecoveryotr">Off-Transport Recovery (OTR)</a>.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Proactive Retransmissions </td><td>UMP, UMQ </td><td>All </td><td>Recovers lost messages never received by the store or never acknowledged by the store. Operates independently of any receivers. Source unicasts retransmissions. See <a class="el" href="index.html#proactiveretransmissions">Proactive Retransmissions</a>. </td></tr>
</table>
<p><br />
 </p>
<h2><a class="anchor" id="configuringforpersistenceandrecovery"></a>
Configuring for Persistence and Recovery&nbsp;&nbsp;<small><a href="#configuringforpersistenceandrecovery">&lt;-</a></small></h2>
<p>Deployment decisions play a huge role in the success of any persistent system. Configuration in UM has a number of options that aid in performance, fault recovery, and overall system stability. It is not possible, or at least not wise, to totally divorce configuration from application development for high performance systems. This is true not only for persistent systems, but for practically all distributed systems. When designing systems, deployment considerations need to be taken into account for the following:</p>
<ul>
<li>
<p class="startli">Source Considerations</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Receiver Considerations</p>
<p class="endli"></p>
</li>
<li>
Store Configuration Considerations </li>
</ul>
<p><br />
 </p>
<h3><a class="anchor" id="sourceconsiderations"></a>
Source Considerations&nbsp;&nbsp;<small><a href="#sourceconsiderations">&lt;-</a></small></h3>
<p>Performance of sources is heavily impacted by:</p>
<ul>
<li>
<p class="startli">the release policy that the source uses</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">streaming methods of the source</p>
<p class="endli"></p>
</li>
<li>
the throughput and latency requirements of the data </li>
</ul>
<p>Source release settings have a direct impact on memory usage. As messages are retained, they consume memory. You reclaim memory when you release messages. Message stability, delivery confirmation and retention size all interact to create your release policies. UM provides a hard limit on the memory usage. When exceeded, UM delivers a Forced Reclamation event. Thus applications that anticipate forced reclamations can handle them appropriately. See also <a class="el" href="index.html#sourcemessageretentionandrelease">Source Message Retention and Release</a>.</p>
<p>How the source streams data has a direct impact on latency and throughput. One streaming method sets a maximum, outstanding count of messages. Once reached, the source does not send any more until message stability notifications come in to reduce the number of outstanding messages. The umesrc example program uses this mechanism to limit the speed of a source to something a store can handle comfortably. This also provides a maximum bound on recovery that can simplify handling of streaming source recovery.</p>
<p>The throughput and latency requirements of the data are normal UM concerns.</p>
<p><br />
 </p>
<h3><a class="anchor" id="receiverconsiderations"></a>
Receiver Considerations&nbsp;&nbsp;<small><a href="#receiverconsiderations">&lt;-</a></small></h3>
<p>In addition to the following, receiver performance shares the same considerations as receivers during normal operation.</p>
<p><b>Acknowledgement Generation</b></p>
<p>Persistent receivers send a message consumption acknowledgement to stores and the message source. Some applications may want to control this acknowledgement explicitly themselves. In this case, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeexplicitackonlyreceiver">ume_explicit_ack_only (receiver)</a> can be used.</p>
<p><b>Controlling Retransmission</b></p>
<p>Persistent receivers during fault recovery are another matter entirely. Receivers send retransmission requests and receive and process retransmissions. Control over this process is crucial when handling very long recoveries, such as hundreds of thousands or millions of messages. A receiver only sends a certain number of retransmission requests at a time.</p>
<p>This means that a receiver will not, unless configured to with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grplatejoin.html#retransmitrequestoutstandingmaximumreceiver">retransmit_request_outstanding_maximum (receiver)</a>, request everything at once. The value of the low sequence number (<a class="el" href="index.html#persistentreceiverrecovery">Persistent Receiver Recovery</a>) has a direct impact on how many requests need to be handled. A receiving application can decide to only handle the last X number of messages instead of recovering them all using the option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grplatejoin.html#retransmitrequestmaximumreceiver">retransmit_request_maximum (receiver)</a>. The timeout used between requests, if the retransmission does not arrive, is totally controllable with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grplatejoin.html#retransmitrequestintervalreceiver">retransmit_request_interval (receiver)</a>. And the total time given to recover all messages is also controllable.</p>
<p><b>Recovery Process</b></p>
<p>Theoretically, receivers can handle up to roughly 2 billion messages during recovery. This limit is implied from the sequence number arithmetic and not from any other limitation. For recovery, the crucial limiting factor is how a receiver processes and handles retransmissions which come in as fast as UM can request them and a store can retransmit them. This is perhaps much faster than an application can handle them. In this case, it is crucial to realize that as recovery progresses, the source may still be transmitting new data. This data will be buffered until recovery is complete and then handed to the application. It is prudent to understand application processing load when planning on how much recovery is going to be needed and how it may need to be configured within UM.</p>
<p><br />
 </p>
<h3><a class="anchor" id="storeconfigurationconsiderations"></a>
Store Configuration Considerations&nbsp;&nbsp;<small><a href="#storeconfigurationconsiderations">&lt;-</a></small></h3>
<p>UM stores have numerous configuration options. See <a class="el" href="index.html#configurationreferenceforumestored">Configuration Reference for Umestored</a> for details.</p>
<p><b>Configuring Store Usage per Source</b></p>
<p>A store handles persisted state on a per topic per source basis. Based on the load of topics and sources, it may be prudent to spread the topic space, or just source space, across stores as a way to handle large loads. As configuration of store usage is per source, this is extremely easy to do. It is easy to spread CPU load via multi-threading as well as hard disk usage across stores. A single store process can have a set of virtual stores within it, each with their own thread.</p>
<p><b>Disk vs. Memory</b></p>
<p>As mentioned previously in <a class="el" href="index.html#persistentstoreconcept">Persistent Store Concept</a>, stores can be memory based or disk based. Disk stores also have the ability to spread hard disk usage across multiple physical disks by using multiple virtual stores within a single store process. This gives great flexibility on a per source basis for spreading data reception and persistent data load.</p>
<p>UM stores provide settings for controlling memory usage and for caching messages for retransmission in memory as well as on disk. All messages in a store, whether in memory or on disk, have some small memory state. This is roughly about 72 bytes per message. For very large caches of messages, this can become non-trivial in size.</p>
<p><b>Activity Timeouts</b></p>
<p>UM stores are NOT archives and are not designed for archival. Stores persist source and receiver state with the aim of providing fault recovery. Central to this is the concept that a source or receiver has an activity timeout attached to it. Once a source or receiver suspends operation or has a failure, it has a set time before the store will forget about it. This activity timeout needs to be long enough to handle the recovery demands of sources and receivers. However, it can not and should not be infinite. Each source takes up memory and disk space, therefore an appropriate timeout should be chosen that meets the requirements of recovery, but is not excessively long so that the limited resources of the store are exhausted.</p>
<p><b>Recommendations for Store Configuration</b></p>
<p>The following conditions allow sources to continue to send messages:</p>
<ul>
<li>
<p class="startli">Quorum - Completed registration of a quorum of stores within at least one group. This is affected by group definitions, plus intragroup and intergroup stability settings. See also <a class="el" href="index.html#persistentstoreconcept">Persistent Store Concept</a>.</p>
<p class="endli"></p>
</li>
<li>
Flight Size - Maximum number of messages sent but not stable which is determined by store group definitions, intragroup and intergroup stability settings and delivery confirmation setting. See also <a class="el" href="index.html#persistenceflightsize">Persistence Flight Size</a>. </li>
</ul>
<p>Configure your stores to address the failure cases you believe are more probable and from which you want to recover. For example, if a particular store group persists topics of higher importance, you may want to increase the number of stores in that group to maintain quorum in the face of a store failure. Or if a particular location has a higher incidence of failures than other locations, you may want to add additional stores in other locations.</p>
<p>Although many different conditions and requirements can apply to the configuration of persistent stores, Informatica recommends the following best practices:</p>
<ol>
<li>
<p class="startli">Minimum of 3 stores - Requiring a minimum of 3 stores needed for quorum in a single store group is optimal. Using 5 stores, for example, in a group allows sources to keep sending in the face of the loss of up to 2 stores.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Multiple store groups - When using multiple store groups, Informatica recommends using at least 3 stores in each group.</p>
<p class="endli"></p>
</li>
<li>
Set Intergroup Stability to all-active. This setting for <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeretentionintergroupstabilitybehaviorsource">ume_retention_intergroup_stability_behavior (source)</a> provides a more immediate evaluation of your store configuration. Active groups must have at least a quorum of active stores, registered with the source and sending stability acknowledgements for persisted messages. By default, if a store becomes unresponsive, a store group could lose quorum and therefore messages in-flight cannot be stabilized by the unresponsive store's group until the store's <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umestoreactivitytimeoutsource">ume_store_activity_timeout (source)</a> expires and the store restarts. However, with all-active, the source does not wait for the unresponsive store's <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umestoreactivitytimeoutsource">ume_store_activity_timeout (source)</a> to expire. The source removes the unresponsive store's group from the list of stores from which the source uses to determine that messages in-flight are stable. An inactive store with a running activity timeout does not impede message stabilization. </li>
</ol>
<p><b>Store Configuration Practices to Avoid</b></p>
<p>Informatica does not support the following store configuration practices:</p>
<ul>
<li>
<p class="startli">Do not use multiple store groups of one store each. Recovery does not work well in this configuration because it allows sources to resume sending as soon as it has registered with a single store, and if that store is not fully up-to-date, this can lead to message loss for receivers.</p>
<p class="endli"></p>
</li>
<li>
Do not use backup stores. The configuration option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umestoregroupsource">ume_store_group (source)</a> allows you to identify a store group and its size in number of stores. Setting the group size in this option to a number of stores less than the number of stores configured with the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umestoresource">ume_store (source)</a> option can lead to messages that were reported stable to the source being unavailable for receivers to recover, in the event that multiple stores became unresponsive and were replaced by backup stores. For example, setting <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umestoregroupsource">ume_store_group (source)</a> with a size of 3 stores, but configuring ume_store with 5 stores is not supported. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="persistenceproxysources"></a>
Persistence Proxy Sources&nbsp;&nbsp;<small><a href="#persistenceproxysources">&lt;-</a></small></h2>
<p>By default, UM expects persistent sources to be running concurrently with persistent receivers. If a source exits, any persistent receivers will disconnect from that source's transport and will wait for the source to come back. More significantly, if a new receiver starts while the source is absent, the receiver will be unable to discover the stores where the old source's previous messages are stored. So that late-joining receiver will not recover messages until the source finally restarts.</p>
<p>The Proxy Source feature allows you to configure stores to automatically continue sending the source's topic advertisements which allow new receivers to join the source's transport session and request Source Registration Information (SRI) to register with the store and request retransmissions. After the source returns, the store automatically stops acting as a proxy source. Stores can be located across a UM Router or within the same LAN as the failed source.</p>
<p>Some other features of Proxy Sources include:</p>
<ul>
<li>
<p class="startli">Requires a Quorum/Consensus store configuration.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Normal store failover operation also initiates a new proxy source.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">A store can be running more than one proxy source if more than one source has failed.</p>
<p class="endli"></p>
</li>
<li>
A store can be running multiple proxy sources for the same topic, each one corresponding to a previous instance of a real source. </li>
</ul>
<p>Note that proxy sources do introduce extra network and CPU loading, so proxy sources should only be enabled if their functionality is needed.</p>
<p><br />
 </p>
<h3><a class="anchor" id="howproxysourcesoperate"></a>
How Proxy Sources Operate&nbsp;&nbsp;<small><a href="#howproxysourcesoperate">&lt;-</a></small></h3>
<p>The following sequence illustrates the life of a proxy source:</p>
<ol>
<li>
<p class="startli">A source configured for Proxy Source sends to receivers and a group of Quorum/Consensus stores.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The source fails.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The source's <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeactivitytimeoutsource">ume_activity_timeout (source)</a> or the store's <a class="el" href="index.html#umecfgsourceactivitytimeout">source-activity-timeout</a> expires.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The Quorum/Consensus stores elect a single store to run the proxy source.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The elected store creates a proxy source and sends topic advertisements.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The failed source reappears.</p>
<p class="endli"></p>
</li>
<li>
The store deletes the proxy source and the original source resumes activity. </li>
</ol>
<p>If the store running the proxy source fails, the other stores in the Quorum/Consensus group detect a source failure again and elect a new store to initiate a proxy source.</p>
<p>If a loss of quorum occurs, the proxy source can continue to send advertisements, but cannot send messages until a quorum is re-established.</p>
<p><br />
 </p>
<h3><a class="anchor" id="activitytimeoutandstatelifetimes"></a>
Activity Timeout and State Lifetimes&nbsp;&nbsp;<small><a href="#activitytimeoutandstatelifetimes">&lt;-</a></small></h3>
<p>UM provides activity and state lifetime timers for sources and receivers that operate in conjunction with the proxy source option or independently. This section explains how these timers work together and how they work with proxy sources.</p>
<p>The <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeactivitytimeoutsource">ume_activity_timeout (source)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeactivitytimeoutreceiver">ume_activity_timeout (receiver)</a> options determine how long a source or receiver must be inactive before a store allows another source or receiver to register using that RegID. This prevents a second source or receiver from stealing a RegID from an existing source or receiver. An activity timeout can be configured for the source/receiver with the UM Configuration Option cited above or with a topic's <a class="el" href="index.html#umecfgumeattributes">ume-attribute</a> configured in the umestored XML configuration file. The following diagram illustrates the default activity timeout behavior, which uses <a class="el" href="index.html#umecfgsourcestatelifetime">source-state-lifetime</a> in the umestored XML configuration file.</p>
<div class="image">
<img src="source_act_timeout_def.png" alt="source_act_timeout_def.png"/>
</div>
 <p>In addition to the activity timeout, you can also configure sources and receivers with a state lifetime timer using the following options.</p>
<ul>
<li>
<p class="startli"><a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umestatelifetimesource">ume_state_lifetime (source)</a></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umestatelifetimereceiver">ume_state_lifetime (receiver)</a></p>
<p class="endli"></p>
</li>
<li>
The topic's ume-attributes options, <a class="el" href="index.html#umecfgsourcestatelifetime">source-state-lifetime</a> and <a class="el" href="index.html#umecfgreceiverstatelifetime">receiver-state-lifetime</a>. </li>
</ul>
<p>The <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umestatelifetimesource">ume_state_lifetime (source)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umestatelifetimereceiver">ume_state_lifetime (receiver)</a> options, when used in conjunction with the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeactivitytimeoutsource">ume_activity_timeout (source)</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeactivitytimeoutreceiver">ume_activity_timeout (receiver)</a> options, determines at what point UM removes the source or receiver state files. UM does not check the state lifetime until the activity timeout expires. The following diagram illustrates this behavior:</p>
<div class="image">
<img src="source_state_lifetime.png" alt="source_state_lifetime.png"/>
</div>
 <p>If you have enabled the Proxy Source option, the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeactivitytimeoutsource">ume_activity_timeout (source)</a> triggers the creation of the proxy source. The following diagram illustrates this behavior:</p>
<div class="image">
<img src="src_act_and_state_timers.png" alt="src_act_and_state_timers.png"/>
</div>
 <p><br />
 </p>
<h3><a class="anchor" id="enablingtheproxysources"></a>
Enabling the Proxy Sources&nbsp;&nbsp;<small><a href="#enablingtheproxysources">&lt;-</a></small></h3>
<p>You must configure both the source and the stores to enable the Proxy Source option.</p>
<ul>
<li>
<p class="startli">Configure the source in a UM Configuration File with the source configuration option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeproxysourcesource">ume_proxy_source (source)</a>.</p>
<p class="endli"></p>
</li>
<li>
Configure the stores in the umestored XML configuration file with the Store Element Option, <a class="el" href="index.html#umecfgallowproxysource">allow-proxy-source</a>. </li>
</ul>
<p><br />
 </p>
<h3><a class="anchor" id="proxysourceelections"></a>
Proxy Source Elections&nbsp;&nbsp;<small><a href="#proxysourceelections">&lt;-</a></small></h3>
<p>When multiple stores in a Quorum/Consensus configuration notice the loss of a registered source (expiration of the source's <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeactivitytimeoutsource">ume_activity_timeout (source)</a>) configured for proxy sources, only one of the stores needs to create a proxy source to continue sending topic advertisements.</p>
<p>The proxy source election process determines which store creates the proxy source. Each store starts by waiting a randomized amount of time based on its <a class="el" href="index.html#umecfgproxyelectioninterval">proxy-election-interval</a> option setting. The store creates a proxy source if it has not received a persistent registration request (PREG) from a proxy on a different store. The proxy source then sends a PREG containing a unique random value to the other stores. This value determines which store deletes it's proxy source in the case that any two stores independently determine they should create a proxy source. The nature of the random values ensures that only one store within the Q/C group or configuration of groups keeps its proxy source.</p>
<p><br />
 </p>
<h3><a class="anchor" id="proactiveretransmissions"></a>
Proactive Retransmissions&nbsp;&nbsp;<small><a href="#proactiveretransmissions">&lt;-</a></small></h3>
<p>Proactive Retransmissions, which is enabled by default, address two types of loss:</p>
<ul>
<li>
<p class="startli">loss of message data between the source and a store</p>
<p class="endli"></p>
</li>
<li>
loss of stability acknowledgments (ACK) between the store and the source </li>
</ul>
<p>The store sends message stability acknowledgments to the source after the store persists the message data.</p>
<p>With Proactive Retransmissions, the source maintains an unstable message queue for those messages sent but not acknowledged by the store. The source checks this queue at the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umemessagestabilitytimeoutsource">ume_message_stability_timeout (source)</a>. If a message in this queue exceeds its <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umemessagestabilitytimeoutsource">ume_message_stability_timeout (source)</a>, the source retransmits the message and puts it back on the unstabilized message queue, restarting the message's <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umemessagestabilitytimeoutsource">ume_message_stability_timeout (source)</a>.</p>
<p>The source continues to retransmit and check the message's stability timeout until the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umemessagestabilitylifetimesource">ume_message_stability_lifetime (source)</a> expires or it receives a stability acknowledgment from the store. If the source has not received a stability acknowledgment when the <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umemessagestabilitylifetimesource">ume_message_stability_lifetime (source)</a> expires, the source sends a Store Message Not Stable source event notification to the application. When the store discards the message because it has not met stability requirements, the store sends a Store Forced Reclaim source event notification to the application.</p>
<p>To disable Proactive Retransmissions, set <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umemessagestabilitytimeoutsource">ume_message_stability_timeout (source)</a> to 0 (zero). As a result, sources do not create an unstable message queue.</p>
<p>The following applies whether you enable or disable Proactive Retransmissions.</p>
<ul>
<li>
<p class="startli">The store does not discard duplicate messages, but rather always responds to duplicate, retransmitted messages by sending stability acknowledgments even if the message is already stable.</p>
<p class="endli"></p>
</li>
<li>
If the store has marked the message unrecoverably lost and receives a duplicate message from the source, the store sends the source a negative stability acknowledgment (NAK), which induces the source to remove the message from its unstabilized message queue. A stability NAK is identical to a stability ACKs except that it has a NAK flag set. </li>
</ul>
<p><br />
 </p>
<h1><a class="anchor" id="manpagesforstore"></a>
Man Pages for Store&nbsp;&nbsp;<small><a href="#manpagesforstore">&lt;-</a></small></h1>
<p>There are two executables for the Store, each with it's own man page: </p><ul>
<li>
<a class="el" href="index.html#umestoredmanpage">Umestored Man Page</a> - Unix and Windows command-line interface. </li>
<li>
<a class="el" href="index.html#umestoredsmanpage">Umestoreds Man Page</a> - Windows service interface. </li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="umestoredmanpage"></a>
Umestored Man Page&nbsp;&nbsp;<small><a href="#umestoredmanpage">&lt;-</a></small></h2>
<p>The umestored executable can be run interactively from a command prompt or from a script/batch file. For use as a Windows Service, see <a class="el" href="index.html#umestoredsmanpage">Umestoreds Man Page</a>.</p>
<pre class="fragment">UMP Store daemon
Usage: umestored [options] configfile
Available options:
  -h, --help            display this help and exit
  -d, --dump-dtd        dump DTD to stdout
  -f, --detach          detach from terminal (not supported on Windows)
  -v, --validate        validate config, but do not run</pre><dl class="section user"><dt>Description</dt><dd>Persistent Store services are provided by umestored.</dd></dl>
<dl class="section user"><dt></dt><dd>The <code>configfile</code> parameter is required and specifies the Store's XML configuration file.</dd></dl>
<dl class="section user"><dt></dt><dd>The DTD used to validate a configuration file will be dumped to standard output with the -d or <code>--dump-dtd</code>. After dumping the DTD, umestored exits instead of providing persistence services as usual.</dd></dl>
<dl class="section user"><dt></dt><dd>The configuration file will be validated against the DTD if either the <code>-v</code> or <code>--validate</code> options are given. After attempting validation, umestored exits instead of providing persistence services as usual. The exit status will be 0 for a configuration file validated by the DTD and non-zero otherwise.</dd></dl>
<dl class="section user"><dt></dt><dd>Umestored normally remains attached to the controlling terminal and runs until interrupted. If the <code>-f</code> or <code>--detach</code> options are given, umestored instead forks, detaches the child from the controlling terminal, and the parent exits immediately.</dd></dl>
<dl class="section user"><dt></dt><dd>Command line help is available with -h.</dd></dl>
<dl class="section user"><dt><b>Usage</b> <b>Notes</b> </dt><dd>When shutting down the UM Persistent Store daemon, use a SIGINT to trigger a clean shutdown, which attempts to cleanly finish outstanding IO requests before shutting down. Two successive SIGINTs force an immediate shutdown (not recommended unless absolutely necessary).</dd></dl>
<dl class="section user"><dt><b>Exit</b> <b>Status</b> </dt><dd>The exit status from umestored is 0 for success and some non-zero value for failure.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="umestoredsmanpage"></a>
Umestoreds Man Page&nbsp;&nbsp;<small><a href="#umestoredsmanpage">&lt;-</a></small></h2>
<p>The umestoreds executable is for use as a Windows Service. The service can be installed as a service by the Windows package installer.</p>
<p>Alternatively, the umestoreds executable can be run interactively from a command prompt to install the service or to change certain configuration elements. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/operations.tag:../../Operations/" href="../../Operations/startupshutdownprocedures.html#umdaemonsaswindowsservices">UM Daemons as Windows Services</a> for more details.</p>
<pre class="fragment">UMP Store service
Usage: umestoreds [options] [configfile]
Available options:
  -h, --help              display this help and exit
  -d, --dump-dtd          dump DTD to stdout
  -s, --service=install   install the service passing configfile
  -s, --service=remove    delete/remove the service
  -s, --service=config    update configfile info to use configfile passed
  -v, --validate          validate config, but do not run
  -e, --event-log-level   Update/set service logging level.  This is the minimum logging
                          level to send to the Windows event log.  Valid values are:
                             NONE - Send no events
                             INFO
                             WARN - default
                             ERROR
  configfile              XML config file (if not present, looks in registry)</pre><dl class="section user"><dt><b>Description</b> </dt><dd>Persistent Store services are provided by the umestoreds Windows Service.</dd></dl>
<dl class="section user"><dt></dt><dd>The <code>configfile</code> parameter is used interactively to configure the Store's XML configuration file.</dd></dl>
<dl class="section user"><dt></dt><dd>The DTD used to validate a configuration file will be dumped to standard output with the <code>-d</code> or <code>--dump-dtd</code>. After dumping the DTD, umestoreds exits instead of providing persistence services as usual.</dd></dl>
<dl class="section user"><dt></dt><dd>The configuration file will be validated against the DTD if either the <code>-v</code> or <code>--validate</code> options are given. After attempting validation, umestoreds exits instead of providing persistence services as usual. The exit status will be 0 for a configuration file validated by the DTD and non-zero otherwise.</dd></dl>
<dl class="section user"><dt></dt><dd>The <code>-s</code> is used interactively to control the installation of the Windows service. The <code>-e</code> is used interactively to configure the logging threshold for writing to the Windows Event Log. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/operations.tag:../../Operations/" href="../../Operations/startupshutdownprocedures.html#umdaemonsaswindowsservices">UM Daemons as Windows Services</a> for more details.</dd></dl>
<dl class="section user"><dt></dt><dd>Command line help is available with -h.</dd></dl>
<dl class="section user"><dt><b>Usage</b> <b>Notes</b> </dt><dd>When installing the UM Persistent Store as a Microsoft Windows service, use only local disk devices and fully qualified path names for all filenames. This is because Windows services run by default under a Local System account, which has reduced privileges and is not allowed access to network devices.</dd></dl>
<dl class="section user"><dt></dt><dd>Stopping the UM Persistent Store service triggers a clean shutdown, which attempts to cleanly finish outstanding IO requests before shutting down.</dd></dl>
<dl class="section user"><dt><b>Exit</b> <b>Status</b> </dt><dd>The exit status from umestored is 0 for success and some non-zero value for failure.</dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="configurationreferenceforumestored"></a>
Configuration Reference for Umestored&nbsp;&nbsp;<small><a href="#configurationreferenceforumestored">&lt;-</a></small></h1>
<p>The operating parameters for umestored come from an XML configuration file that must be supplied on the command line (see <a class="el" href="index.html#manpagesforstore">Man Pages for Store</a>. Umestored contains a UM context and receivers that may be configured with default values through a UM configuration file referenced in the XML configuration file. Default UM options my be overridden for each configured store using the XML configuration file.</p>
<p>You configure umestored to instantiate stores with the umestored XML configuration file, which Ultra Messaging reads at start up.</p>
<p>The umestored XML configuration file for persistence has the following sections.</p>
<ul>
<li>
<p class="startli">Daemon section - holds administrative parameters for such things as the location of log files, the UM Configuration File, etc.</p>
<p class="endli"></p>
</li>
<li>
Stores section - holds parameters for any persistent stores and also the topics to be persisted. </li>
</ul>
<p><b>High Level Store Configuration File:</b></p>
<pre class="fragment">&lt;ume-store version="1.3"&gt;
  &lt;daemon&gt;
    Daemon configuration options
  &lt;/daemon&gt;
  &lt;stores&gt;
    &lt;store attributes&gt;
      &lt;topics&gt;
        &lt;topic attributes&gt;
          &lt;ume-attributes&gt;
            &lt;option attributes/&gt;
          &lt;/ume-attributes&gt;
        &lt;/topic&gt;
      &lt;/topics&gt;
    &lt;/store&gt;
  &lt;/stores&gt;
&lt;/ume-store&gt;
</pre><p><br />
 </p>
<h2><a class="anchor" id="daemonelement"></a>
Daemon Element&nbsp;&nbsp;<small><a href="#daemonelement">&lt;-</a></small></h2>
<p>The following table presents child elements allowed in the daemon configuration section.</p>
<table class="doxtable">
<tr>
<th>Tag </th><th>Description </th><th><p class="starttd">Default Value</p>
<p class="endtd"><a class="anchor" id="umecfglog"></a></p>
</th></tr>
<tr>
<td>log </td><td>Required. Pathname for log file. </td><td><p class="starttd">None - this is a required element.</p>
<p class="endtd"><a class="anchor" id="umecfguid"></a></p>
</td></tr>
<tr>
<td>uid </td><td>User ID (uid) for daemon process (if started as root) </td><td><p class="starttd">Daemon retains starting uid</p>
<p class="endtd"><a class="anchor" id="umecfgpidfile"></a></p>
</td></tr>
<tr>
<td>pidfile </td><td>Pathname for daemon process ID (pid) file </td><td><p class="starttd">No pidfile</p>
<p class="endtd"><a class="anchor" id="umecfggid"></a></p>
</td></tr>
<tr>
<td>gid </td><td>Group ID (gid) for daemon process (if started as root) </td><td><p class="starttd">Daemon retains starting gid</p>
<p class="endtd"><a class="anchor" id="umecfglbmconfig"></a></p>
</td></tr>
<tr>
<td>lbm-config </td><td>Pathname for UM configuration file </td><td><p class="starttd">No config file; use UM defaults</p>
<p class="endtd"><a class="anchor" id="umecfgxmlconfig"></a></p>
</td></tr>
<tr>
<td>xml-config </td><td>Pathname for UM XML configuration file </td><td><p class="starttd">No config file; use UM defaults</p>
<p class="endtd"><a class="anchor" id="umecfglbmlicensefile"></a></p>
</td></tr>
<tr>
<td>lbm-license-file </td><td>Pathname for UM license file </td><td><p class="starttd">License read from environment</p>
<p class="endtd"><a class="anchor" id="umecfgwebmonitor"></a></p>
</td></tr>
<tr>
<td>web-monitor </td><td><p class="starttd">Address:port where web monitor listens. Address of '*' listens on all interfaces. Also has a single attribute, <code>permission</code>, with allowable values: <code>"read-only"</code> and <code>"read-write"</code>. Using read-only disables the text fields and buttons on a Web Monitor "debug page" that can only be enabled by Informatica Support. Example: *:15304</p>
<p>Omit this element to disable the web monitor.</p>
<p class="endtd">See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/design.tag:../../Design/" href="../../Design/fundamentalconcepts.html#webmonsecurity">Webmon Security</a> for important security information. </p>
</td><td><p class="starttd">No web monitor</p>
<p class="endtd"><a class="anchor" id="umecfgdaemonmonitor"></a></p>
</td></tr>
<tr>
<td>daemon-monitor </td><td>configuration for <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/design.tag:../../Design/" href="../../Design/umobjects.html#daemonstatistics">Daemon Statistics</a>. </td></tr>
</table>
<p><br />
 </p>
<h3><a class="anchor" id="logelement"></a>
Log Element&nbsp;&nbsp;<small><a href="#logelement">&lt;-</a></small></h3>
<p>The Log Element defines how the store daemon writes log messages during operation.</p>
<p>The following table gives attributes for the <code>&lt;log&gt;</code> element:</p>
<table class="doxtable">
<tr>
<th>Attribute </th><th>Description </th><th>Default Value </th></tr>
<tr>
<td>type </td><td>One of "file", "console". </td><td>"console" </td></tr>
<tr>
<td>size </td><td>Number of millions of bytes of file size to roll log file. E.g. a value of 1 rolls after 1000000 bytes. Maximum value is 4000. Value of 0 disables rolling by file size. Only applicable for <code>type="file"</code>. </td><td>0 </td></tr>
<tr>
<td>frequency </td><td>Frequency by which to roll log file. Choices are <br />
&#160;&#160;<code>daily</code> - Roll log file at midnight. <br />
&#160;&#160;<code>hourly</code> - Roll log file after approximately an hour, but is not exact and can drift significantly over a period of time. <br />
&#160;&#160;<code>test</code> - For internal Informatica testing and should not be used. <br />
&#160;&#160;<code>disable</code> - Do not roll log file by frequency. <br />
Only applicable for <code>type="file"</code> </td><td><code>disable</code> </td></tr>
</table>
<p><br />
 </p>
<h3><a class="anchor" id="daemonmonitorelement"></a>
Daemon-monitor Element&nbsp;&nbsp;<small><a href="#daemonmonitorelement">&lt;-</a></small></h3>
<p>The daemon-monitor element configures the store daemon for <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/design.tag:../../Design/" href="../../Design/umobjects.html#daemonstatistics">Daemon Statistics</a>.</p>
<p>See <a class="el" href="index.html#storedaemonstatisticsconfiguration">Store Daemon Statistics Configuration</a> for an example of configuring.</p>
<p>The following table gives attributes for the <code>&lt;daemon-monitor&gt;</code> element:</p>
<table class="doxtable">
<tr>
<th>Attribute </th><th>Description </th><th>Default Value </th></tr>
<tr>
<td>topic </td><td>topic name for used to publish daemon statistics. </td><td>umestore.monitor </td></tr>
</table>
<p>The following table presents child elements allowed in the daemon-monitor configuration section.</p>
<table class="doxtable">
<tr>
<th>Tag </th><th>Description </th><th><p class="starttd">Default Value</p>
<p class="endtd"><a class="anchor" id="dmoncfglbmconfig"></a></p>
</th></tr>
<tr>
<td>lbm-config </td><td>Optional LBM configuration file for the monitoring context. </td><td><p class="starttd">Defaults to LBM settings set by the daemon element's <a class="el" href="index.html#umecfglbmconfig">lbm-config element</a>.</p>
<p class="endtd"><a class="anchor" id="dmoncfgpublishinginterval"></a></p>
</td></tr>
<tr>
<td>publishing-interval </td><td>optional element which sets the interval for message publication. </td><td><p class="starttd">Defaults to not publishing.</p>
<p class="endtd"><a class="anchor" id="dmoncfgremotesnapshotrequest"></a></p>
</td></tr>
<tr>
<td>remote-snapshot-request </td><td>Controls if the daemon will respond to requests from monitoring applications. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/design.tag:../../Design/" href="../../Design/umobjects.html#daemonstatisticsrequests">Daemon Statistics Requests</a>. </td><td><p class="starttd">Defaults to disabled.</p>
<p class="endtd"><a class="anchor" id="dmoncfgremoteconfigchangesrequest"></a></p>
</td></tr>
<tr>
<td>remote-config-changes-request </td><td>Controls if the daemon will respond to change requests from monitoring applications. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/design.tag:../../Design/" href="../../Design/umobjects.html#daemonstatisticsrequests">Daemon Statistics Requests</a>. </td><td>Defaults to disabled. </td></tr>
</table>
<p><br />
 </p>
<h3><a class="anchor" id="publishingintervalelement"></a>
Publishing-interval Element&nbsp;&nbsp;<small><a href="#publishingintervalelement">&lt;-</a></small></h3>
<p>Element which sets the publishing intervals for desired message types. The desired message types must be listed as <code>&lt;group&gt;</code> sub-elements of the <code>&lt;publishing-interval&gt;</code> element.</p>
<p>See <a class="el" href="index.html#storedaemonstatisticsconfiguration">Store Daemon Statistics Configuration</a> for an example of configuring.</p>
<p>The following table presents child elements allowed in the daemon-monitor configuration section.</p>
<table class="doxtable">
<tr>
<th>Tag </th><th>Description </th><th><p class="starttd">Default Value</p>
<p class="endtd"><a class="anchor" id="dmoncfggroup"></a></p>
</th></tr>
<tr>
<td>group </td><td>Identifies the grouping of message type(s) and their publishing intervals. </td><td>Any grouping of message type(s) not listed default to not publishing. </td></tr>
</table>
<p><br />
 </p>
<h3><a class="anchor" id="groupelement"></a>
Group Element&nbsp;&nbsp;<small><a href="#groupelement">&lt;-</a></small></h3>
<p>The group element identifies the grouping of message type(s) and their publishing interval.</p>
<p>The following table gives attributes for the <code>&lt;group&gt;</code> element:</p>
<table class="doxtable">
<tr>
<th>Attribute </th><th>Description </th><th>Default Value </th></tr>
<tr>
<td>name </td><td>one of the following: <ul>
<li>
<code>"default"</code> - sets a default interval for all message types. </li>
<li>
<code>"store"</code> - sets the interval for messages of type <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#aeeb55ed0b759e6316cdedc3c990dfe26">umestore_store_dmon_stat_msg_t</a>. </li>
<li>
<code>"source"</code> - sets the interval for messages of type <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#a88ce572fd35203194ada676661d2f54b">umestore_repo_dmon_stat_msg_t</a>. </li>
<li>
<code>"receiver"</code> - sets the interval for messages of type <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#a3829efae398d994795fb395097626709">umestore_rcv_dmon_stat_msg_t</a>. </li>
<li>
<code>"disk"</code> - sets the interval for messages of type <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#a3ed32f1017abda98dbac7f228d7c506b">umestore_disk_dmon_stat_msg_t</a>. </li>
<li>
<code>"config"</code> - sets the interval for messages of types <code>umestore_*_dmon_config_msg_t</code>. </li>
<li>
<code>"memory"</code> - sets the interval for messages of type <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#a0f08c3244acc64f54edb6e5897477121">umestore_smart_heap_dmon_stat_msg_t</a>. </li>
</ul>
</td><td>Required attribute (no default). </td></tr>
<tr>
<td>ivl </td><td>Time interval in seconds. </td><td>Required attribute (no default) </td></tr>
</table>
<p><br />
 </p>
<h2><a class="anchor" id="storeselement"></a>
Stores Element&nbsp;&nbsp;<small><a href="#storeselement">&lt;-</a></small></h2>
<p>The Stores Element is a container for individual store elements which define specific store instances. The below is an example of a Stores Element.</p>
<pre class="fragment">  &lt;stores&gt;
    &lt;store name="test-store-1" port="14567"&gt;
      &lt;ume-attributes&gt; ... &lt;/ume-attributes&gt;
      &lt;topics&gt;
        &lt;topic pattern="quote.*" type="PCRE"&gt;
          &lt;ume-attributes&gt; ... &lt;/ume-attributes&gt;
        &lt;/topic&gt;
        &lt;topic pattern="subject.*" type="PCRE"&gt;
          &lt;ume-attributes&gt; ... &lt;/ume-attributes&gt;
        &lt;/topic&gt;
      &lt;/topics&gt;
    &lt;/store&gt;
    &lt;store name="test-store-2" port="14568"&gt;
      &lt;ume-attributes&gt; ... &lt;/ume-attributes&gt;
      &lt;topics&gt;
        &lt;topic pattern="issue.*" type="PCRE"&gt;
          &lt;ume-attributes&gt; ... &lt;/ume-attributes&gt;
        &lt;/topic&gt;
        &lt;topic pattern="topic.*" type="PCRE"&gt;
          &lt;ume-attributes&gt; ... &lt;/ume-attributes&gt;
        &lt;/topic&gt;
      &lt;/topics&gt;
    &lt;/store&gt;
  &lt;/stores&gt;
</pre><p><br />
 </p>
<h3><a class="anchor" id="storeelement"></a>
Store Element&nbsp;&nbsp;<small><a href="#storeelement">&lt;-</a></small></h3>
<p>The Store Element contains information about an individual store and has attributes, options and topics. See the example below.</p>
<pre class="fragment">  &lt;store name="test-store-1" port="14567"&gt;
    &lt;ume-attributes&gt; ... &lt;/ume-attributes&gt;
    &lt;topics&gt;
      &lt;topic pattern="quote.*" type="PCRE"&gt;
        &lt;ume-attributes&gt; ... &lt;/ume-attributes&gt;
      &lt;/topic&gt;
      &lt;topic pattern="subject.*" type="PCRE"&gt;
        &lt;ume-attributes&gt; ... &lt;/ume-attributes&gt;
      &lt;/topic&gt;
    &lt;/topics&gt;
  &lt;/store&gt;
</pre><p>The following table gives attributes for the <code>&lt;store&gt;</code> element:</p>
<table class="doxtable">
<tr>
<th>Attribute </th><th>Description </th><th><p class="starttd">Default Value</p>
<p class="endtd"></p>
</th></tr>
<tr>
<td>name </td><td>Name that identifies log messages for this store in the umestored log file. </td><td><p class="starttd">None—this is a required attribute</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>port </td><td>TCP port where umestored should listen for connection requests to this store. </td><td><p class="starttd">None—this is a required attribute</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>interface </td><td>Specifies the IP address over which umestored accepts connection requests for this store. You can specify a single IP address, such as 10.29.3.16, or a range of addresses, 10.29.3.16/25. See also <a class="el" href="index.html#identifyingpersistentstores">Identifying Persistent Stores</a> </td><td>0.0.0.0 (INADDR_ANY) </td></tr>
</table>
<p><b>Child Elements of the Store Element</b></p>
<p>The following table gives the child elements allowed in the store configuration section:</p>
<table class="doxtable">
<tr>
<th>Child Element </th><th>Description </th><th><p class="starttd">Default Value</p>
<p class="endtd"><a class="anchor" id="umecfgtopics"></a></p>
</th></tr>
<tr>
<td>topics </td><td>A container for topic elements. See <a class="el" href="index.html#topicselement">Topics Element</a> for more information. </td><td><p class="starttd">None</p>
<p class="endtd"><a class="anchor" id="umecfgumeattributes"></a></p>
</td></tr>
<tr>
<td>ume-attributes </td><td>A container for option elements. See <a class="el" href="index.html#optionsforastoresumeattributeselement">Options for a Store's ume-attributes Element</a> for more information. </td><td><p class="starttd">None</p>
<p class="endtd"><a class="anchor" id="storecfgpublishinginterval"></a></p>
</td></tr>
<tr>
<td>publishing-interval </td><td>optional element which sets the interval for message publication. </td><td>Defaults to not publishing. </td></tr>
</table>
<p><a class="anchor" id="optionsforastoresumeattributeselement"></a><b>Options for a Store's ume-attributes Element</b></p>
<p>Inside a '<code>&lt;ume-attributes&gt;</code>' section, options are set with one or more '<code>&lt;option ...&gt;</code>' elements. Each '<code>&lt;option ...&gt;</code>' element contains a '<code>type'</code> attribute, a '<code>name</code>' attribute, and a '<code>value</code>' attribute. The '<code>type</code>' attribute identifies the scope of the option (context, receiver, source, or store), the '<code>name</code>' attribute identifies the individual option being set, and the '<code>value</code>' attribute supplies the value.</p>
<p><b>Options for UM</b></p>
<p>Options with a type of "lbm-source", "lbm-receiver", or "lbm-context" are UM configuration options, which the store passes to the UM library.</p>
<p>For example, the option element: <br />
<code>&lt;option type="lbm-context" name="transport_lbtrm_receiver_socket_buffer" value="1048576"/&gt;</code> <br />
sets the UM configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grptransportlbtrmreliability.html#transportlbtrmreceiversocketbuffercontext">transport_lbtrm_receiver_socket_buffer (context)</a> (receiver socket buffer size for LBT-RM) to 1 megabyte.</p>
<p>See the <a href="../../Config/index.html">UM Configuration Guide</a> for the full list of UM configuration options.</p>
<dl class="section note"><dt>Note</dt><dd>Some UM options specify interfaces, which can be done by supplying the device name of the interface. Special care must be taken when supplying device names. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/generalconfigurationguidelines.html#interfacedevicenamesandxml">Interface Device Names and XML</a> for details.</dd></dl>
<p><b>Store Options</b></p>
<p>Store options without a type attribute or those explicitly given a type attribute of '<code>store</code>' simply configure the store itself.</p>
<p>For example, the option element: <br />
<code>&lt;option type="store" name="disk-cache-directory" value="cache"/&gt;</code> <br />
sets the store's disk cache directory.</p>
<p>The following table gives options allowed for a store element. Use the '<code>store</code>' option type for these options.</p>
<table class="doxtable">
<tr>
<td>Option </td><td>Description </td><td><p class="starttd">Default Value</p>
<p class="endtd"><a class="anchor" id="umecfgdiskcachedirectory"></a></p>
</td></tr>
<tr>
<td>disk-cache-directory </td><td>Pathname for disk store message cache directory. Must be between 1 and 230 characters long. </td><td><p class="starttd">umestored-cache</p>
<p class="endtd"><a class="anchor" id="umecfgdiskstatedirectory"></a></p>
</td></tr>
<tr>
<td>disk-state-directory </td><td>Pathname for disk store state directory. Must be between 1 and 230 characters long. </td><td><p class="starttd">umestored-state</p>
<p class="endtd"><a class="anchor" id="umecfgallowproxysource"></a></p>
</td></tr>
<tr>
<td>allow-proxy-source </td><td>Allows the store to act as a proxy source in case a registered source terminates. </td><td><p class="starttd">0 (Disable)</p>
<p class="endtd"><a class="anchor" id="umecfgcontextname"></a></p>
</td></tr>
<tr>
<td>context-name </td><td>Name of the store that can be used by sources to refer to the store instead of the address:port. Restricted to 128 characters in length, and may contain only alphanumeric characters, hyphens, and underscores. A store runs in its own context, so the store's context name can be used to identify the store. UM automatically resolves store names, which can facilitate persistent operation across the UM Router. A context name must be unique across the entire network and not be the same as any context names used in a UMM XML configuration. See also <a class="el" href="index.html#identifyingpersistentstores">Identifying Persistent Stores</a> </td><td><p class="starttd">None.</p>
<p class="endtd"><a class="anchor" id="umecfgretransmissionrequestprocessingrate"></a></p>
</td></tr>
<tr>
<td>retransmission-request-processing-rate </td><td>Specifies the number of retransmission requests processed by a store per second across all topics. The store drops all retransmission requests that exceed this value. </td><td>262144 </td></tr>
</table>
<p><br />
 </p>
<h3><a class="anchor" id="topicselement"></a>
Topics Element&nbsp;&nbsp;<small><a href="#topicselement">&lt;-</a></small></h3>
<p>The Topics element is a container element for all the topics persisted by the UM store. It is one of the two child elements of the Store Element. See the example below:</p>
<pre class="fragment">  &lt;topics&gt;
    &lt;topic pattern="issue.*" type="PCRE"&gt;
      &lt;ume-attributes&gt; ... &lt;/ume-attributes&gt;
    &lt;/topic&gt;
    &lt;topic pattern="topic.*" type="PCRE"&gt;
      &lt;ume-attributes&gt; ... &lt;/ume-attributes&gt;
    &lt;/topic&gt;
  &lt;/topics&gt;
</pre><p><br />
 </p>
<h3><a class="anchor" id="topicelement"></a>
Topic Element&nbsp;&nbsp;<small><a href="#topicelement">&lt;-</a></small></h3>
<p>The Topic Element defines an individual topic persisted on the store.</p>
<p>The following table gives attributes for the <code>&lt;topic&gt;</code> element:</p>
<table class="doxtable">
<tr>
<th>Attribute </th><th>Description </th><th><p class="starttd">Default Value</p>
<p class="endtd"><a class="anchor" id="umecfgpattern"></a></p>
</th></tr>
<tr>
<td>pattern </td><td>Specifies a pattern used to select topics for which a store provides persistence services. </td><td><p class="starttd">None—this is a required attribute</p>
<p class="endtd"><a class="anchor" id="umecfgtype"></a></p>
</td></tr>
<tr>
<td>type </td><td>Specifies the type of matching to be performed on the pattern attribute. A value of <code>direct</code> selects an exact string match. A value of <code>PCRE</code> selects a Perl Compatible Regular Expression match. A value of <code>regexp</code> selects a POSIX extended regular expression. <b>The <code>regexp</code> selection is deprecated.</b> </td><td><code>direct</code> </td></tr>
</table>
<p>The Topic Element has one child element, ume-attributes, the options for which appear in Options for a Topic's ume-attributes Element.</p>
<p><b>Options for a Topic's ume-attributes Element</b></p>
<p>As with <a class="el" href="index.html#optionsforastoresumeattributeselement">Options for a Store's ume-attributes Element</a>, options for a topic's ume-attributes element can set both UM configuration options as well as store configuration.</p>
<p>The following table gives options allowed for a topic element. Use the store Option Type for these options.</p>
<table class="doxtable">
<tr>
<th>Option </th><th>Description </th><th><p class="starttd">Default Value</p>
<p class="endtd"><a class="anchor" id="umecfgretransmissionrequestforwarding"></a></p>
</th></tr>
<tr>
<td>retransmission-request-forwarding </td><td>If enabled (value = 1), the store forwards retransmission requests to sources if and only if the store does not have the data. If disabled (value = 0), the store services retransmission requests for data it has, and does not forward requests to sources for data it does not have. </td><td><p class="starttd">0 (store services retransmission requests and does not forward requests)</p>
<p class="endtd"><a class="anchor" id="umecfgrepositorytype"></a></p>
</td></tr>
<tr>
<td>repository-type </td><td>Specifies how messages should be retained by the store. Possible values: <ul>
<li>
<code>"no-cache"</code> does not retain messages, only state information. </li>
<li>
<code>"memory"</code> retains messages only in the (presumably volatile) main memory of the store. </li>
<li>
<code>"disk"</code> retains messages to (presumably non-volatile) disk storage as quickly as possible. In addition, messages are cached in main memory for a time as well. </li>
<li>
<code>"reduced-fd"</code> retains messages in disk storage using significantly fewer File Descriptors. Use of this repository type may impact performance. (See <a class="el" href="index.html#persistentstorearchitecture">Persistent Store Architecture</a>.) The <code>"reduced-fd"</code> disk storage option is not available on Microsoft Windows. </li>
</ul>
</td><td><p class="starttd"><code>"no-cache"</code></p>
<p class="endtd"><a class="anchor" id="umecfgrepositorysizethreshold"></a></p>
</td></tr>
<tr>
<td>repository-size-threshold </td><td>For topics with a repository-type of memory, disk or reduced-fd, specifies the minimum number of message bytes (includes payload, headers, and store structure overhead) retained for a topic before the repository starts to delete old messages. Pertains to a memory store or the memory cache of a disk or reduced-fd repository. For RPP repositories, this value only includes message payload. Also for RPP, the source may optionally override this value with a value less than or equal with the source configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umerepositorysizethresholdsource">ume_repository_size_threshold (source)</a>. (units: bytes) </td><td><p class="starttd">25165824 (24 MB)</p>
<p class="endtd"><a class="anchor" id="umecfgrepositorysizelimit"></a></p>
</td></tr>
<tr>
<td>repository-size-limit </td><td>For topics with a repository-type of memory, disk or reduced-fd, specifies the maximum number of message bytes (includes payload, headers, and store structure overhead) retained for each source. Pertains to a memory store or the memory cache of a disk or reduced-fd repository. For RPP repositories, this value only includes message payload. Also for RPP, the source may optionally override this value with a value less than or equal with the source configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umerepositorysizelimitsource">ume_repository_size_limit (source)</a> (units: bytes) </td><td><p class="starttd">50331648 (48 MB)</p>
<p class="endtd"><a class="anchor" id="umecfgrepositoryagethreshold"></a></p>
</td></tr>
<tr>
<td>repository-age-threshold </td><td>For topics with a repository-type of memory, disk or reduced-fd, specifies how long the repository keeps a message available. Pertains to a memory store or the memory cache of a disk or reduced-fd repository. The repository reclaims space used to store messages that exceed this threshold. A value of 0 means message age is not considered in retention decisions. (units: seconds) </td><td><p class="starttd">0</p>
<p class="endtd"><a class="anchor" id="umecfgrepositorydiskmaxasynccbs"></a></p>
</td></tr>
<tr>
<td>repository-disk-max-async-cbs </td><td>For topics with a repository-type of disk or reduced-fd, specifies the maximum number of outstanding async I/O callbacks for reading and writing messages to disk. (units: async callbacks) </td><td><p class="starttd">16 callbacks</p>
<p class="endtd"><a class="anchor" id="umecfgrepositorydiskmaxwriteasynccbs"></a></p>
</td></tr>
<tr>
<td>repository-disk-max-write-async-cbs </td><td>For topics with a <a class="el" href="index.html#umecfgrepositorytype">repository-type</a> of disk or reduced-fd, specifies the maximum number of outstanding async I/O callbacks for writing messages to disk. Reducing this option can improve throughput by batching more fragments into a single write. (units: async callbacks) This option is deprecated. </td><td><p class="starttd">16 callbacks</p>
<p class="endtd"><a class="anchor" id="umecfgrepositorydiskmaxreadasynccbs"></a></p>
</td></tr>
<tr>
<td>repository-disk-max-read-async-cbs </td><td>For topics with a <a class="el" href="index.html#umecfgrepositorytype">repository-type</a> of disk or reduced-fd, specifies the maximum number of outstanding async I/O callbacks for reading messages from disk. Raising this value can improve recovery rates. For topics with a <a class="el" href="index.html#umecfgrepositorytype">repository-type</a> of reduced-fd, Informatica recommends a value of 200 times the number of expected receivers per topic. (units: async callbacks) </td><td><p class="starttd">16 callbacks</p>
<p class="endtd"><a class="anchor" id="umecfgrepositorydiskfilesizelimit"></a></p>
</td></tr>
<tr>
<td>repository-disk-file-size-limit </td><td>For topics with a <a class="el" href="index.html#umecfgrepositorytype">repository-type</a> of disk or reduced-fd, specifies the maximum amount of disk space that will be used to store retained messages. A minimum value of 196992 is enforced. For RPP, the source may optionally override this value with a value less than or equal with the source configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umerepositorydiskfilesizelimitsource">ume_repository_disk_file_size_limit (source)</a>. (units: bytes) </td><td><p class="starttd">104857600 (100 MB)</p>
<p class="endtd"><a class="anchor" id="umecfgrepositorydiskfilepreallocate"></a></p>
</td></tr>
<tr>
<td>repository-disk-file-preallocate </td><td>For topics with a <a class="el" href="index.html#umecfgrepositorytype">repository-type</a> of disk, if set to 1, UM pre-allocates a store's cache files to match their maximum size on disk (as configured by repository-disk-file-size-limit) upon creation, as opposed to growing to that size as the store receives new messages. For ext3/4 and NTFS file systems, this options creates a sparse file, which does not allocate all of the underlying data blocks. Advantages of pre-allocation include better performance on rotating disks due to less file fragmentation, and knowing that enough disk space exists for any new source that registers. Disadvantage is the time to create the cache files, especially if many sources register at once. </td><td><p class="starttd">0 (zero) - do not pre-allocate</p>
<p class="endtd"><a class="anchor" id="umecfgrepositorydiskasyncbufferlength"></a></p>
</td></tr>
<tr>
<td>repository-disk-async-buffer-length </td><td>For topics with a <a class="el" href="index.html#umecfgrepositorytype">repository-type</a> of disk or reduced-fd, specifies the size of the buffers that will be used in async I/O operations for reading and writing messages to disk. A minimum value of 65664 is enforced. (units: bytes) </td><td><p class="starttd">1024000</p>
<p class="endtd"><a class="anchor" id="umecfgrepositorydiskmessagechecksum"></a></p>
</td></tr>
<tr>
<td>repository-disk-message-checksum </td><td>For topics with a <a class="el" href="index.html#umecfgrepositorytype">repository-type</a> of disk or reduced-fd, specifies whether the messages saved to disk should include a checksum field or not for validation if the store is restarted. (units: flag) </td><td><p class="starttd">0 (disabled)</p>
<p class="endtd"><a class="anchor" id="umecfgsourceactivitytimeout"></a></p>
</td></tr>
<tr>
<td>source-activity-timeout </td><td>Establishes the period of time from a source's last activity to the release of the source's RegID. Stores return an error to any new source requesting the source's RegID during this period. If proxy sources are enabled (<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeproxysourcesource">ume_proxy_source (source)</a>) the store does not release the source's RegID and UM elects a proxy source. If neither proxy sources nor <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umestatelifetimesource">ume_state_lifetime (source)</a> are configured, the store also deletes the source's state and cache. Can be overridden by <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeactivitytimeoutsource">ume_activity_timeout (source)</a>. See also <a class="el" href="index.html#persistenceproxysources">Persistence Proxy Sources</a>. (units: milliseconds) </td><td><p class="starttd">30000 (30 seconds)</p>
<p class="endtd"><a class="anchor" id="umecfgsourcestatelifetime"></a></p>
</td></tr>
<tr>
<td>source-state-lifetime </td><td>Establishes the period of time from a source's last activity to the deletion of the source's state and cache by the store, regardless of whether a proxy source has been created or not. You can also configure <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umestatelifetimesource">ume_state_lifetime (source)</a> for the source. The store uses whichever is shorter. See also <a class="el" href="index.html#persistenceproxysources">Persistence Proxy Sources</a>. (units: milliseconds) </td><td><p class="starttd">0 (zero)</p>
<p class="endtd"><a class="anchor" id="umecfgreceiveractivitytimeout"></a></p>
</td></tr>
<tr>
<td>receiver-activity-timeout </td><td>Establishes the period of time from a receiver's last activity to the release of the receiver's RegID. Stores return an error to any new request for the receiver's RegID during this period. Can be overridden by <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeactivitytimeoutsource">ume_activity_timeout (source)</a>. See also <a class="el" href="index.html#persistenceproxysources">Persistence Proxy Sources</a>. (units: milliseconds) </td><td><p class="starttd">30000 (30 seconds)</p>
<p class="endtd"><a class="anchor" id="umecfgreceiverstatelifetime"></a></p>
</td></tr>
<tr>
<td>receiver-state-lifetime </td><td>Establishes the period of time from a receiver's last activity to the deletion of the receiver's state and cache by the store. You can also configure <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umestatelifetimereceiver">ume_state_lifetime (receiver)</a> for the receiver. The store uses whichever is shorter. See also <a class="el" href="index.html#persistenceproxysources">Persistence Proxy Sources</a>. (units: milliseconds) </td><td><p class="starttd">0 (zero)</p>
<p class="endtd"><a class="anchor" id="umecfgsourcecheckinterval"></a></p>
</td></tr>
<tr>
<td>source-check-interval </td><td>Specifies how often a store will check for activity of sources and receivers. (units: milliseconds) </td><td><p class="starttd">750 (750 milliseconds)</p>
<p class="endtd"><a class="anchor" id="umecfgkeepaliveinterval"></a></p>
</td></tr>
<tr>
<td>keepalive-interval </td><td>Specifies how often a store will generate keepalive traffic to sources and receivers if there has been no traffic required in the normal course of operation. (units: milliseconds) </td><td><p class="starttd">3000 (3 seconds)</p>
<p class="endtd"><a class="anchor" id="umecfgreceivernewregistrationrollback"></a></p>
</td></tr>
<tr>
<td>receiver-new-registration-rollback </td><td>Specifies the number of stabilized messages that a newly registered receiver should consume. For example, setting this to 10 "rolls back" the new receiver's starting message to the 10th most recent message. This value must be positive and less than 2147483648. The recommended value of 2147483647 indicates that the rollback should begin at the start of the stream. A value of 0 indicates the store should instruct the receivers to start with the next new message from the source known by the store. (units: messages) </td><td><p class="starttd">2147483647 (rollback starts at beginning of stream)</p>
<p class="endtd"><a class="anchor" id="umecfgproxyelectioninterval"></a></p>
</td></tr>
<tr>
<td>proxy-election-interval </td><td>Specifies the interval, in milliseconds, used when electing a proxy source. When a source, which requested that a proxy source be provided for it, has been detected as no longer active, each store eligible to provide a proxy source for it waits for an amount of time which is randomized in the range [0.5*proxy-election-interval .. 1.5*proxy-election-interval]. If no other store has been elected to serve as the proxy source, the store declares itself as the proxy source. (units: milliseconds) </td><td><p class="starttd">60,000 (60 seconds)</p>
<p class="endtd"><a class="anchor" id="umecfgstabilityackinterval"></a></p>
</td></tr>
<tr>
<td>stability-ack-interval </td><td>Specifies the maximum amount of time that stability acknowledgments will be batched before being sent to a source. Batching stability ACKs can increase throughput of stores (especially memory stores) significantly, but introduces a delay between when a message is actually stable in the store and when the source is notified of message stability. (units: milliseconds) </td><td><p class="starttd">200 (200 milliseconds)</p>
<p class="endtd"><a class="anchor" id="umecfgstabilityackminimumnumber"></a></p>
</td></tr>
<tr>
<td>stability-ack-minimum-number </td><td>Specifies the minimum number of message stability acknowledgments that must accumulate before a stability ACK is sent to a source. With the default value of 1, stability ACKs are sent immediately as soon as messages are stable. Increasing this value causes stability ACKs to be batched, which can increase throughput of stores (especially memory stores) significantly, but introduces a delay between when a message is actually stable in the store and when the source is notified of message stability. If using a stability ACK-based flight size on a persistent source in combination with this option, it is advisable to make sure stability-ack-minimum-number is set less than or equal to the source's flight size. Otherwise, stability ACKs will only be sent upon expiration of the <a class="el" href="index.html#umecfgstabilityackinterval">stability-ack-interval</a> timer, resulting in bursty stop-and-go sending. (units: number of message fragments) </td><td><p class="starttd">1 (1 fragment)</p>
<p class="endtd"><a class="anchor" id="umecfgrepositoryallowreceiverpacedpersistence"></a></p>
</td></tr>
<tr>
<td>repository-allow-receiver-paced-persistence </td><td>Specifies if the repository allows receiver-paced persistence (1). If allowed, the source may optionally request RPP with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umereceiverpacedpersistencesource">ume_receiver_paced_persistence (source)</a>. Both must be done for RPP to be in effect. </td><td><p class="starttd">0 (store does not allow the source to specify RPP)</p>
<p class="endtd"><a class="anchor" id="umecfgrepositoryallowackonreception"></a></p>
</td></tr>
<tr>
<td>repository-allow-ack-on-reception </td><td>For RPP, specifies if the repository allows the repository to perform "ack on reception" (1). If allowed, the source may optionally request "ack on reception" with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umerepositoryackonreceptionsource">ume_repository_ack_on_reception (source)</a>. Both must be done for "ack on reception" to be in effect. For SPP and memory stores, this option has no effect. See <a class="el" href="index.html#rppnormaloperation">RPP Normal Operation</a> for more information. </td><td><p class="starttd">0 (store does not allow the source to specify ack-on-reception behavior)</p>
<p class="endtd"><a class="anchor" id="umecfgrepositorydiskwritedelay"></a></p>
</td></tr>
<tr>
<td>repository-disk-write-delay </td><td>For topics with a repository-type of disk or reduced-fd, specifies the maximum delay in milliseconds after message reception before the repository persists a message to disk. For RPP, the source may optionally override this value with a value less than or equal with the source configuration option <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umewritedelaysource">ume_write_delay (source)</a>. (units: milliseconds) </td><td><p class="starttd">0 milliseconds</p>
<p class="endtd"><a class="anchor" id="umecfgsourceflightsizebytesmaximum"></a></p>
</td></tr>
<tr>
<td>source-flight-size-bytes-maximum </td><td>With RPP, specifies the maximum number of in-flight payload bytes that the source is allowed to configure with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeflightsizebytessource">ume_flight_size_bytes (source)</a>. If the source attempts to configure <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpultramessagingpersistence.html#umeflightsizebytessource">ume_flight_size_bytes (source)</a> greater than the store's <a class="el" href="index.html#umecfgsourceflightsizebytesmaximum">source-flight-size-bytes-maximum</a>, the source registration is rejected. For SPP stores, this option has no effect (i.e. the source is not restricted in its configuration). See <a class="el" href="index.html#persistenceflightsize">Persistence Flight Size</a> for more information. (units: bytes) </td><td>4194304 bytes (4MB) </td></tr>
</table>
<p><br />
 </p>
<h2><a class="anchor" id="optiontypesforumeattributeselements"></a>
Option Types for ume-attributes Elements&nbsp;&nbsp;<small><a href="#optiontypesforumeattributeselements">&lt;-</a></small></h2>
<p>As mentioned in <a class="el" href="index.html#optionsforastoresumeattributeselement">Options for a Store's ume-attributes Element</a>, all options configured for '<code>&lt;ume-attributes&gt;</code>' require an '<code>&lt;option&gt;</code>' type, which specifies the scope of the option.</p>
<p>For example, here is a store configuration which illustrates several options being set of varying types:</p>
<pre class="fragment">&lt;?xml version="1.0"?&gt;
  &lt;stores&gt;
    &lt;store name="test-store" port="14567"&gt;
      &lt;ume-attributes&gt;
        &lt;option type="store" name="disk-cache-directory" value="cache"/&gt;
            &lt;option type="lbm-context" name="transport_lbtrm_rate_interval" value="100"&gt;
      &lt;/ume-attributes&gt;
      &lt;topics&gt;
        &lt;topic pattern="test.*" type="PCRE"&gt;
          &lt;ume-attributes&gt;
            &lt;option type="lbm-receiver" name="transport_lbtrm_send_naks" value="0"&gt;
            &lt;option type="lbm-source" name="transport" value="lbtru"&gt;
            &lt;option type="store" name="repository-size-limit" value="209715200"/&gt;
          &lt;/ume-attributes&gt;
        &lt;/topic&gt;
      &lt;/topics&gt;
    &lt;/store&gt;
  &lt;/stores&gt;
</pre><p>The following table describes the Option Types:</p>
<table class="doxtable">
<tr>
<th>Option Type </th><th>Description </th><th><p class="starttd">Default Value</p>
<p class="endtd"><a class="anchor" id="umecfglbmreceiver"></a></p>
</th></tr>
<tr>
<td>lbm-receiver </td><td>Allows you to configure receiver-scope options that you usually specify in an Ultra Messaging configuration file or set using lbm_*_attr_setopt(). For example, you could turn off delivery of NAKs for a particular topic by including the following within the topic's '<code>&lt;ume-attributes&gt;</code>' element: <br />
<code>&lt;option type="lbm-receiver" name="transport_lbtrm_send_naks" value="0"&gt;</code> <br />
'<code>&lt;option&gt;</code>' is a child of '<code>&lt;ume-attributes&gt;'</code>, but you can use option type lbm-receiver within only a '<code>&lt;topic&gt;</code>' element, not a '<code>&lt;store&gt;</code>' element. </td><td><p class="starttd">None - this is a required attribute.</p>
<p class="endtd"><a class="anchor" id="umecfglbmcontext"></a></p>
</td></tr>
<tr>
<td>lbm-context </td><td>Allows you to configure context-scope options that you usually specify in an Ultra Messaging configuration file or set using lbm_*_attr_setopt(). For example, you could increase the receiver socket buffer by including the following within the '<code>&lt;ume-attributes&gt;</code>' element: <br />
<code>&lt;option type="lbm-context" name="transport_lbtrm_receiver_socket_buffer" value="1048576"&gt;</code> <br />
'<code>&lt;option&gt;</code>' is a child of '<code>&lt;ume-attributes&gt;</code>', but you can use option type lbm-receiver within only a '<code>&lt;store&gt;</code>' element, not a '<code>&lt;topic&gt;</code>' element. </td><td><p class="starttd">None - this is a required attribute.</p>
<p class="endtd"><a class="anchor" id="umecfglbmsource"></a></p>
</td></tr>
<tr>
<td>lbm-source </td><td>Allows you to configure source-scope options that you usually specify in an Ultra Messaging configuration file or set using lbm_*_attr_setopt(). For example, you could change the transport by including the following within the '<code>&lt;ume-attributes&gt;</code>' element: <br />
<code>&lt;option type="lbm-source" name="transport" value="lbtru"&gt;</code> <br />
'<code>&lt;option&gt;</code>' is a child of '<code>&lt;ume-attributes&gt;</code>', but you can use option type lbm-source within only a '<code>&lt;topic&gt;</code>' element, not a '<code>&lt;store&gt;</code>' element. </td><td><p class="starttd">None - this is a required attribute.</p>
<p class="endtd"><a class="anchor" id="umecfgstore"></a></p>
</td></tr>
<tr>
<td>store </td><td>Option type used for all ume-attributes configured for the store element and its topic element. </td><td>None - this is a required attribute. </td></tr>
</table>
<p><br />
 </p>
<h2><a class="anchor" id="umestoredconfigurationdtd"></a>
umestored Configuration DTD&nbsp;&nbsp;<small><a href="#umestoredconfigurationdtd">&lt;-</a></small></h2>
<p>The DTD for UM Store configuration has evolved over time:</p>
<table class="doxtable">
<tr>
<th>DTD Version </th><th>Release Date </th><th>Product Version </th><th>Supported Features </th></tr>
<tr>
<td>1.0 </td><td>Feb. 2007 </td><td>UME 1.0 </td><td>Persistent Stores </td></tr>
<tr>
<td>1.1 </td><td>April 2010 </td><td>UME 3.0.1 / UMQ 1.0 </td><td>Persistent Stores, Queues and Ultra Load Balancing (ULB) </td></tr>
<tr>
<td>1.2 </td><td>March 2011 </td><td>UME 3.2 / UMQ 2.1 </td><td>Persistent Stores, Queues, Ultra Load Balancing (ULB), Dead Letter Queue, Indexed Queuing and Indexed ULB </td></tr>
<tr>
<td>1.3 </td><td>November 2016 </td><td>UM 6.10 </td><td>Addition of '<code>&lt;xml-config&gt;</code>' element (under '<code>&lt;daemon&gt;</code>'). </td></tr>
</table>
<p>Here is the current version:</p>
<pre class="fragment">&lt;!ELEMENT ume-store (daemon, stores?)&gt; 
&lt;!ATTLIST ume-store version CDATA #REQUIRED&gt; 
&lt;!ELEMENT daemon (log | uid | pidfile | gid | lbm-config | xml-config | lbm-license-file | web-monitor | daemon-monitor)*&gt; 
&lt;!ELEMENT log ( #PCDATA )&gt; 
&lt;!ATTLIST log type (file | console) "console"&gt; 
&lt;!ATTLIST log frequency (disable | daily | hourly | test) "disable"&gt; 
&lt;!ATTLIST log size CDATA #IMPLIED&gt; 
&lt;!ATTLIST log xml:space (default | preserve) "default"&gt;
&lt;!ELEMENT pidfile ( #PCDATA )&gt; 
&lt;!ATTLIST pidfile xml:space (default | preserve) "default"&gt;
&lt;!ELEMENT uid ( #PCDATA )&gt; 
&lt;!ATTLIST uid xml:space (default | preserve) "default"&gt;
&lt;!ELEMENT gid ( #PCDATA )&gt; 
&lt;!ATTLIST gid xml:space (default | preserve) "default"&gt;
&lt;!ELEMENT lbm-config ( #PCDATA )&gt; 
&lt;!ATTLIST lbm-config xml:space (default | preserve) "default"&gt;
&lt;!ELEMENT xml-config ( #PCDATA )&gt; 
&lt;!ATTLIST xml-config xml:space (default | preserve) "default"&gt;
&lt;!ATTLIST xml-config application-name CDATA #IMPLIED&gt; 
&lt;!ELEMENT lbm-license-file ( #PCDATA )&gt; 
&lt;!ATTLIST lbm-license-file xml:space (default | preserve) "default"&gt;
&lt;!ELEMENT web-monitor ( #PCDATA )&gt; 
&lt;!ATTLIST web-monitor xml:space (default | preserve) "default"&gt;
&lt;!ELEMENT stores (store*)&gt; 
&lt;!ELEMENT store (publishing-interval | ume-attributes | topics)+&gt; 
&lt;!ATTLIST store name CDATA #REQUIRED&gt; 
&lt;!ATTLIST store interface CDATA #IMPLIED&gt; 
&lt;!ATTLIST store port CDATA #REQUIRED&gt; 
&lt;!ELEMENT topics (topic+)&gt; 
&lt;!ELEMENT topic (ume-attributes*)&gt; 
&lt;!ATTLIST topic pattern CDATA #REQUIRED&gt; 
&lt;!ATTLIST topic type (direct | PCRE | regexp) #IMPLIED&gt; 
&lt;!ELEMENT ume-attributes (option+)&gt; 
&lt;!ELEMENT option EMPTY&gt; 
&lt;!ATTLIST option type (lbm-receiver | lbm-context | lbm-source | store) #IMPLIED&gt; 
&lt;!ATTLIST option name CDATA #REQUIRED&gt; 
&lt;!ATTLIST option value CDATA #REQUIRED&gt; 
&lt;!ELEMENT daemon-monitor (lbm-config | publishing-interval | remote-snapshot-request | remote-config-changes-request)*&gt; 
&lt;!ATTLIST daemon-monitor topic CDATA "umestore.monitor"&gt; 
&lt;!ELEMENT publishing-interval (group+)&gt; 
&lt;!ELEMENT group EMPTY&gt; 
&lt;!ATTLIST group name (default | store | source | receiver | disk | config | memory) #REQUIRED&gt; 
&lt;!ATTLIST group ivl CDATA #REQUIRED&gt; 
&lt;!ELEMENT remote-snapshot-request EMPTY&gt; 
&lt;!ATTLIST remote-snapshot-request allow (0 | 1) "0"&gt; 
&lt;!ELEMENT remote-config-changes-request EMPTY&gt; 
&lt;!ATTLIST remote-config-changes-request allow (0 | 1) "0"&gt; </pre><p><br />
 </p>
<h2><a class="anchor" id="storeconfigurationexample"></a>
Store Configuration Example&nbsp;&nbsp;<small><a href="#storeconfigurationexample">&lt;-</a></small></h2>
<p>Store daemon with one store.</p>
<pre class="fragment">&lt;?xml version="1.0"?&gt;
&lt;ume-store version="1.3"&gt;
  &lt;daemon&gt;
    &lt;log&gt;stored.log&lt;/log&gt;
    &lt;pidfile&gt;stored.pid&lt;/pidfile&gt;
    &lt;web-monitor&gt;*:15304&lt;/web-monitor&gt;
  &lt;/daemon&gt;

  &lt;stores&gt;
    &lt;store name="test-store" port="14567"&gt;
      &lt;ume-attributes&gt;
        &lt;option type="store" name="disk-cache-directory" value="cache"/&gt;
        &lt;option type="store" name="disk-state-directory" value="state"/&gt;
        &lt;option type="store" name="context-name" value="remote-store"/&gt;
      &lt;/ume-attributes&gt;
      &lt;topics&gt;
        &lt;topic pattern="test.*" type="PCRE"&gt;
          &lt;ume-attributes&gt;
            &lt;option type="store" name="repository-type" value="disk"/&gt;
            &lt;option type="store" name="repository-size-threshold" value="104857600"/&gt;
            &lt;option type="store" name="repository-size-limit" value="209715200"/&gt;
            &lt;option type="store" name="repository-disk-file-size-limit" value="1073741824"/&gt;
            &lt;option type="store" name="source-activity-timeout" value="120000"/&gt;
            &lt;option type="store" name="receiver-activity-timeout" value="120000"/&gt;
            &lt;option type="store" name="retransmission-request-forwarding" value="0"/&gt;
          &lt;/ume-attributes&gt;
        &lt;/topic&gt;
      &lt;/topics&gt;
    &lt;/store&gt;
  &lt;/stores&gt;
&lt;/ume-store&gt;
</pre><p><br />
 </p>
<h3><a class="anchor" id="xmlconfigtag"></a>
xml-config Tag&nbsp;&nbsp;<small><a href="#xmlconfigtag">&lt;-</a></small></h3>
<p>The '<code>&lt;xml-config&gt;</code>' tag is used to load a UM configuration file which is used by the store as it creates UM objects (contexts, receivers, etc.). This example applies the configuration specified in the "tnwgd" application tag of the file "lbm_cfg.xml":</p>
<pre class="fragment">&lt;ume-store version="1.3"&gt;
    &lt;daemon&gt;
        ...
        &lt;xml-config application-name="tnwgd"&gt;lbm_cfg.xml&lt;/lbm-xmlconfig&gt;
    &lt;/daemon&gt;
</pre><p>If an '<code>application-name</code>' attribute is not supplied, "umestored" is assumed. If it is desired to load the unnamed configuration, use an empty application name as follows:</p>
<pre class="fragment">&lt;ume-store version="1.3"&gt;
    &lt;daemon&gt;
        ...
        &lt;xml-config application-name=""&gt;lbm_cfg.xml&lt;/lbm-xmlconfig&gt;
    &lt;/daemon&gt;
</pre><p><br />
 </p>
<h1><a class="anchor" id="storedaemonstatistics"></a>
Store Daemon Statistics&nbsp;&nbsp;<small><a href="#storedaemonstatistics">&lt;-</a></small></h1>
<p>This section contains details on the Store's Daemon Statistics feature. <b>You should already be familiar with the general information contained in <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/design.tag:../../Design/" href="../../Design/umobjects.html#daemonstatistics">Daemon Statistics</a>.</b></p>
<p><br />
 </p>
<h2><a class="anchor" id="storedaemonstatisticsstructures"></a>
Store Daemon Statistics Structures&nbsp;&nbsp;<small><a href="#storedaemonstatisticsstructures">&lt;-</a></small></h2>
<p>The different message types are:</p>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#aa3a3d4c63922003ed750ed38027bcc82">LBM_UMESTORE_DMON_MPG_SMART_HEAP_STATS</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#a102df121698e67407d2aeffc0147d91e">LBM_UMESTORE_DMON_MPG_STORE_STATS</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#aa4269805d37ad1586f340a0f4486e0e9">LBM_UMESTORE_DMON_MPG_REPO_STATS</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#a41acc94a55b5c03bf2580c876d7f8ad4">LBM_UMESTORE_DMON_MPG_DISK_STATS</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#aa57c0aadc4536533388200812a51584e">LBM_UMESTORE_DMON_MPG_RCV_STATS</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#aed8460b69470931e1d8ee4347110a309">LBM_UMESTORE_DMON_MPG_STORE_CONFIG</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#aab14bc84ccbe0986c41e5f3f4b5f2b34">LBM_UMESTORE_DMON_MPG_STORE_PATTERN_CONFIG</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#a8e29917df3f47cbb8935cb1ed683e876">LBM_UMESTORE_DMON_MPG_STORE_TOPIC_CONFIG</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#a76e34ed0b81c5e1141a36e358f3803a4">LBM_UMESTORE_DMON_MPG_REPO_CONFIG</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#a37abe47b7a806332d6dec510f8370386">LBM_UMESTORE_DMON_MPG_RCV_CONFIG</a> </li>
</ul>
<p>Each one has a specific structure associated with it, as detailed in <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html">umedmonmsgs.h</a>.</p>
<p>Note that message types ending with "_CONFIG" are in the config category, while message types ending with "_STATS" are in the stats category. See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/design.tag:../../Design/" href="../../Design/umobjects.html#daemonstatisticsstructures">Daemon Statistics Structures</a> for information on how the two categories are handled differently.</p>
<p><br />
 </p>
<h3><a class="anchor" id="storedaemonstatisticsbyteswapping"></a>
Store Daemon Statistics Byte Swapping&nbsp;&nbsp;<small><a href="#storedaemonstatisticsbyteswapping">&lt;-</a></small></h3>
<p>A monitoring application receiving these messages must detect if there is an endian mismatch (see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/design.tag:../../Design/" href="../../Design/umobjects.html#daemonstatisticsbinarydata">Daemon Statistics Binary Data</a>). The header structure <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#ac8fa75ab624041897fe74bdde0a98b16">umestore_dmon_msg_hdr_t</a> contains a 16-bit field named <code>magic</code> which is set equal to <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#a1803f128fe2a66d57e078956fdcc07ca">LBM_UMESTORE_DMON_MAGIC</a>. The receiving application should compare it to <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#a1803f128fe2a66d57e078956fdcc07ca">LBM_UMESTORE_DMON_MAGIC</a> and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#a24d18e9ceeaed40dd3e282418dbdc42c">LBM_UMESTORE_DMON_ANTIMAGIC</a>. Anything else would represent a serious problem.</p>
<p>If the receiving app sees: </p><pre class="fragment">  magic == LBM_UMESTORE_DMON_MAGIC
</pre><p> then it can simply access the binary fields directly. However, if it sees: </p><pre class="fragment">  magic == LBM_UMESTORE_DMON_ANTIMAGIC
</pre><p> then <em>most</em> (but not all) binary fields need to be byte-swapped. See <a href="../../example/umedmon.c">umedmon.c</a> for an example, paying special attention to the macros <code>COND_SWAPxx</code> (which <em>conditionally</em> swaps based on the magic test) and the functions <code>byte_swapXX()</code> (which performs the byte swapping).</p>
<p>However, there are some binary fields which must never be swapped, regardless of the endian. This is indicated in the documentation. For example, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/structumestore__store__dmon__config__msg__t__stct.html#af0145c44bd69bcaf83b9a4088151960c">umestore_store_dmon_config_msg_t_stct::store_iface</a> says "NOTE: This field should NOT be byte-swapped." Here's how that field might be accessed: </p><pre class="fragment">  in.s_addr = msg-&gt;store_iface;
  printf("Store IP address / port: %s / %d\n",
      inet_ntoa(in), COND_SWAP16(msg_swap, msg-&gt;store_port));
</pre><p> As you can see, <code>store_iface</code> is not byte swapped, but <code>store_port</code> (conditionally) is swapped.</p>
<p><br />
 </p>
<h3><a class="anchor" id="storedaemonstatisticsstructuresstringbuffers"></a>
Store Daemon Statistics String Buffers&nbsp;&nbsp;<small><a href="#storedaemonstatisticsstructuresstringbuffers">&lt;-</a></small></h3>
<p>There are some messages which contain string buffers at the ends of the messages. Strings in these data structures are always null-terminated. Be aware that these messages are not sent as fixed-length equal to the size of the data structure, but rather are sent with only the bytes required by the string (including the final null). For example, the structure <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#a132a874ae972e1f393b1a973905ac923">umestore_store_pattern_dmon_config_msg_t</a> contains the field <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/structumestore__store__pattern__dmon__config__msg__t__stct.html#ad90cc4d946617553bbc8e7e7f1741138">umestore_store_pattern_dmon_config_msg_t_stct::pattern_buffer</a> which is <code>char</code> array of size <code>LBM_UMESTORE_DMON_TOPIC_PATTERN_STRLEN</code>. If <code>pattern_buffer</code> is set to ".*", then only 3 bytes (including the null string terminator) are sent for that field.</p>
<p>Contrast this with <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/gateway.tag:../../Gateway/" href="../../Gateway/umrouterdaemonstatistics.html#umrouterdaemonstatisticsstructuresstringbuffers">UM Router Daemon Statistics String Buffers</a>.</p>
<p>This becomes more complicated when there are multiple strings in one message. For example, consider <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#a6791bb4e61ba08a319647d4fd5ed8c5d">umestore_store_dmon_config_msg_t</a>. This message contains three strings: store name, cache directory name, and state directory name. But a single <code>char</code> array is declared: </p><pre class="fragment">  char string_buffer[LBM_UMESTORE_DMON_STORE_NAME_STRLEN + (2 * LBM_UMESTORE_DMON_FILENAME_MAX_STRLEN)
</pre><p> The three strings are packed into that buffer, only taking up as much space as is necessary. I.e. if the three strings are "a", "b", and "c", only 6 bytes of the buffer will be consumed (each string has a null).</p>
<p>To make it easier for the code to find the three strings, the structure has three offset variables: <code>store_name_offset</code>, <code>disk_cache_dir_offset</code>, and <code>disk_state_dir_offset</code>. These are byte offsets from the start of the entire structure. So, to access the store name, the monitoring application might use: </p><pre class="fragment">  umestore_store_dmon_config_msg_t *store_config_msg = ... /* ptr to incoming msg */
  char *state_dir_name = (char *)store_config_msg +
                         store_config_msg-&gt;store_name_offset;
</pre><p> (The practice of using offsets from the start of the structure allows for greater flexibility in ensuring inter-version compatibility.)</p>
<p><br />
 </p>
<h3><a class="anchor" id="storedaemonstatisticsstructuresretxcounts"></a>
Store Daemon Statistics Retx Counts&nbsp;&nbsp;<small><a href="#storedaemonstatisticsstructuresretxcounts">&lt;-</a></small></h3>
<p>There is a set of fields in <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#aeeb55ed0b759e6316cdedc3c990dfe26">umestore_store_dmon_stat_msg_t</a> which give statistics on recovery operations initiated by receivers:</p>
<ul>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/structumestore__store__dmon__stat__msg__t__stct.html#aa5af5aa74379f3784c59503a52309dfd">umestore_store_dmon_stat_msg_t_stct::ume_retx_req_rcv_count</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/structumestore__store__dmon__stat__msg__t__stct.html#a9fb94f3660f9055189b1466fbe26d5b1">umestore_store_dmon_stat_msg_t_stct::ume_retx_req_serviced_count</a> </li>
<li>
<a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/structumestore__store__dmon__stat__msg__t__stct.html#a48daa393596d1ede504a5c378220f468">umestore_store_dmon_stat_msg_t_stct::ume_retx_req_drop_count</a> </li>
</ul>
<p>The web monitor's <a class="el" href="index.html#storewebmonitorstorepage">Store Web Monitor Store Page</a> has a manual function labeled <a class="el" href="index.html#resetratestats">Reset Rate Stats</a> which clears those <code>"ume_retx_..._count"</code> fields. This is a useful function for users who use the web monitor as their primary monitoring tool, but for users who depend on the published Daemon Statistics, it can be disruptive for the counts to be cleared on-demand.</p>
<p>The field <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/structumestore__store__dmon__stat__msg__t__stct.html#a8413d51c9aa089626fb135e0a64dc60c">umestore_store_dmon_stat_msg_t_stct::ume_retx_stat_interval</a> contains the seconds since the last <a class="el" href="index.html#resetratestats">Reset Rate Stats</a> operation. If the user has not used <a class="el" href="index.html#resetratestats">Reset Rate Stats</a>, then <code>ume_retx_stat_interval</code> contains the seconds since the store's startup.</p>
<p><br />
 </p>
<h2><a class="anchor" id="storedaemonstatisticsconfiguration"></a>
Store Daemon Statistics Configuration&nbsp;&nbsp;<small><a href="#storedaemonstatisticsconfiguration">&lt;-</a></small></h2>
<p>There are two places in the Store configuration file that Daemon Statistics are configured: </p><ul>
<li>
The <a class="el" href="index.html#daemonmonitorelement">Daemon-monitor Element</a> inside the <code>&lt;daemon&gt;</code> definition. Configures all aspects of the Store Daemon Statistics feature, including publishing intervals. </li>
<li>
The <a class="el" href="index.html#publishingintervalelement">Publishing-interval Element</a> inside a <code>&lt;store&gt;</code> definition. Configures only the publishing intervals on a store basis. </li>
</ul>
<p>Here is an example of configuring daemon statistics.</p>
<pre class="fragment">&lt;ume-store version="1.3"&gt;
&lt;daemon&gt;
  &lt;daemon-monitor topic="bozo"&gt;
    ...
    &lt;publishing-interval&gt;
      &lt;group name="default" ivl="3"/&gt;
      &lt;group name="config" ivl="120"/&gt;
    &lt;/publishing-interval&gt;
    &lt;remote-snapshot-request allow="1"/&gt;
    &lt;remote-config-changes-request allow="1"/&gt;
  &lt;/daemon-monitor&gt;
&lt;daemon&gt;
&lt;stores&gt;
  &lt;store name="store0" port="12000"&gt;
    &lt;publishing-interval&gt;
      &lt;group name="default" ivl="6"/&gt;
      &lt;group name="config" ivl="120"/&gt;
    &lt;/publishing-interval&gt;
    ...
  &lt;/store&gt;
  &lt;store name="store1" port="12001"&gt;
    ...
  &lt;/store&gt;
&lt;/stores&gt;
</pre><p>In this example, all stats-type messages are (conditionally) published on a 3-second interval, except those of store0, which are published (conditionally) on a 6-second interval. All config-type messages are published (unconditionally) on a 120-second interval.</p>
<p><br />
 </p>
<h2><a class="anchor" id="storedaemonstatisticsrequests"></a>
Store Daemon Statistics Requests&nbsp;&nbsp;<small><a href="#storedaemonstatisticsrequests">&lt;-</a></small></h2>
<p>The Store Daemon supports a monitoring application to send a specific set of requests to control the operation of Daemon Statistics. The <a class="el" href="index.html#dmoncfgremotesnapshotrequest">remote-snapshot-request</a> and <a class="el" href="index.html#dmoncfgremoteconfigchangesrequest">remote-config-changes-request</a> configuration elements control whether the Store enables this request feature (defaults to disabled).</p>
<p>If enabled, the monitoring application can send a command message to the store in the form of a topicless unicast immediate "request" message (see <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/lbm_8h.html#ae011c7a66e1db1f012d7f9633dbd321d">lbm_unicast_immediate_request()</a> with NULL for topic). The format of the message is a simple ascii string, with or without null termination. Due to the simple format of the message, no data structure is defined for it.</p>
<p>When the Store receives and validates the command, it sends a UM response message back to the requesting application containing a status message (which is <em>not</em> null-terminated). If the status was OK, the Store also performs the requested action.</p>
<p>The example program <a href="../../example/umedcmd.c">umedcmd.c</a> demonstrates the correct way to send the messages and receive the responses.</p>
<p><b>Commands enabled by <a class="el" href="index.html#dmoncfgremotesnapshotrequest">remote-snapshot-request</a>:</b></p>
<dl class="section user"><dt>version</dt><dd>The Store returns in its command response the value of <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#af43ca32ea1917897c4ff1310d214c20b">LBM_UMESTORE_DMON_VERSION</a>. No daemon statistics messages are published.</dd></dl>
<dl class="section user"><dt>snap memory</dt><dd>The Store immediately publishes the memory usage message <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#aa3a3d4c63922003ed750ed38027bcc82">LBM_UMESTORE_DMON_MPG_SMART_HEAP_STATS</a>.</dd></dl>
<dl class="section user"><dt>snap src</dt><dd>The Store immediately publishes the source repository statistics message(s) <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#aa4269805d37ad1586f340a0f4486e0e9">LBM_UMESTORE_DMON_MPG_REPO_STATS</a>.</dd></dl>
<dl class="section user"><dt>snap rcv</dt><dd>The Store immediately publishes the receiver statistics message(s) <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#aa57c0aadc4536533388200812a51584e">LBM_UMESTORE_DMON_MPG_RCV_STATS</a>.</dd></dl>
<dl class="section user"><dt>snap disk</dt><dd>The Store immediately publishes the disk statistics message(s) <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#a41acc94a55b5c03bf2580c876d7f8ad4">LBM_UMESTORE_DMON_MPG_DISK_STATS</a>.</dd></dl>
<dl class="section user"><dt>snap store</dt><dd>The Store immediately publishes the store statistics message(s) <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#a102df121698e67407d2aeffc0147d91e">LBM_UMESTORE_DMON_MPG_STORE_STATS</a>.</dd></dl>
<dl class="section user"><dt>snap config</dt><dd>The Store immediately publishes the store config category messages <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#aed8460b69470931e1d8ee4347110a309">LBM_UMESTORE_DMON_MPG_STORE_CONFIG</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#aab14bc84ccbe0986c41e5f3f4b5f2b34">LBM_UMESTORE_DMON_MPG_STORE_PATTERN_CONFIG</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#a8e29917df3f47cbb8935cb1ed683e876">LBM_UMESTORE_DMON_MPG_STORE_TOPIC_CONFIG</a>, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#a76e34ed0b81c5e1141a36e358f3803a4">LBM_UMESTORE_DMON_MPG_REPO_CONFIG</a>, and <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/api.tag:../../API/" href="../../API/umedmonmsgs_8h.html#a37abe47b7a806332d6dec510f8370386">LBM_UMESTORE_DMON_MPG_RCV_CONFIG</a></dd></dl>
<p><b>Commands enabled by <a class="el" href="index.html#dmoncfgremoteconfigchangesrequest">remote-config-changes-request</a>:</b></p>
<dl class="section user"><dt>memory N</dt><dd>Set the publishing interval for memory usage. <br />
For example: <code>memory 5</code></dd></dl>
<dl class="section user"><dt>src N</dt><dd>Set the publishing interval for source repository statistics messages. This command can be preceded by a store name in double quote marks to only set the publishing interval for that store. <br />
For example: <code>"store1" src 5</code></dd></dl>
<dl class="section user"><dt>rcv N</dt><dd>Set the publishing interval for receiver statistics messages. This command can be preceded by a store name in double quote marks to only set the publishing interval for that store. <br />
For example: <code>"store1" rcv 5</code></dd></dl>
<dl class="section user"><dt>disk N</dt><dd>Set the publishing interval for disk statistics messages. This command can be preceded by a store name in double quote marks to only set the publishing interval for that store. <br />
For example: <code>"store1" disk 5</code></dd></dl>
<dl class="section user"><dt>store N</dt><dd>Set the publishing interval for store statistics messages. This command can be preceded by a store name in double quote marks to only set the publishing interval for that store. <br />
For example: <code>"store1" store 5</code></dd></dl>
<dl class="section user"><dt>config N</dt><dd>Set the publishing interval for config category messages. This command can be preceded by a store name in double quote marks to only set the publishing interval for that store. <br />
For example: <code>"store1" config 5</code></dd></dl>
<p><br />
 </p>
<h1><a class="anchor" id="storewebmonitor"></a>
Store Web Monitor&nbsp;&nbsp;<small><a href="#storewebmonitor">&lt;-</a></small></h1>
<p>The built-in web monitor (configured in the umestored XML configuration file) is a rich source of information about the health of a UM stores. This section contains a page-by-page guide to reading and interpreting the output of a UM web monitor, with just a couple example sources and one receiver using a single store.</p>
<dl class="section warning"><dt>Warning</dt><dd>The store's web monitor is not designed to be a highly-secure feature. Anybody with access to the network can access the web monitor pages.</dd></dl>
<p>Users are expected to prevent unauthorized access to the web monitor through normal firewalling methods. Users who are unable to limit access to a level consistent with their overall security needs should disable the store web monitor (using <a class="el" href="index.html#umecfgwebmonitor">&lt;web-monitor&gt;</a>). See <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/design.tag:../../Design/" href="../../Design/fundamentalconcepts.html#webmonsecurity">Webmon Security</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>the UM daemon designs are evolving away from simple web-based monitoring and towards a publish/subscribe model of distributing monitoring events and statistics.</dd></dl>
<p><br />
 </p>
<h2><a class="anchor" id="storewebmonitorindexpage"></a>
Store Web Monitor Index Page&nbsp;&nbsp;<small><a href="#storewebmonitorindexpage">&lt;-</a></small></h2>
<p>Here is an image of the Web Monitor's <em>Index</em> (main) page:</p>
<center> <div class="image">
<img src="webmon_index.png" alt="webmon_index.png"/>
</div>
  </center><p>The web monitor's index page tells what build of UM is running.</p>
<p>The "Stores" link displays the <a class="el" href="index.html#storewebmonitorstorespage">Store Web Monitor Stores Page</a>.</p>
<p><br />
 </p>
<h2><a class="anchor" id="storewebmonitorstorespage"></a>
Store Web Monitor Stores Page&nbsp;&nbsp;<small><a href="#storewebmonitorstorespage">&lt;-</a></small></h2>
<p>Here is an image of the Web Monitor's <em>Stores</em> page:</p>
<center> <div class="image">
<img src="webmon_stores.png" alt="webmon_stores.png"/>
</div>
  </center><p>This page shows all the stores configured under the umestored process. If you had 5 stores configured, they would be numbered Store 0 through Store 4. Our example has only one store configured, "ume-test-store".</p>
<p>Each store name is a clickable link, which displays the <a class="el" href="index.html#storewebmonitorstorepage">Store Web Monitor Store Page</a> for that store.</p>
<p><br />
 </p>
<h2><a class="anchor" id="storewebmonitorstorepage"></a>
Store Web Monitor Store Page&nbsp;&nbsp;<small><a href="#storewebmonitorstorepage">&lt;-</a></small></h2>
<p>Here is an image of the Web Monitor's <em>Store</em> page:</p>
<center> <div class="image">
<img src="webmon_store.png" alt="webmon_store.png"/>
</div>
  </center><p>This page shows the following information about the store.</p>
<table class="doxtable">
<tr>
<th>Item </th><th><p class="starttd">Description</p>
<p class="endtd"></p>
</th></tr>
<tr>
<td>Interface </td><td><p class="starttd">This store is listening on all interfaces (0.0.0.0) on port 38401.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Cache Dir </td><td><p class="starttd">Pathname for disk store message cache directory. This would be configured as a store attribute in the store's XML configuration file. For example: <br />
<a class="el" href="index.html#umecfgdiskcachedirectory">&lt;option type="store" name="disk-cache-directory" value="cache/" /&gt;</a></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>State Dir </td><td><p class="starttd">Pathname for disk store state directory. This would be configured as a store attribute in the store's XML configuration file. For example: <br />
<a class="el" href="index.html#umecfgdiskstatedirectory">&lt;option type="store" name="disk-state-directory" value="state/" /&gt;</a></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Configured Retransmission Request Processing Rate </td><td><p class="starttd">Current value for the store's <a class="el" href="index.html#umecfgretransmissionrequestprocessingrate">retransmission-request-processing-rate</a> option setting.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Total Seconds Used for Rate Calculations </td><td><p class="starttd">Accumulating counter that displays the number of seconds since the last rate reset. The Web Monitor divides the Retransmission Request Received, Retransmission Request Service and Retransmission Request Drop totals by the Total Seconds to calculate the rates displayed. If you click the Reset Rate Stats, the Web Monitor resets this value to zero.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Retransmission Request Received Rate </td><td><p class="starttd">Number of retransmission requests received per second.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Retransmission Request Service Rate </td><td><p class="starttd">Number of retransmission requests serviced per second.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Retransmission Request Drop Rate </td><td><p class="starttd">Number of retransmission requests dropped per second. Requests are dropped if the rate of retransmission requests exceeds the configured retransmission request rate.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Retransmission Request Total Dropped </td><td><p class="starttd">The number of retransmission requests since the time the store was started.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Patterns </td><td><p class="starttd">Specifies the wildcard pattern used to select topics for which a store will provide persistence services. This would be configured as a topic attribute in the store's XML configuration file. For example: <a class="el" href="index.html#umecfgpattern">&lt;topic pattern="test.*" type="PCRE"&gt;</a></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Topics </td><td><p class="starttd">Displays the topic names and Registration ID (Session ID) for any sources publishing on the topic. The screen examples display one topic, test1 - 2504558780(39307788). Each Registration ID (Session ID) is a clickable link, which displays the <a class="el" href="index.html#storewebmonitorsourcepage">Store Web Monitor Source Page</a> for that source.</p>
<p class="endtd"><a class="anchor" id="resetratestats"></a></p>
</td></tr>
<tr>
<td>Reset Rate Stats </td><td>Click the Reset Rate Stats link to reset the retransmission rates. After clicking the link, The Web Monitor rests Total Seconds Used for Rate Calculations to zero and displays a page with the store number and the message, '<code>Rate Statistics have been reset</code>'. </td></tr>
</table>
<p><br />
 </p>
<h2><a class="anchor" id="storewebmonitorsourcepage"></a>
Store Web Monitor Source Page&nbsp;&nbsp;<small><a href="#storewebmonitorsourcepage">&lt;-</a></small></h2>
<p>Here is an image of the Web Monitor's <em>Source</em> page:</p>
<center> <div class="image">
<img src="webmon_source.png" alt="webmon_source.png"/>
</div>
  </center><p>The first line in the page contains is interpreted as follows:</p>
<table class="doxtable">
<tr>
<td>2504558780 </td><td><p class="starttd">The source's registration ID.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>10.29.3.42.14392 </td><td><p class="starttd">The IP address and port of the source's UM configuration option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpunicastimmediatemessagingnetwork.html#requesttcpportcontext">request_tcp_port (context)</a>.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>3958260924 </td><td><p class="starttd">The source's transport session index.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>1161732811 </td><td>The source's topic index within the transport session, 3958260924. </td></tr>
</table>
<p>The remaining fields are described in the following table:</p>
<table class="doxtable">
<tr>
<th>Source Page Item </th><th><p class="starttd">Description</p>
<p class="endtd"></p>
</th></tr>
<tr>
<td>Topic </td><td><p class="starttd">test is the source's topic string.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Session ID </td><td><p class="starttd">39307788 is the source's Session ID.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Last Activity </td><td><p class="starttd">09:19:39.501350 is the timestamp when the store last heard from the source, including keepalives sent by UM</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Repository </td><td><p class="starttd">disk is the type of repository. Possible values are memory, disk or reduced-fd.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Receiver Paced Persistence </td><td><p class="starttd">Setting for Receiver-paced Persistence (RPP), which is a repository option both the repository and source must enable. A value of 0 means RPP is not enabled and the repository is using the default Source-paced persistence. A value of 1 means RPP is enabled.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Message Map: 3120 </td><td><p class="starttd">The total number of message fragments the store has for this source, both on disk and in memory. These are UM-level fragments, not IP-level fragments. UM messages are fragmented into roughly 8 kilobyte chunks for UDP-based protocols (LBT-RM and LBT-RU) and into roughly 64 kilobyte chunks for LBT-TCP. The majority of application messages tend to be well under the fragment boundaries, so the value after "Message Map" could be used as a rough estimate of the number of messages in the store from this particular source. It's at least a strict upper bound.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Window: [0, 9d5, c2f] </td><td><p class="starttd">Window format is: trail_sqn, mem_trail_sqn, lead_sqn <br />
<br />
</p><ul>
<li>trail_sqn, 0, is the trailing sequence number, which is the oldest sequence number in the store for this source. In most cases, this starts at 0 and stays there for a while. The trailing sequence number changes if the store reaches a disk file size limit and then deletes the oldest messages. <br />
<br />
</li>
<li>mem_trail_sqn, 9d5, is the trailing sequence number for messages in memory. It is the oldest sequence number still in memory. Typically, you might have more sequence numbers on disk than you do in memory, or possibly the same number. <br />
<br />
</li>
<li>lead_sqn, c2f, is the leading sequence number, which is the newest sequence number in the store. <br />
<br />
 Note: For a memory store, the first and second values would always be the same. The oldest sequence number in memory is the oldest in the store, so only two values are displayed. The trailing sequence number and the leading sequence number.</li>
</ul>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Memory: 55986 / 65000 / 50331648 </td><td><p class="starttd">Memory format is: repository memory size / repository size threshold / repository size limit <br />
<br />
</p><ul>
<li>repository memory size, 55986, is the number of bytes of messages in memory, which includes headers and store overhead. <br />
<br />
</li>
<li>repository size threshold, 65000, is the <a class="el" href="index.html#umecfgrepositorysizethreshold">repository-size-threshold</a> topic option found in the store's XML configuration file. <br />
<br />
</li>
<li>repository size limit, 50331648, is the store's <a class="el" href="index.html#umecfgrepositorysizelimit">repository-size-limit</a> topic option found in the store's XML configuration file. <br />
<br />
 You would expect the number of bytes in memory to be under the threshold most of the time, but it could spike above it before going back down if the store is really busy momentarily. It should never go above the limit.</li>
</ul>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Age Threshold: 0 </td><td><p class="starttd">Age Threshold, 0, is the store's <a class="el" href="index.html#umecfgrepositoryagethreshold">repository-age-threshold</a> topic option found in the store's XML configuration file.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Sync: [c2f, c2f, c2f] </td><td><p class="starttd">Pertains to disk or reduced-fd repositories only. Sync format is: sync_complete_sqn, sync_sqn, contig_sqn <br />
<br />
</p><ul>
<li>sync_complete_sqn, c2f, Most recent sequence number that the Operating System has confirmed persisting to disk. <br />
<br />
</li>
<li>sync_sqn, c2f, Most recent sequence number for which the store has initiated persisting to disk, but the Operating System has not confirmed completion of persistence. <br />
<br />
</li>
<li>contig_sqn, c2f, Most recent sequence number that along with the trail_sqn, creates a range of sequence numbers with no sequence number gaps. For example, if trail_sqn = 0 and the store has persisted all eleven messages with sequence numbers 0 through 10, contig_sqn would equal 10. contig_sqn would also be 10 if a receiver declared message sequence number 7 unrecoverably lost. contig_sqn would be 6 if message sequence number 7 was not persisted, but not declared lost.</li>
</ul>
<p class="endtd"></p>
</td></tr>
<tr>
<td>In progress: 0 / 0 </td><td><p class="starttd">Pertains to disk or reduced-fd repositories only. In progress format is: num_ios_pending / num_read_ios_pending <br />
<br />
</p><ul>
<li>num_ios_pending, 0, Number of disk writes the store has submitted to the Operation System. A disk write refers to the store persisting a message to disk. <br />
<br />
</li>
<li>num_read_ios_pending, 0, Number of disk reads that the store has submitted to the Operating System. A disk read, for example, results from an application retransmission request.</li>
</ul>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Offsets: 0 / 190320 / 4294967296 </td><td><p class="starttd">Pertains to disk or reduced-fd repositories only. Offsets format is: start_offset, offset, max_offset <br />
<br />
</p><ul>
<li>start_offset, 0, The relative location of the first message, trail_sqn, in the disk. start_offset is 0 for a reduced-fd repository. <br />
<br />
</li>
<li>offset, 190320, The relative location of where the message , contig_sqn plus one will be written. offset represents the size of the repository on disk for a reduced-fd repository. <br />
<br />
</li>
<li>max_offset, 4294967296, The maximum size of the cache file. max_offset is the maximum repository size on disk for a reduced-fd repository.</li>
</ul>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Active ULBs: 0 high 0 </td><td><p class="starttd">ULB stands for Unrecoverable Loss Burst. A little extra work is required to keep cache files consistent when the store gets an unrecoverable loss burst, because unrecoverable loss bursts are delivered all at once for lots of messages, rather than one at a time like normal unrecoverable loss messages. <br />
<br />
 Active ULB is the number of unrecoverable loss burst events the store is dealing with at the moment. It'll go to zero after the ULB has been resolved. <br />
<br />
 The high number (0) is the highest sequence number reported among any unrecoverable loss burst event, and is not reset after the ULB is handled; it increments throughout the process life of the store. <br />
<br />
 <b>WARNING</b>: If you see any number other than 0 here, the store is losing large numbers of messages, and they are likely not being persisted.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Loss: 0 ULBs 0 </td><td><p class="starttd">These values are counters for number of unrecoverable loss messages (Loss) and for number of unrecoverable burst loss messages (ULB). These start at 0 when the store starts up and aren't reset until the store exits. They don't include any loss events that were persisted to disk from a previous run, only new loss events since the store started. There are cases with UME 2.0 where one individual store could legitimately report some unrecoverable loss, or maybe even unrecoverable loss bursts. <br />
<br />
 <b>WARNING</b>: If you see any number other than 0 for either of these counters, you should investigate.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Drops: 0 / 0 </td><td><p class="starttd">If the store is nearing the <a class="el" href="index.html#umecfgrepositorysizelimit">repository-size-limit</a> and gets another message, the store will intentionally drop a message. A drop requires a bit of work on the store's part. <br />
<br />
 The first 0 is the number of active drops, which are drops that are currently being worked on. <br />
<br />
 The second 0 is the total number of drops that have happened for this store since it was started. Some people want a low <a class="el" href="index.html#umecfgrepositorysizelimit">repository-size-limit</a> and therefore lots of intentional drops can occur. Some don't want to drop any message the whole day - so the interpretation of the values is up to you.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>LBM Stats </td><td><p class="starttd">These represent transport-level statistics for the underlying receivers in the store for the source. The example shown is for a TCP source, so not too many stats are available (stats for a TCP source are less important from a monitoring perspective). <br />
<br />
 Statistics for an LBT-RM or LBT-RU source, however, show number of NAKs sent, which is important. Ideally, the number of NAKs sent should be 0. A few NAKs from a store throughout the day is not an emergency. It can be, however, an early warning sign of more severe problems, and should be taken seriously. <br />
<br />
 If you see a non-zero number of NAKs here, take a look at the overall network load the store's machine is attempting to handle, particularly in very busy periods and spikes; it may be too much.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Receivers </td><td>Registration IDs and accompanying Session ID for the receivers listening on the source's topic. Click on the receiver Registration ID (Session ID) to display the <a class="el" href="index.html#storewebmonitorreceiverpage">Store Web Monitor Receiver Page</a> to review information about the receivers for that persisted topic. </td></tr>
</table>
<p><br />
 </p>
<h2><a class="anchor" id="storewebmonitorreceiverpage"></a>
Store Web Monitor Receiver Page&nbsp;&nbsp;<small><a href="#storewebmonitorreceiverpage">&lt;-</a></small></h2>
<p>Here is an image of the Web Monitor's <em>Receiver</em> page:</p>
<center> <div class="image">
<img src="webmon_receiver.png" alt="webmon_receiver.png"/>
</div>
  </center><p>The first line in the page contains is interpreted as follows:</p>
<table class="doxtable">
<tr>
<td>2504558781 </td><td><p class="starttd">The receiver's registration ID.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>10.29.3.42.14393 </td><td><p class="starttd">The IP address and port of the source's UM configuration option, <a class="elRef" doxygen="/29W/Amun/home/jenkins/backup_exclude.1/rc/UMQ_6.12_RC3/doc/UME/config.tag:../../Config/" href="../../Config/grpunicastimmediatemessagingnetwork.html#requesttcpportcontext">request_tcp_port (context)</a>.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>1510613393 </td><td><p class="starttd">The receiver's transport session index.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>1161732811 </td><td>The source's topic index within the transport session, 1510613393. </td></tr>
</table>
<p>The remaining fields are described in the following table:</p>
<table class="doxtable">
<tr>
<th>Receiver Page Item </th><th><p class="starttd">Description</p>
<p class="endtd"></p>
</th></tr>
<tr>
<td>Topic </td><td><p class="starttd">The topic that the receiver is listening on.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Last Activity </td><td><p class="starttd">09:09:35.981110 is the timestamp of when the store last heard from the receiver, including keepalives sent by UM.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Source RegID </td><td><p class="starttd">Registration ID of the source publishing on the topic. Click on the Registration ID link to display the <a class="el" href="index.html#storewebmonitorsourcepage">Store Web Monitor Source Page</a>.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Source Session ID </td><td><p class="starttd">The Session ID of the Source sending messages on the topic.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>ACK </td><td>c93 is the last message sequence number the receiver acknowledged. </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
</body>
</html>
